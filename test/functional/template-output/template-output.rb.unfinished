#!/usr/bin/ruby
# encoding: utf-8

require 'antlr3/test/functional'

class TestTemplateOutput < ANTLR3::Test::Functional
  
  example 'inline templates' do
    parse(<<-'END')
      grammar InlineTemplates;
      options {
        language=Ruby;
        output=template;
      }
      
      a : ID INT
        -> template(id={$ID.text}, int={$INT.text})
           "id=<%= id %>, int=<%= int %>"
      ;
      
      ID : 'a'..'z'+;
      INT : '0'..'9'+;
      WS : (' '|'\n') {$channel=HIDDEN;} ;
    END
  end

  
  #def execParser(self, grammar, grammarEntry, input, group=None):
  #    lexerCls, parserCls = self.compileInlineGrammar(grammar)
  #
  #    cStream = antlr3.StringStream(input)
  #    lexer = lexerCls(cStream)
  #    tStream = antlr3.CommonTokenStream(lexer)
  #    parser = parserCls(tStream)
  #    if group is not None:
  #        parser.templateLib = group
  #    result = getattr(parser, grammarEntry)()
  #    if result.st is not None:
  #        return result.st.toString()
  #    return None
  #
  #
  #def testInlineTemplate(self):
  #    grammar = textwrap.dedent(
  #        r'''
  #        grammar T;
  #        options {
  #          language=Python;
  #          output=template;
  #        }
  #        a : ID INT
  #          -> template(id={$ID.text}, int={$INT.text})
  #             "id=<id>, int=<int>"
  #        ;
  #        
  #        ID : 'a'..'z'+;
  #        INT : '0'..'9'+;
  #        WS : (' '|'\n') {$channel=HIDDEN;} ;
  #        '''
  #        )
  #
  #    found = self.execParser(
  #        grammar, 'a',
  #        "abc 34"
  #        )
  #
  #    self.failUnlessEqual("id=abc, int=34", found)
  #
  #
  #def testExternalTemplate(self):
  #    templates = textwrap.dedent(
  #        '''\
  #        group T;
  #        expr(args, op) ::= <<
  #        [<args; separator={<op>}>]
  #        >>
  #        '''
  #        )
  #
  #    group = stringtemplate3.StringTemplateGroup(
  #        file=StringIO(templates),
  #        lexer='angle-bracket'
  #        )
  #    
  #    grammar = textwrap.dedent(
  #        r'''grammar T2;
  #        options {
  #          language=Python;
  #          output=template;
  #        }
  #        a : r+=arg OP r+=arg
  #            -> expr(op={$OP.text}, args={$r})
  #        ;
  #        arg: ID -> template(t={$ID.text}) "<t>";
  #        
  #        ID : 'a'..'z'+;
  #        OP: '+';
  #        WS : (' '|'\n') {$channel=HIDDEN;} ;
  #        '''
  #        )
  #
  #    found = self.execParser(
  #        grammar, 'a',
  #        "a + b",
  #        group
  #        )
  #
  #    self.failUnlessEqual("[a+b]", found)
  #
  #
  
  example "inline template" do
    grammar = <<-'END'
      grammar InlineTemplate;
      options {
        language=Ruby;
        output=template;
      }
      a : ID INT
        -> template(id={$ID.text}, int={$INT.text})
           "id=<%= id %>, int=<%= int %>"
      ;
      
      ID : 'a'..'z'+;
      INT : '0'..'9'+;
      WS : (' '|'\n') {$channel=HIDDEN;} ;
  
    END
  end
  
  example "external template" do
    grammar = <<-'END'
      grammar ExternalTemplate;
      options {
        language=Ruby;
        output=template;
      }
      a : r+=arg OP r+=arg
        -> expr(op={$OP.text}, args={$r})
      ;
      arg: ID -> template(t={$ID.text}) "<%= t %>";
      
      ID : 'a'..'z'+;
      OP: '+';
      WS : (' '|'\n') {$channel=HIDDEN;} ;
  
    END
  end
  
  example "empty template" do
    grammar = <<-'END'
      grammar EmptyTemplate;
      options {
        language=Ruby;
        output=template;
      }
      a : ID INT
        -> 
      ;
      
      ID : 'a'..'z'+;
      INT : '0'..'9'+;
      WS : (' '|'\n') {$channel=HIDDEN;} ;
  
    END
  end
  
  example "list" do
    grammar = <<-'END'
      grammar List;
      options {
        language=Ruby;
        output=template;
      }
      a: (r+=b)* EOF
        -> template(r={$r})
           "<%= r.join(',') %>"
      ;
      
      b: ID
        -> template(t={$ID.text}) "<%= t %>"
      ;
      
      ID : 'a'..'z'+;
      WS : (' '|'\n') {$channel=HIDDEN;} ;
  
    END
  end
  
  example "action" do
    grammar = <<-'END'
      grammar Action;
      options {
        language=Ruby;
        output=template;
      }
      a: ID
        -> { stringtemplate3.StringTemplate("hello") }
      ;
      
      ID : 'a'..'z'+;
      WS : (' '|'\n') {$channel=HIDDEN;} ;
  
    END
  end
  
  example "template expression in action" do
    grammar = <<-'END'
      grammar TemplateExpressionInAction;
      options {
        language=Ruby;
        output=template;
      }
      a: ID
        { $st = %{"hello"} }
      ;
      
      ID : 'a'..'z'+;
      WS : (' '|'\n') {$channel=HIDDEN;} ;
  
    END
  end
  
  example "template expression in action2" do
    grammar = <<-'END'
      grammar TemplateExpressionInAction2;
      options {
        language=Ruby;
        output=template;
      }
      a: ID
        {
          res = %{"hello <%= foo %>"}
          %res.foo = "world";
        }
        -> { res }
      ;
      
      ID : 'a'..'z'+;
      WS : (' '|'\n') {$channel=HIDDEN;} ;
  
    END
  end
  
  example "indirect template constructor" do
    grammar = <<-'END'
      grammar IndirectTemplateConstructor;
      options {
        language=Ruby;
        output=template;
      }
      
      a: ID
        {
          $st = %({"expr"})(args={[1, 2, 3]}, op={"+"})
        }
      ;
      
      ID : 'a'..'z'+;
      WS : (' '|'\n') {$channel=HIDDEN;} ;
  
    END
  end
  
  example "predicates" do
    grammar = <<-'END'
      grammar Predicates;
      options {
        language=Ruby;
        output=template;
      }
      a : ID INT
        -> {$ID.text=='a'}? template(int={$INT.text})
                            "A: <%= int %>"
        -> {$ID.text=='b'}? template(int={$INT.text})
                            "B: <%= int %>"
        ->                  template(int={$INT.text})
                            "C: <%= int %>"
      ;
      
      ID : 'a'..'z'+;
      INT : '0'..'9'+;
      WS : (' '|'\n') {$channel=HIDDEN;} ;
  
    END
  end
  
  example "backtracking mode" do
    grammar = <<-'END'
      grammar BacktrackingMode;
      options {
        language=Ruby;
        output=template;
        backtrack=true;
      }
      a : (ID INT)=> ID INT
        -> template(id={$ID.text}, int={$INT.text})
           "id=<%= id %>, int=<%= int %>"
      ;
      
      ID : 'a'..'z'+;
      INT : '0'..'9'+;
      WS : (' '|'\n') {$channel=HIDDEN;} ;
  
    END
  end
  
  example "rewrite" do
    grammar = <<-'END'
      grammar Rewrite;
      options {
        language=Ruby;
        output=template;
        rewrite=true;
      }
      
      prog: stat+;
      
      stat
          : 'if' '(' expr ')' stat
          | 'return' return_expr ';'
          | '{' stat* '}'
          | ID '=' expr ';'
          ;
      
      return_expr
          : expr
            -> template(t={$text}) <<boom(<%= t %>)>>
          ;
          
      expr
          : ID
          | INT
          ;
          
      ID:  'a'..'z'+;
      INT: '0'..'9'+;
      WS: (' '|'\n')+ {$channel=HIDDEN;} ;
      COMMENT: '/*' (options {greedy=false;} : .)* '*/' {$channel = HIDDEN;} ;
  
    END
  end
  
  example "tree rewrite" do
    grammar = <<-'END'
      grammar TreeRewrite;
      options {
        language=Ruby;
        output=AST;
      }
      
      tokens {
        BLOCK;
        ASSIGN;
      }
      
      prog: stat+;
      
      stat
          : IF '(' e=expr ')' s=stat
            -> ^(IF $e $s)
          | RETURN expr ';'
            -> ^(RETURN expr)
          | '{' stat* '}'
            -> ^(BLOCK stat*)
          | ID '=' expr ';'
            -> ^(ASSIGN ID expr)
          ;
          
      expr
          : ID
          | INT
          ;
      
      IF: 'if';
      RETURN: 'return';
      ID:  'a'..'z'+;
      INT: '0'..'9'+;
      WS: (' '|'\n')+ {$channel=HIDDEN;} ;
      COMMENT: '/*' (options {greedy=false;} : .)* '*/' {$channel = HIDDEN;} ;
  
    END
  end
end