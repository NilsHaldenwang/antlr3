<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_16) on Wed Oct 14 09:00:06 EDT 2009 -->
<TITLE>
Grammar
</TITLE>

<META NAME="date" CONTENT="2009-10-14">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Grammar";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/antlr/tool/FASerializer.html" title="class in org.antlr.tool"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../org/antlr/tool/Grammar.Decision.html" title="class in org.antlr.tool"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/antlr/tool/Grammar.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Grammar.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.antlr.tool</FONT>
<BR>
Class Grammar</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>org.antlr.tool.Grammar</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>Grammar</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
Represents a grammar in memory.
<P>

<P>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Nested Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.Decision.html" title="class in org.antlr.tool">Grammar.Decision</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.LabelElementPair.html" title="class in org.antlr.tool">Grammar.LabelElementPair</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#actions">actions</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Map a scope to a map of name:action pairs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#allDecisionDFACreated">allDecisionDFACreated</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#ANTLRLiteralCharValueEscape">ANTLRLiteralCharValueEscape</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given a char, we need to be able to show as an ANTLR literal.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#ANTLRLiteralEscapedCharValue">ANTLRLiteralEscapedCharValue</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When converting ANTLR char and string literals, here is the
  value set of escape chars.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#ARTIFICIAL_TOKENS_RULENAME">ARTIFICIAL_TOKENS_RULENAME</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#atLeastOneBacktrackOption">atLeastOneBacktrackOption</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;At least one backtrack=true in rule or decision or grammar.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#atLeastOneRuleMemoizes">atLeastOneRuleMemoizes</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;At least one rule has memoize=true</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#AUTO_GENERATED_TOKEN_NAME_PREFIX">AUTO_GENERATED_TOKEN_NAME_PREFIX</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;<A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#blocksWithSemPreds">blocksWithSemPreds</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Track decisions with syn preds specified for reporting.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;<A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#blocksWithSynPreds">blocksWithSynPreds</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Track decisions with syn preds specified for reporting.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#builtFromString">builtFromString</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;We need a way to detect when a lexer grammar is autogenerated from
  another grammar or we are just sending in a string representing a
  grammar.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#CHAR_LABEL">CHAR_LABEL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../org/antlr/misc/IntSet.html" title="interface in org.antlr.misc">IntSet</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#charVocabulary">charVocabulary</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TODO: hook this to the charVocabulary option</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#COMBINED">COMBINED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/tool/CompositeGrammar.html" title="class in org.antlr.tool">CompositeGrammar</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#composite">composite</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If this grammar is part of a larger composite grammar via delegate
  statement, then this points at the composite.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/tool/CompositeGrammarTree.html" title="class in org.antlr.tool">CompositeGrammarTree</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#compositeTreeNode">compositeTreeNode</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A pointer back into grammar tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#decisionCount">decisionCount</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Be able to assign a number to every decision in grammar;
  decisions in 1..n</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;<A HREF="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#decisionsWhoseDFAsUsesSemPreds">decisionsWhoseDFAsUsesSemPreds</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Track decisions that actually use the syn preds in the DFA.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;<A HREF="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#decisionsWhoseDFAsUsesSynPreds">decisionsWhoseDFAsUsesSynPreds</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Track decisions that actually use the syn preds in the DFA.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#defaultBlockOptions">defaultBlockOptions</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;What are the default options for a subrule?</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#defaultLexerBlockOptions">defaultLexerBlockOptions</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#defaultOptions">defaultOptions</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#defaultTokenOption">defaultTokenOption</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Set&lt;<A HREF="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#delegatedRuleReferences">delegatedRuleReferences</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The list of all rules referenced in this grammar, not defined here,
  and defined in a delegate grammar.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#DFACreationWallClockTimeInMS">DFACreationWallClockTimeInMS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;How long in ms did it take to build DFAs for this grammar?
  If this grammar is a combined grammar, it only records time for
  the parser grammar component.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Set</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#doNotCopyOptionsToLexer">doNotCopyOptionsToLexer</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#externalAnalysisAbort">externalAnalysisAbort</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An external tool requests that DFA analysis abort prematurely.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../org/antlr/tool/NFAFactory.html" title="class in org.antlr.tool">NFAFactory</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#factory">factory</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#fileName">fileName</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;What file name holds this grammar?</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#FRAGMENT_RULE_MODIFIER">FRAGMENT_RULE_MODIFIER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../org/antlr/codegen/CodeGenerator.html" title="class in org.antlr.codegen">CodeGenerator</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#generator">generator</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If non-null, this is the code generator we will use to generate
  recognizers in the target language.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#global_k">global_k</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Is there a global fixed lookahead set for this grammar?
  If 0, nothing specified.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#GRAMMAR_FILE_EXTENSION">GRAMMAR_FILE_EXTENSION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#grammarTree">grammarTree</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An AST that records entire input grammar with all rules.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#grammarTypeToFileNameSuffix">grammarTypeToFileNameSuffix</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#grammarTypeToString">grammarTypeToString</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#IGNORE_STRING_IN_GRAMMAR_FILE_NAME">IGNORE_STRING_IN_GRAMMAR_FILE_NAME</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#implicitLexer">implicitLexer</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Was this created from a COMBINED grammar?</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Vector&lt;<A HREF="../../../org/antlr/tool/Grammar.Decision.html" title="class in org.antlr.tool">Grammar.Decision</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#indexToDecision">indexToDecision</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Each subrule/rule is a decision point and we must track them so we
  can go back later and build DFA predictors for them.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#INITIAL_DECISION_LIST_SIZE">INITIAL_DECISION_LIST_SIZE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#INVALID_RULE_INDEX">INVALID_RULE_INDEX</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#label">label</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If this is a delegate of another grammar, this is the label used
  as an instance var by that grammar to point at this grammar.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#LabelTypeToString">LabelTypeToString</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Set&lt;<A HREF="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#leftRecursiveRules">leftRecursiveRules</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A list of all rules that are in any left-recursive cycle.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Set</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#legalBlockOptions">legalBlockOptions</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Set</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#legalLexerOptions">legalLexerOptions</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Set</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#legalParserOptions">legalParserOptions</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Set</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#legalTokenOptions">legalTokenOptions</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Legal options for terminal refs like ID<node=MyVarNode></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Set</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#legalTreeParserOptions">legalTreeParserOptions</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#LEXER">LEXER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#LEXER_GRAMMAR_FILE_EXTENSION">LEXER_GRAMMAR_FILE_EXTENSION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;used for generating lexer temp files</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;org.antlr.stringtemplate.StringTemplate</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#lexerGrammarST">lexerGrammarST</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For merged lexer/parsers, we must construct a separate lexer spec.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#lexerRuleNamesInCombined">lexerRuleNamesInCombined</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The ANTLRParser tracks lexer rules when reading combined grammars
  so we can build the Tokens rule.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/analysis/LL1Analyzer.html" title="class in org.antlr.analysis">LL1Analyzer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#ll1Analyzer">ll1Analyzer</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#name">name</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;What name did the user provide for this grammar?</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/tool/NameSpaceChecker.html" title="class in org.antlr.tool">NameSpaceChecker</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#nameSpaceChecker">nameSpaceChecker</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.LinkedHashMap&lt;java.lang.String,<A HREF="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#nameToRuleMap">nameToRuleMap</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Map a rule to it's Rule object</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.LinkedHashMap</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#nameToSynpredASTMap">nameToSynpredASTMap</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When we read in a grammar, we track the list of syntactic predicates
  and build faux rules for them later.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/analysis/NFA.html" title="class in org.antlr.analysis">NFA</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#nfa">nfa</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The NFA that represents the grammar with edges labelled with tokens
  or epsilon.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#numberOfManualLookaheadOptions">numberOfManualLookaheadOptions</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#numberOfSemanticPredicates">numberOfSemanticPredicates</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#options">options</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A list of options specified at the grammar level such as language=Java.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#overriddenRules">overriddenRules</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If this rule is a delegate, some rules might be overridden; don't
  want to gen code for them.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#PARSER">PARSER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#RULE_LABEL">RULE_LABEL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#RULE_LIST_LABEL">RULE_LIST_LABEL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Set&lt;<A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#ruleRefs">ruleRefs</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The unique set of all rule references in any rule; set of tree node
  objects so two refs to same rule can exist but at different line/position.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Set&lt;<A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#scopedRuleRefs">scopedRuleRefs</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#scopes">scopes</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Track the scopes defined outside of rules and the scopes associated
  with all rules (even if empty).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#setOfDFAWhoseAnalysisTimedOut">setOfDFAWhoseAnalysisTimedOut</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;java.lang.Integer&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#setOfNondeterministicDecisionNumbers">setOfNondeterministicDecisionNumbers</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;java.lang.Integer&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#setOfNondeterministicDecisionNumbersResolvedWithPredicates">setOfNondeterministicDecisionNumbersResolvedWithPredicates</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#SYNPRED_RULE_PREFIX">SYNPRED_RULE_PREFIX</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#SYNPREDGATE_ACTION_NAME">SYNPREDGATE_ACTION_NAME</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#synPredNamesUsedInDFA">synPredNamesUsedInDFA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Track names of preds so we can avoid generating preds that aren't used
  Computed during NFA to DFA conversion.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#TOKEN_LABEL">TOKEN_LABEL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#TOKEN_LIST_LABEL">TOKEN_LIST_LABEL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;antlr.TokenStreamRewriteEngine</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#tokenBuffer">tokenBuffer</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is the buffer of *all* tokens found in the grammar file
  including whitespace tokens etc...</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Set&lt;antlr.Token&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#tokenIDRefs">tokenIDRefs</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The unique set of all token ID references in any rule</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/Tool.html" title="class in org.antlr">Tool</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#tool">tool</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#TREE_PARSER">TREE_PARSER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#type">type</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;What type of grammar is this: lexer, parser, tree walker</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/antlr/misc/MultiMap.html" title="class in org.antlr.misc">MultiMap</A>&lt;java.lang.Integer,java.lang.Integer&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#validDelegations">validDelegations</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set of valid imports.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#WILDCARD_TREE_LABEL">WILDCARD_TREE_LABEL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#WILDCARD_TREE_LIST_LABEL">WILDCARD_TREE_LIST_LABEL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#Grammar()">Grammar</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Useful for when you are sure that you are not part of a composite
  already.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#Grammar(java.lang.String)">Grammar</A></B>(java.lang.String&nbsp;grammarString)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Used for testing; only useful on noncomposite grammars.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#Grammar(org.antlr.Tool, java.lang.String)">Grammar</A></B>(<A HREF="../../../org/antlr/Tool.html" title="class in org.antlr">Tool</A>&nbsp;tool,
        java.lang.String&nbsp;grammarString)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Used for testing and Interp/RandomPhrase.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#Grammar(org.antlr.Tool, java.lang.String, org.antlr.tool.CompositeGrammar)">Grammar</A></B>(<A HREF="../../../org/antlr/Tool.html" title="class in org.antlr">Tool</A>&nbsp;tool,
        java.lang.String&nbsp;fileName,
        <A HREF="../../../org/antlr/tool/CompositeGrammar.html" title="class in org.antlr.tool">CompositeGrammar</A>&nbsp;composite)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a grammar from file name.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#addArtificialMatchTokensRule(org.antlr.tool.GrammarAST, java.util.List, java.util.List, boolean)">addArtificialMatchTokensRule</A></B>(<A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;grammarAST,
                             java.util.List&lt;java.lang.String&gt;&nbsp;ruleNames,
                             java.util.List&lt;java.lang.String&gt;&nbsp;delegateNames,
                             boolean&nbsp;filterMode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parse a rule we add artificially that is a list of the other lexer
  rules like this: "Tokens : ID | INT | SEMI ;"  nextToken() will invoke
  this to set the current token.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#addDelegateGrammar(org.antlr.tool.Grammar)">addDelegateGrammar</A></B>(<A HREF="../../../org/antlr/tool/Grammar.html" title="class in org.antlr.tool">Grammar</A>&nbsp;delegateGrammar)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add new delegate to composite tree</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#allDecisionDFAHaveBeenCreated()">allDecisionDFAHaveBeenCreated</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#altReferencesRule(java.lang.String, org.antlr.tool.GrammarAST, org.antlr.tool.GrammarAST, int)">altReferencesRule</A></B>(java.lang.String&nbsp;enclosingRuleName,
                  <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;refScopeAST,
                  <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;refAST,
                  int&nbsp;outerAltNum)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Track a rule reference within an outermost alt of a rule.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#altReferencesTokenID(java.lang.String, org.antlr.tool.GrammarAST, int)">altReferencesTokenID</A></B>(java.lang.String&nbsp;ruleName,
                     <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;refAST,
                     int&nbsp;outerAltNum)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Track a token reference within an outermost alt of a rule.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#assignDecisionNumber(org.antlr.analysis.NFAState)">assignDecisionNumber</A></B>(<A HREF="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</A>&nbsp;state)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#buildAST()">buildAST</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#buildNFA()">buildNFA</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#buildTemplate()">buildTemplate</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#checkAllRulesForLeftRecursion()">checkAllRulesForLeftRecursion</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#checkAllRulesForUselessLabels()">checkAllRulesForUselessLabels</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remove all labels on rule refs whose target rules have no return value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#checkNameSpaceAndActions()">checkNameSpaceAndActions</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ANALYZE ACTIONS, LOOKING FOR LABEL AND ATTR REFS, sanity check</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#checkRuleReference(org.antlr.tool.GrammarAST, org.antlr.tool.GrammarAST, org.antlr.tool.GrammarAST, java.lang.String)">checkRuleReference</A></B>(<A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;scopeAST,
                   <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;refAST,
                   <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;argsAST,
                   java.lang.String&nbsp;currentRuleName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/misc/IntSet.html" title="interface in org.antlr.misc">IntSet</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#complement(int)">complement</A></B>(int&nbsp;atom)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/misc/IntSet.html" title="interface in org.antlr.misc">IntSet</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#complement(org.antlr.misc.IntSet)">complement</A></B>(<A HREF="../../../org/antlr/misc/IntSet.html" title="interface in org.antlr.misc">IntSet</A>&nbsp;set)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For lexer grammars, return everything in unicode not in set.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#computeTokenNameFromLiteral(int, java.lang.String)">computeTokenNameFromLiteral</A></B>(int&nbsp;tokenType,
                            java.lang.String&nbsp;literal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;given a token type and the text of the literal, come up with a
  decent token type label.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../org/antlr/tool/Grammar.Decision.html" title="class in org.antlr.tool">Grammar.Decision</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#createDecision(int)">createDecision</A></B>(int&nbsp;decision)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#createLL_1_LookaheadDFA(int)">createLL_1_LookaheadDFA</A></B>(int&nbsp;decision)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#createLookaheadDFA(int, boolean)">createLookaheadDFA</A></B>(int&nbsp;decision,
                   boolean&nbsp;wackTempStructures)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#createLookaheadDFAs()">createLookaheadDFAs</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For each decision in this grammar, compute a single DFA using the
  NFA states associated with the decision.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#createLookaheadDFAs(boolean)">createLookaheadDFAs</A></B>(boolean&nbsp;wackTempStructures)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/tool/AttributeScope.html" title="class in org.antlr.tool">AttributeScope</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#createParameterScope(java.lang.String, antlr.Token)">createParameterScope</A></B>(java.lang.String&nbsp;ruleName,
                     antlr.Token&nbsp;argAction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/tool/AttributeScope.html" title="class in org.antlr.tool">AttributeScope</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#createReturnScope(java.lang.String, antlr.Token)">createReturnScope</A></B>(java.lang.String&nbsp;ruleName,
                  antlr.Token&nbsp;retAction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/tool/AttributeScope.html" title="class in org.antlr.tool">AttributeScope</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#createRuleScope(java.lang.String, antlr.Token)">createRuleScope</A></B>(java.lang.String&nbsp;ruleName,
                antlr.Token&nbsp;scopeAction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#createRuleStartAndStopNFAStates()">createRuleStartAndStopNFAStates</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Define all the rule begin/end NFAStates to solve forward reference
  issues.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#dealWithTreeFilterMode()">dealWithTreeFilterMode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/tool/AttributeScope.html" title="class in org.antlr.tool">AttributeScope</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#defineGlobalScope(java.lang.String, antlr.Token)">defineGlobalScope</A></B>(java.lang.String&nbsp;name,
                  antlr.Token&nbsp;scopeAction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#defineGrammarSymbols()">defineGrammarSymbols</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#defineLabel(org.antlr.tool.Rule, antlr.Token, org.antlr.tool.GrammarAST, int)">defineLabel</A></B>(<A HREF="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</A>&nbsp;r,
            antlr.Token&nbsp;label,
            <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;element,
            int&nbsp;type)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Define a label defined in a rule r; check the validity then ask the
  Rule object to actually define it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#defineLexerRuleForAliasedStringLiteral(java.lang.String, java.lang.String, int)">defineLexerRuleForAliasedStringLiteral</A></B>(java.lang.String&nbsp;tokenID,
                                       java.lang.String&nbsp;literal,
                                       int&nbsp;tokenType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If someone does PLUS='+' in the parser, must make sure we get
  "PLUS : '+' ;" in lexer not "T73 : '+';"</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#defineLexerRuleForStringLiteral(java.lang.String, int)">defineLexerRuleForStringLiteral</A></B>(java.lang.String&nbsp;literal,
                                int&nbsp;tokenType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#defineLexerRuleFoundInParser(antlr.Token, org.antlr.tool.GrammarAST)">defineLexerRuleFoundInParser</A></B>(antlr.Token&nbsp;ruleToken,
                             <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;ruleAST)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#defineNamedAction(org.antlr.tool.GrammarAST, java.lang.String, org.antlr.tool.GrammarAST, org.antlr.tool.GrammarAST)">defineNamedAction</A></B>(<A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;ampersandAST,
                  java.lang.String&nbsp;scope,
                  <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;nameAST,
                  <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;actionAST)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given @scope::name {action} define it for this grammar.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#defineRule(antlr.Token, java.lang.String, java.util.Map, org.antlr.tool.GrammarAST, org.antlr.tool.GrammarAST, int)">defineRule</A></B>(antlr.Token&nbsp;ruleToken,
           java.lang.String&nbsp;modifier,
           java.util.Map&nbsp;options,
           <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;tree,
           <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;argActionAST,
           int&nbsp;numAlts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Define a new rule.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#defineRuleListLabel(java.lang.String, antlr.Token, org.antlr.tool.GrammarAST)">defineRuleListLabel</A></B>(java.lang.String&nbsp;ruleName,
                    antlr.Token&nbsp;label,
                    <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;element)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#defineRuleRefLabel(java.lang.String, antlr.Token, org.antlr.tool.GrammarAST)">defineRuleRefLabel</A></B>(java.lang.String&nbsp;ruleName,
                   antlr.Token&nbsp;label,
                   <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;ruleRef)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#defineSyntacticPredicate(org.antlr.tool.GrammarAST, java.lang.String)">defineSyntacticPredicate</A></B>(<A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;blockAST,
                         java.lang.String&nbsp;currentRuleName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Define a new predicate and get back its name for use in building
  a semantic predicate reference to the syn pred.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#defineToken(java.lang.String, int)">defineToken</A></B>(java.lang.String&nbsp;text,
            int&nbsp;tokenType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Define a token at a particular token type value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#defineTokenListLabel(java.lang.String, antlr.Token, org.antlr.tool.GrammarAST)">defineTokenListLabel</A></B>(java.lang.String&nbsp;ruleName,
                     antlr.Token&nbsp;label,
                     <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;element)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#defineTokenRefLabel(java.lang.String, antlr.Token, org.antlr.tool.GrammarAST)">defineTokenRefLabel</A></B>(java.lang.String&nbsp;ruleName,
                    antlr.Token&nbsp;label,
                    <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;tokenRef)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#defineWildcardTreeLabel(java.lang.String, antlr.Token, org.antlr.tool.GrammarAST)">defineWildcardTreeLabel</A></B>(java.lang.String&nbsp;ruleName,
                        antlr.Token&nbsp;label,
                        <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;tokenRef)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#defineWildcardTreeListLabel(java.lang.String, antlr.Token, org.antlr.tool.GrammarAST)">defineWildcardTreeListLabel</A></B>(java.lang.String&nbsp;ruleName,
                            antlr.Token&nbsp;label,
                            <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;tokenRef)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#examineAllExecutableActions()">examineAllExecutableActions</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Before generating code, we examine all actions that can have
  $x.y and $y stuff in them because some code generation depends on
  Rule.referencedPredefinedRuleAttributes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#externallyAbortNFAToDFAConversion()">externallyAbortNFAToDFAConversion</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Terminate DFA creation (grammar analysis).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/analysis/LookaheadSet.html" title="class in org.antlr.analysis">LookaheadSet</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#FIRST(org.antlr.analysis.NFAState)">FIRST</A></B>(<A HREF="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</A>&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#generateMethodForRule(java.lang.String)">generateMethodForRule</A></B>(java.lang.String&nbsp;ruleName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Should codegen.g gen rule for ruleName?
        If synpred, only gen if used in a DFA.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getActions()">getActions</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/misc/IntSet.html" title="interface in org.antlr.misc">IntSet</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getAllCharValues()">getAllCharValues</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If there is a char vocabulary, use it; else return min to max char
  as defined by the target.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;<A HREF="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getAllImportedRules()">getAllImportedRules</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get set of all rules imported from all delegate grammars even if
  indirectly delegated.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getANTLRCharLiteralForChar(int)">getANTLRCharLiteralForChar</A></B>(int&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a string representing the escaped char for code c.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getArtificialRulesForSyntacticPredicates(org.antlr.grammar.v2.ANTLRParser, java.util.LinkedHashMap)">getArtificialRulesForSyntacticPredicates</A></B>(org.antlr.grammar.v2.ANTLRParser&nbsp;parser,
                                         java.util.LinkedHashMap&nbsp;nameToSynpredASTMap)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for any syntactic predicates, we need to define rules for them; they will get
  defined automatically like any other rule.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getAutoBacktrackMode(int)">getAutoBacktrackMode</A></B>(int&nbsp;decision)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getBlockOption(org.antlr.tool.GrammarAST, java.lang.String)">getBlockOption</A></B>(<A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;blockAST,
               java.lang.String&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getCharValueFromGrammarCharLiteral(java.lang.String)">getCharValueFromGrammarCharLiteral</A></B>(java.lang.String&nbsp;literal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given a literal like (the 3 char sequence with single quotes) 'a',
  return the int value of 'a'.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/codegen/CodeGenerator.html" title="class in org.antlr.codegen">CodeGenerator</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getCodeGenerator()">getCodeGenerator</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../org/antlr/tool/Grammar.Decision.html" title="class in org.antlr.tool">Grammar.Decision</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getDecision(int)">getDecision</A></B>(int&nbsp;decision)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getDecisionBlockAST(int)">getDecisionBlockAST</A></B>(int&nbsp;decision)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getDecisionNFAStartState(int)">getDecisionNFAStartState</A></B>(int&nbsp;decision)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getDecisionNFAStartStateList()">getDecisionNFAStartStateList</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getDefaultActionScope(int)">getDefaultActionScope</A></B>(int&nbsp;grammarType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given a grammar type, what should be the default action scope?
  If I say @members in a COMBINED grammar, for example, the
  default scope should be "parser".</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;<A HREF="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getDelegatedRuleReferences()">getDelegatedRuleReferences</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;<A HREF="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getDelegatedRules()">getDelegatedRules</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the set of Rules that need to have manual delegations
  like "void rule() { importedGrammar.rule(); }"

  If this grammar is master, get list of all rule definitions from all
  delegate grammars.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getDelegateNames()">getDelegateNames</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List&lt;<A HREF="../../../org/antlr/tool/Grammar.html" title="class in org.antlr.tool">Grammar</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getDelegates()">getDelegates</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get list of all delegates from all grammars directly or indirectly
  imported into this grammar.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/tool/Grammar.html" title="class in org.antlr.tool">Grammar</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getDelegator()">getDelegator</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Who's my direct parent grammar?</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List&lt;<A HREF="../../../org/antlr/tool/Grammar.html" title="class in org.antlr.tool">Grammar</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getDelegators()">getDelegators</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get list of all delegators.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List&lt;<A HREF="../../../org/antlr/tool/Grammar.html" title="class in org.antlr.tool">Grammar</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getDirectDelegates()">getDirectDelegates</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getFileName()">getFileName</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/tool/AttributeScope.html" title="class in org.antlr.tool">AttributeScope</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getGlobalScope(java.lang.String)">getGlobalScope</A></B>(java.lang.String&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a global scope</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getGlobalScopes()">getGlobalScopes</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getGrammarIsRoot()">getGrammarIsRoot</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getGrammarMaxLookahead()">getGrammarMaxLookahead</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getGrammarTree()">getGrammarTree</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getGrammarTypeString()">getGrammarTypeString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getImplicitlyGeneratedLexerFileName()">getImplicitlyGeneratedLexerFileName</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List&lt;<A HREF="../../../org/antlr/tool/Grammar.html" title="class in org.antlr.tool">Grammar</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getIndirectDelegates()">getIndirectDelegates</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get delegates below direct delegates</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getLabels(java.util.Set, int)">getLabels</A></B>(java.util.Set&lt;<A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&gt;&nbsp;rewriteElements,
          int&nbsp;labelType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given a set of all rewrite elements on right of ->, filter for
  label types such as Grammar.TOKEN_LABEL, Grammar.TOKEN_LIST_LABEL, ...</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;<A HREF="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getLeftRecursiveRules()">getLeftRecursiveRules</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a list of left-recursive rules; no analysis can be done
  successfully on these.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getLexerGrammar()">getLexerGrammar</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If the grammar is a combined grammar, return the text of the implicit
  lexer grammar.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getLineColumnToLookaheadDFAMap()">getLineColumnToLookaheadDFAMap</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getLocallyDefinedOption(java.lang.String)">getLocallyDefinedOption</A></B>(java.lang.String&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getLocallyDefinedRule(java.lang.String)">getLocallyDefinedRule</A></B>(java.lang.String&nbsp;ruleName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getLookaheadDFA(int)">getLookaheadDFA</A></B>(int&nbsp;decision)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getLookaheadDFAColumnsForLineInFile(int)">getLookaheadDFAColumnsForLineInFile</A></B>(int&nbsp;line)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;returns a list of column numbers for all decisions
  on a particular line so ANTLRWorks choose the decision
  depending on the location of the cursor (otherwise,
  ANTLRWorks has to give the *exact* location which
  is not easy from the user point of view).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getLookaheadDFAFromPositionInFile(int, int)">getLookaheadDFAFromPositionInFile</A></B>(int&nbsp;line,
                                  int&nbsp;col)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Useful for ANTLRWorks to map position in file to the DFA for display</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getMaxCharValue()">getMaxCharValue</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;What is the max char value possible for this grammar's target?  Use
  unicode max if no target defined.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getMaxTokenType()">getMaxTokenType</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;How many token types have been allocated so far?</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getNewTokenType()">getNewTokenType</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a new unique integer in the token type space</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getNFAStateForAltOfDecision(org.antlr.analysis.NFAState, int)">getNFAStateForAltOfDecision</A></B>(<A HREF="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</A>&nbsp;decisionState,
                            int&nbsp;alt)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the ith alternative (1..n) from a decision; return null when
  an invalid alt is requested.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getNumberOfAltsForDecisionNFA(org.antlr.analysis.NFAState)">getNumberOfAltsForDecisionNFA</A></B>(<A HREF="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</A>&nbsp;decisionState)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decisions are linked together with transition(1).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getNumberOfCyclicDecisions()">getNumberOfCyclicDecisions</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getNumberOfDecisions()">getNumberOfDecisions</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getOption(java.lang.String)">getOption</A></B>(java.lang.String&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getRecognizerName()">getRecognizerName</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the name of the generated recognizer; may or may not be same
  as grammar name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getRule(java.lang.String)">getRule</A></B>(java.lang.String&nbsp;ruleName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getRule(java.lang.String, java.lang.String)">getRule</A></B>(java.lang.String&nbsp;scopeName,
        java.lang.String&nbsp;ruleName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getRuleIndex(java.lang.String)">getRuleIndex</A></B>(java.lang.String&nbsp;ruleName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getRuleIndex(java.lang.String, java.lang.String)">getRuleIndex</A></B>(java.lang.String&nbsp;scopeName,
             java.lang.String&nbsp;ruleName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getRuleModifier(java.lang.String)">getRuleModifier</A></B>(java.lang.String&nbsp;ruleName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getRuleName(int)">getRuleName</A></B>(int&nbsp;ruleIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Collection&lt;<A HREF="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getRules()">getRules</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getRuleStartState(java.lang.String)">getRuleStartState</A></B>(java.lang.String&nbsp;ruleName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getRuleStartState(java.lang.String, java.lang.String)">getRuleStartState</A></B>(java.lang.String&nbsp;scopeName,
                  java.lang.String&nbsp;ruleName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getRuleStopState(java.lang.String)">getRuleStopState</A></B>(java.lang.String&nbsp;ruleName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/misc/IntSet.html" title="interface in org.antlr.misc">IntSet</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getSetFromRule(org.antlr.grammar.v2.TreeToNFAConverter, java.lang.String)">getSetFromRule</A></B>(org.antlr.grammar.v2.TreeToNFAConverter&nbsp;nfabuilder,
               java.lang.String&nbsp;ruleName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the set equivalent (if any) of the indicated rule from this
  grammar.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getStringLiterals()">getStringLiterals</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the list of ANTLR String literals</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getSyntacticPredicate(java.lang.String)">getSyntacticPredicate</A></B>(java.lang.String&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.LinkedHashMap</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getSyntacticPredicates()">getSyntacticPredicates</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getTokenDisplayName(int)">getTokenDisplayName</A></B>(int&nbsp;ttype)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given a token type, get a meaningful name for it such as the ID
  or string literal.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getTokenDisplayNames()">getTokenDisplayNames</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a list of all token IDs and literals that have an associated
  token type.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getTokenIDs()">getTokenIDs</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the list of tokens that are IDs like BLOCK and LPAREN</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getTokenType(java.lang.String)">getTokenType</A></B>(java.lang.String&nbsp;tokenName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/misc/IntSet.html" title="interface in org.antlr.misc">IntSet</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getTokenTypes()">getTokenTypes</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a set of all possible token or char types for this grammar</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Collection</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getTokenTypesWithoutID()">getTokenTypesWithoutID</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return an ordered integer list of token types that have no
  corresponding token ID like INT or KEYWORD_BEGIN; for stuff
  like 'begin'.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/Tool.html" title="class in org.antlr">Tool</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getTool()">getTool</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.StringBuffer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getUnescapedStringFromGrammarStringLiteral(java.lang.String)">getUnescapedStringFromGrammarStringLiteral</A></B>(java.lang.String&nbsp;literal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ANTLR does not convert escape sequences during the parse phase because
  it could not know how to print String/char literals back out when
  printing grammars etc...</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#getUserMaxLookahead(int)">getUserMaxLookahead</A></B>(int&nbsp;decision)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#grammarTreeToString(org.antlr.tool.GrammarAST)">grammarTreeToString</A></B>(<A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#grammarTreeToString(org.antlr.tool.GrammarAST, boolean)">grammarTreeToString</A></B>(<A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;t,
                    boolean&nbsp;showActions)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#importGrammar(org.antlr.tool.GrammarAST, java.lang.String)">importGrammar</A></B>(<A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;grammarNameAST,
              java.lang.String&nbsp;label)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Import the rules/tokens of a delegate grammar.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#importTokenVocabulary(org.antlr.tool.Grammar)">importTokenVocabulary</A></B>(<A HREF="../../../org/antlr/tool/Grammar.html" title="class in org.antlr.tool">Grammar</A>&nbsp;importFromGr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pull your token definitions from an existing grammar in memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#importTokenVocabulary(org.antlr.tool.GrammarAST, java.lang.String)">importTokenVocabulary</A></B>(<A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;tokenVocabOptionAST,
                      java.lang.String&nbsp;vocabName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Load a vocab file <vocabName>.tokens and return max token type found.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#isAtomTokenType(int)">isAtomTokenType</A></B>(int&nbsp;ttype)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#isBuiltFromString()">isBuiltFromString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#isEmptyRule(org.antlr.tool.GrammarAST)">isEmptyRule</A></B>(<A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;block)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rules like "a : ;" and "a : {...} ;" should not generate
  try/catch blocks for RecognitionException.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#isValidSet(org.antlr.grammar.v2.TreeToNFAConverter, org.antlr.tool.GrammarAST)">isValidSet</A></B>(org.antlr.grammar.v2.TreeToNFAConverter&nbsp;nfabuilder,
           <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given set tree like ( SET A B ), check that A and B
  are both valid sets themselves, else we must tree like a BLOCK</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#legalOption(java.lang.String)">legalOption</A></B>(java.lang.String&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/analysis/LookaheadSet.html" title="class in org.antlr.analysis">LookaheadSet</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#LOOK(org.antlr.analysis.NFAState)">LOOK</A></B>(<A HREF="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</A>&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.List&lt;<A HREF="../../../org/antlr/misc/IntervalSet.html" title="class in org.antlr.misc">IntervalSet</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#makeEdgeSetsDisjoint(java.util.List)">makeEdgeSetsDisjoint</A></B>(java.util.List&lt;<A HREF="../../../org/antlr/misc/IntervalSet.html" title="class in org.antlr.misc">IntervalSet</A>&gt;&nbsp;edges)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#NFAToDFAConversionExternallyAborted()">NFAToDFAConversionExternallyAborted</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#optionIsValid(java.lang.String, java.lang.Object)">optionIsValid</A></B>(java.lang.String&nbsp;key,
              java.lang.Object&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#parseAndBuildAST()">parseAndBuildAST</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#parseAndBuildAST(java.io.Reader)">parseAndBuildAST</A></B>(java.io.Reader&nbsp;r)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#printGrammar(java.io.PrintStream)">printGrammar</A></B>(java.io.PrintStream&nbsp;output)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#referenceRuleLabelPredefinedAttribute(java.lang.String)">referenceRuleLabelPredefinedAttribute</A></B>(java.lang.String&nbsp;ruleName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To yield smaller, more readable code, track which rules have their
  predefined attributes accessed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#removeUselessLabels(java.util.Map)">removeUselessLabels</A></B>(java.util.Map&nbsp;ruleToElementLabelPairMap)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A label on a rule is useless if the rule has no return value, no
  tree or template output, and it is not referenced in an action.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#rewriteMode()">rewriteMode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#setCodeGenerator(org.antlr.codegen.CodeGenerator)">setCodeGenerator</A></B>(<A HREF="../../../org/antlr/codegen/CodeGenerator.html" title="class in org.antlr.codegen">CodeGenerator</A>&nbsp;generator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#setDecisionBlockAST(int, org.antlr.tool.GrammarAST)">setDecisionBlockAST</A></B>(int&nbsp;decision,
                    <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;blockAST)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#setDecisionNFA(int, org.antlr.analysis.NFAState)">setDecisionNFA</A></B>(int&nbsp;decision,
               <A HREF="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</A>&nbsp;state)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#setFileName(java.lang.String)">setFileName</A></B>(java.lang.String&nbsp;fileName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#setGrammarContent(java.lang.String)">setGrammarContent</A></B>(java.lang.String&nbsp;grammarString)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#setLookaheadDFA(int, org.antlr.analysis.DFA)">setLookaheadDFA</A></B>(int&nbsp;decision,
                <A HREF="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</A>&nbsp;lookaheadDFA)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the lookahead DFA for a particular decision.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#setName(java.lang.String)">setName</A></B>(java.lang.String&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#setOption(java.lang.String, java.lang.Object, antlr.Token)">setOption</A></B>(java.lang.String&nbsp;key,
          java.lang.Object&nbsp;value,
          antlr.Token&nbsp;optionsStartToken)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Save the option key/value pair and process it; return the key
  or null if invalid option.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#setOptions(java.util.Map, antlr.Token)">setOptions</A></B>(java.util.Map&nbsp;options,
           antlr.Token&nbsp;optionsStartToken)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#setRuleAST(java.lang.String, org.antlr.tool.GrammarAST)">setRuleAST</A></B>(java.lang.String&nbsp;ruleName,
           <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#setSynPredGateIfNotAlready(org.antlr.stringtemplate.StringTemplate)">setSynPredGateIfNotAlready</A></B>(org.antlr.stringtemplate.StringTemplate&nbsp;gateST)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#setTool(org.antlr.Tool)">setTool</A></B>(<A HREF="../../../org/antlr/Tool.html" title="class in org.antlr">Tool</A>&nbsp;tool)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#synPredUsedInDFA(org.antlr.analysis.DFA, org.antlr.analysis.SemanticContext)">synPredUsedInDFA</A></B>(<A HREF="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</A>&nbsp;dfa,
                 <A HREF="../../../org/antlr/analysis/SemanticContext.html" title="class in org.antlr.analysis">SemanticContext</A>&nbsp;semCtx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/tool/Grammar.html#validImport(org.antlr.tool.Grammar)">validImport</A></B>(<A HREF="../../../org/antlr/tool/Grammar.html" title="class in org.antlr.tool">Grammar</A>&nbsp;delegate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Many imports are illegal such as lexer into a tree grammar</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="SYNPRED_RULE_PREFIX"><!-- --></A><H3>
SYNPRED_RULE_PREFIX</H3>
<PRE>
public static final java.lang.String <B>SYNPRED_RULE_PREFIX</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.antlr.tool.Grammar.SYNPRED_RULE_PREFIX">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GRAMMAR_FILE_EXTENSION"><!-- --></A><H3>
GRAMMAR_FILE_EXTENSION</H3>
<PRE>
public static final java.lang.String <B>GRAMMAR_FILE_EXTENSION</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.antlr.tool.Grammar.GRAMMAR_FILE_EXTENSION">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="LEXER_GRAMMAR_FILE_EXTENSION"><!-- --></A><H3>
LEXER_GRAMMAR_FILE_EXTENSION</H3>
<PRE>
public static final java.lang.String <B>LEXER_GRAMMAR_FILE_EXTENSION</B></PRE>
<DL>
<DD>used for generating lexer temp files
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.antlr.tool.Grammar.LEXER_GRAMMAR_FILE_EXTENSION">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="INITIAL_DECISION_LIST_SIZE"><!-- --></A><H3>
INITIAL_DECISION_LIST_SIZE</H3>
<PRE>
public static final int <B>INITIAL_DECISION_LIST_SIZE</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.antlr.tool.Grammar.INITIAL_DECISION_LIST_SIZE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="INVALID_RULE_INDEX"><!-- --></A><H3>
INVALID_RULE_INDEX</H3>
<PRE>
public static final int <B>INVALID_RULE_INDEX</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.antlr.tool.Grammar.INVALID_RULE_INDEX">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="RULE_LABEL"><!-- --></A><H3>
RULE_LABEL</H3>
<PRE>
public static final int <B>RULE_LABEL</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.antlr.tool.Grammar.RULE_LABEL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="TOKEN_LABEL"><!-- --></A><H3>
TOKEN_LABEL</H3>
<PRE>
public static final int <B>TOKEN_LABEL</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.antlr.tool.Grammar.TOKEN_LABEL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="RULE_LIST_LABEL"><!-- --></A><H3>
RULE_LIST_LABEL</H3>
<PRE>
public static final int <B>RULE_LIST_LABEL</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.antlr.tool.Grammar.RULE_LIST_LABEL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="TOKEN_LIST_LABEL"><!-- --></A><H3>
TOKEN_LIST_LABEL</H3>
<PRE>
public static final int <B>TOKEN_LIST_LABEL</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.antlr.tool.Grammar.TOKEN_LIST_LABEL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="CHAR_LABEL"><!-- --></A><H3>
CHAR_LABEL</H3>
<PRE>
public static final int <B>CHAR_LABEL</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.antlr.tool.Grammar.CHAR_LABEL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="WILDCARD_TREE_LABEL"><!-- --></A><H3>
WILDCARD_TREE_LABEL</H3>
<PRE>
public static final int <B>WILDCARD_TREE_LABEL</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.antlr.tool.Grammar.WILDCARD_TREE_LABEL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="WILDCARD_TREE_LIST_LABEL"><!-- --></A><H3>
WILDCARD_TREE_LIST_LABEL</H3>
<PRE>
public static final int <B>WILDCARD_TREE_LIST_LABEL</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.antlr.tool.Grammar.WILDCARD_TREE_LIST_LABEL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="LabelTypeToString"><!-- --></A><H3>
LabelTypeToString</H3>
<PRE>
public static java.lang.String[] <B>LabelTypeToString</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="ARTIFICIAL_TOKENS_RULENAME"><!-- --></A><H3>
ARTIFICIAL_TOKENS_RULENAME</H3>
<PRE>
public static final java.lang.String <B>ARTIFICIAL_TOKENS_RULENAME</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.antlr.tool.Grammar.ARTIFICIAL_TOKENS_RULENAME">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FRAGMENT_RULE_MODIFIER"><!-- --></A><H3>
FRAGMENT_RULE_MODIFIER</H3>
<PRE>
public static final java.lang.String <B>FRAGMENT_RULE_MODIFIER</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.antlr.tool.Grammar.FRAGMENT_RULE_MODIFIER">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SYNPREDGATE_ACTION_NAME"><!-- --></A><H3>
SYNPREDGATE_ACTION_NAME</H3>
<PRE>
public static final java.lang.String <B>SYNPREDGATE_ACTION_NAME</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.antlr.tool.Grammar.SYNPREDGATE_ACTION_NAME">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="ANTLRLiteralEscapedCharValue"><!-- --></A><H3>
ANTLRLiteralEscapedCharValue</H3>
<PRE>
public static int[] <B>ANTLRLiteralEscapedCharValue</B></PRE>
<DL>
<DD>When converting ANTLR char and string literals, here is the
  value set of escape chars.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="ANTLRLiteralCharValueEscape"><!-- --></A><H3>
ANTLRLiteralCharValueEscape</H3>
<PRE>
public static java.lang.String[] <B>ANTLRLiteralCharValueEscape</B></PRE>
<DL>
<DD>Given a char, we need to be able to show as an ANTLR literal.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="LEXER"><!-- --></A><H3>
LEXER</H3>
<PRE>
public static final int <B>LEXER</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.antlr.tool.Grammar.LEXER">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="PARSER"><!-- --></A><H3>
PARSER</H3>
<PRE>
public static final int <B>PARSER</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.antlr.tool.Grammar.PARSER">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="TREE_PARSER"><!-- --></A><H3>
TREE_PARSER</H3>
<PRE>
public static final int <B>TREE_PARSER</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.antlr.tool.Grammar.TREE_PARSER">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="COMBINED"><!-- --></A><H3>
COMBINED</H3>
<PRE>
public static final int <B>COMBINED</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.antlr.tool.Grammar.COMBINED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="grammarTypeToString"><!-- --></A><H3>
grammarTypeToString</H3>
<PRE>
public static final java.lang.String[] <B>grammarTypeToString</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="grammarTypeToFileNameSuffix"><!-- --></A><H3>
grammarTypeToFileNameSuffix</H3>
<PRE>
public static final java.lang.String[] <B>grammarTypeToFileNameSuffix</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="validDelegations"><!-- --></A><H3>
validDelegations</H3>
<PRE>
public static <A HREF="../../../org/antlr/misc/MultiMap.html" title="class in org.antlr.misc">MultiMap</A>&lt;java.lang.Integer,java.lang.Integer&gt; <B>validDelegations</B></PRE>
<DL>
<DD>Set of valid imports.  E.g., can only import a tree parser into
  another tree parser.  Maps delegate to set of delegator grammar types.
  validDelegations.get(LEXER) gives list of the kinds of delegators
  that can import lexers.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="tokenBuffer"><!-- --></A><H3>
tokenBuffer</H3>
<PRE>
protected antlr.TokenStreamRewriteEngine <B>tokenBuffer</B></PRE>
<DL>
<DD>This is the buffer of *all* tokens found in the grammar file
  including whitespace tokens etc...  I use this to extract
  lexer rules from combined grammars.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="IGNORE_STRING_IN_GRAMMAR_FILE_NAME"><!-- --></A><H3>
IGNORE_STRING_IN_GRAMMAR_FILE_NAME</H3>
<PRE>
public static final java.lang.String <B>IGNORE_STRING_IN_GRAMMAR_FILE_NAME</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.antlr.tool.Grammar.IGNORE_STRING_IN_GRAMMAR_FILE_NAME">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="AUTO_GENERATED_TOKEN_NAME_PREFIX"><!-- --></A><H3>
AUTO_GENERATED_TOKEN_NAME_PREFIX</H3>
<PRE>
public static final java.lang.String <B>AUTO_GENERATED_TOKEN_NAME_PREFIX</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.antlr.tool.Grammar.AUTO_GENERATED_TOKEN_NAME_PREFIX">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="name"><!-- --></A><H3>
name</H3>
<PRE>
public java.lang.String <B>name</B></PRE>
<DL>
<DD>What name did the user provide for this grammar?
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="type"><!-- --></A><H3>
type</H3>
<PRE>
public int <B>type</B></PRE>
<DL>
<DD>What type of grammar is this: lexer, parser, tree walker
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="options"><!-- --></A><H3>
options</H3>
<PRE>
protected java.util.Map <B>options</B></PRE>
<DL>
<DD>A list of options specified at the grammar level such as language=Java.
  The value can be an AST for complicated values such as character sets.
  There may be code generator specific options in here.  I do no
  interpretation of the key/value pairs...they are simply available for
  who wants them.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="legalLexerOptions"><!-- --></A><H3>
legalLexerOptions</H3>
<PRE>
public static final java.util.Set <B>legalLexerOptions</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="legalParserOptions"><!-- --></A><H3>
legalParserOptions</H3>
<PRE>
public static final java.util.Set <B>legalParserOptions</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="legalTreeParserOptions"><!-- --></A><H3>
legalTreeParserOptions</H3>
<PRE>
public static final java.util.Set <B>legalTreeParserOptions</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="doNotCopyOptionsToLexer"><!-- --></A><H3>
doNotCopyOptionsToLexer</H3>
<PRE>
public static final java.util.Set <B>doNotCopyOptionsToLexer</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="defaultOptions"><!-- --></A><H3>
defaultOptions</H3>
<PRE>
public static final java.util.Map <B>defaultOptions</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="legalBlockOptions"><!-- --></A><H3>
legalBlockOptions</H3>
<PRE>
public static final java.util.Set <B>legalBlockOptions</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="defaultBlockOptions"><!-- --></A><H3>
defaultBlockOptions</H3>
<PRE>
public static final java.util.Map <B>defaultBlockOptions</B></PRE>
<DL>
<DD>What are the default options for a subrule?
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="defaultLexerBlockOptions"><!-- --></A><H3>
defaultLexerBlockOptions</H3>
<PRE>
public static final java.util.Map <B>defaultLexerBlockOptions</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="legalTokenOptions"><!-- --></A><H3>
legalTokenOptions</H3>
<PRE>
public static final java.util.Set <B>legalTokenOptions</B></PRE>
<DL>
<DD>Legal options for terminal refs like ID<node=MyVarNode>
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="defaultTokenOption"><!-- --></A><H3>
defaultTokenOption</H3>
<PRE>
public static final java.lang.String <B>defaultTokenOption</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.antlr.tool.Grammar.defaultTokenOption">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="global_k"><!-- --></A><H3>
global_k</H3>
<PRE>
protected int <B>global_k</B></PRE>
<DL>
<DD>Is there a global fixed lookahead set for this grammar?
  If 0, nothing specified.  -1 implies we have not looked at
  the options table yet to set k.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="actions"><!-- --></A><H3>
actions</H3>
<PRE>
protected java.util.Map <B>actions</B></PRE>
<DL>
<DD>Map a scope to a map of name:action pairs.
  Map<String, Map<String,GrammarAST>>
  The code generator will use this to fill holes in the output files.
  I track the AST node for the action in case I need the line number
  for errors.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="nfa"><!-- --></A><H3>
nfa</H3>
<PRE>
public <A HREF="../../../org/antlr/analysis/NFA.html" title="class in org.antlr.analysis">NFA</A> <B>nfa</B></PRE>
<DL>
<DD>The NFA that represents the grammar with edges labelled with tokens
  or epsilon.  It is more suitable to analysis than an AST representation.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="factory"><!-- --></A><H3>
factory</H3>
<PRE>
protected <A HREF="../../../org/antlr/tool/NFAFactory.html" title="class in org.antlr.tool">NFAFactory</A> <B>factory</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="composite"><!-- --></A><H3>
composite</H3>
<PRE>
public <A HREF="../../../org/antlr/tool/CompositeGrammar.html" title="class in org.antlr.tool">CompositeGrammar</A> <B>composite</B></PRE>
<DL>
<DD>If this grammar is part of a larger composite grammar via delegate
  statement, then this points at the composite.  The composite holds
  a global list of rules, token types, decision numbers, etc...
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="compositeTreeNode"><!-- --></A><H3>
compositeTreeNode</H3>
<PRE>
public <A HREF="../../../org/antlr/tool/CompositeGrammarTree.html" title="class in org.antlr.tool">CompositeGrammarTree</A> <B>compositeTreeNode</B></PRE>
<DL>
<DD>A pointer back into grammar tree.  Needed so we can add delegates.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="label"><!-- --></A><H3>
label</H3>
<PRE>
public java.lang.String <B>label</B></PRE>
<DL>
<DD>If this is a delegate of another grammar, this is the label used
  as an instance var by that grammar to point at this grammar. null
  if no label was specified in the delegate statement.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="charVocabulary"><!-- --></A><H3>
charVocabulary</H3>
<PRE>
protected <A HREF="../../../org/antlr/misc/IntSet.html" title="interface in org.antlr.misc">IntSet</A> <B>charVocabulary</B></PRE>
<DL>
<DD>TODO: hook this to the charVocabulary option
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="tool"><!-- --></A><H3>
tool</H3>
<PRE>
public <A HREF="../../../org/antlr/Tool.html" title="class in org.antlr">Tool</A> <B>tool</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="ruleRefs"><!-- --></A><H3>
ruleRefs</H3>
<PRE>
protected java.util.Set&lt;<A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&gt; <B>ruleRefs</B></PRE>
<DL>
<DD>The unique set of all rule references in any rule; set of tree node
  objects so two refs to same rule can exist but at different line/position.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="scopedRuleRefs"><!-- --></A><H3>
scopedRuleRefs</H3>
<PRE>
protected java.util.Set&lt;<A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&gt; <B>scopedRuleRefs</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="tokenIDRefs"><!-- --></A><H3>
tokenIDRefs</H3>
<PRE>
protected java.util.Set&lt;antlr.Token&gt; <B>tokenIDRefs</B></PRE>
<DL>
<DD>The unique set of all token ID references in any rule
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="decisionCount"><!-- --></A><H3>
decisionCount</H3>
<PRE>
protected int <B>decisionCount</B></PRE>
<DL>
<DD>Be able to assign a number to every decision in grammar;
  decisions in 1..n
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="leftRecursiveRules"><!-- --></A><H3>
leftRecursiveRules</H3>
<PRE>
protected java.util.Set&lt;<A HREF="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</A>&gt; <B>leftRecursiveRules</B></PRE>
<DL>
<DD>A list of all rules that are in any left-recursive cycle.  There
  could be multiple cycles, but this is a flat list of all problematic
  rules.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="externalAnalysisAbort"><!-- --></A><H3>
externalAnalysisAbort</H3>
<PRE>
protected boolean <B>externalAnalysisAbort</B></PRE>
<DL>
<DD>An external tool requests that DFA analysis abort prematurely.  Stops
  at DFA granularity, which are limited to a DFA size and time computation
  as failsafe.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="nameToSynpredASTMap"><!-- --></A><H3>
nameToSynpredASTMap</H3>
<PRE>
protected java.util.LinkedHashMap <B>nameToSynpredASTMap</B></PRE>
<DL>
<DD>When we read in a grammar, we track the list of syntactic predicates
  and build faux rules for them later.  See my blog entry Dec 2, 2005:
  http://www.antlr.org/blog/antlr3/lookahead.tml
  This maps the name (we make up) for a pred to the AST grammar fragment.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="atLeastOneRuleMemoizes"><!-- --></A><H3>
atLeastOneRuleMemoizes</H3>
<PRE>
public boolean <B>atLeastOneRuleMemoizes</B></PRE>
<DL>
<DD>At least one rule has memoize=true
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="atLeastOneBacktrackOption"><!-- --></A><H3>
atLeastOneBacktrackOption</H3>
<PRE>
public boolean <B>atLeastOneBacktrackOption</B></PRE>
<DL>
<DD>At least one backtrack=true in rule or decision or grammar.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="implicitLexer"><!-- --></A><H3>
implicitLexer</H3>
<PRE>
public boolean <B>implicitLexer</B></PRE>
<DL>
<DD>Was this created from a COMBINED grammar?
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="nameToRuleMap"><!-- --></A><H3>
nameToRuleMap</H3>
<PRE>
protected java.util.LinkedHashMap&lt;java.lang.String,<A HREF="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</A>&gt; <B>nameToRuleMap</B></PRE>
<DL>
<DD>Map a rule to it's Rule object
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="overriddenRules"><!-- --></A><H3>
overriddenRules</H3>
<PRE>
public java.util.Set&lt;java.lang.String&gt; <B>overriddenRules</B></PRE>
<DL>
<DD>If this rule is a delegate, some rules might be overridden; don't
  want to gen code for them.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="delegatedRuleReferences"><!-- --></A><H3>
delegatedRuleReferences</H3>
<PRE>
protected java.util.Set&lt;<A HREF="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</A>&gt; <B>delegatedRuleReferences</B></PRE>
<DL>
<DD>The list of all rules referenced in this grammar, not defined here,
  and defined in a delegate grammar.  Not all of these will be generated
  in the recognizer for this file; only those that are affected by rule
  definitions in this grammar.  I am not sure the Java target will need
  this but I'm leaving in case other targets need it.
<P>
<DL>
<DT><B>See Also:</B><DD><CODE>NameSpaceChecker.lookForReferencesToUndefinedSymbols()</CODE></DL>
</DL>
<HR>

<A NAME="lexerRuleNamesInCombined"><!-- --></A><H3>
lexerRuleNamesInCombined</H3>
<PRE>
public java.util.List&lt;java.lang.String&gt; <B>lexerRuleNamesInCombined</B></PRE>
<DL>
<DD>The ANTLRParser tracks lexer rules when reading combined grammars
  so we can build the Tokens rule.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="scopes"><!-- --></A><H3>
scopes</H3>
<PRE>
protected java.util.Map <B>scopes</B></PRE>
<DL>
<DD>Track the scopes defined outside of rules and the scopes associated
  with all rules (even if empty).
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="grammarTree"><!-- --></A><H3>
grammarTree</H3>
<PRE>
protected <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A> <B>grammarTree</B></PRE>
<DL>
<DD>An AST that records entire input grammar with all rules.  A simple
  grammar with one rule, "grammar t; a : A | B ;", looks like:
 ( grammar t ( rule a ( BLOCK ( ALT A ) ( ALT B ) ) <end-of-rule> ) )
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="indexToDecision"><!-- --></A><H3>
indexToDecision</H3>
<PRE>
protected java.util.Vector&lt;<A HREF="../../../org/antlr/tool/Grammar.Decision.html" title="class in org.antlr.tool">Grammar.Decision</A>&gt; <B>indexToDecision</B></PRE>
<DL>
<DD>Each subrule/rule is a decision point and we must track them so we
  can go back later and build DFA predictors for them.  This includes
  all the rules, subrules, optional blocks, ()+, ()* etc...
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="generator"><!-- --></A><H3>
generator</H3>
<PRE>
protected <A HREF="../../../org/antlr/codegen/CodeGenerator.html" title="class in org.antlr.codegen">CodeGenerator</A> <B>generator</B></PRE>
<DL>
<DD>If non-null, this is the code generator we will use to generate
  recognizers in the target language.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="nameSpaceChecker"><!-- --></A><H3>
nameSpaceChecker</H3>
<PRE>
public <A HREF="../../../org/antlr/tool/NameSpaceChecker.html" title="class in org.antlr.tool">NameSpaceChecker</A> <B>nameSpaceChecker</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="ll1Analyzer"><!-- --></A><H3>
ll1Analyzer</H3>
<PRE>
public <A HREF="../../../org/antlr/analysis/LL1Analyzer.html" title="class in org.antlr.analysis">LL1Analyzer</A> <B>ll1Analyzer</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="lexerGrammarST"><!-- --></A><H3>
lexerGrammarST</H3>
<PRE>
protected org.antlr.stringtemplate.StringTemplate <B>lexerGrammarST</B></PRE>
<DL>
<DD>For merged lexer/parsers, we must construct a separate lexer spec.
  This is the template for lexer; put the literals first then the
  regular rules.  We don't need to specify a token vocab import as
  I make the new grammar import from the old all in memory; don't want
  to force it to read from the disk.  Lexer grammar will have same
  name as original grammar but will be in different filename.  Foo.g
  with combined grammar will have FooParser.java generated and
  Foo__.g with again Foo inside.  It will however generate FooLexer.java
  as it's a lexer grammar.  A bit odd, but autogenerated.  Can tweak
  later if we want.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="fileName"><!-- --></A><H3>
fileName</H3>
<PRE>
protected java.lang.String <B>fileName</B></PRE>
<DL>
<DD>What file name holds this grammar?
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="DFACreationWallClockTimeInMS"><!-- --></A><H3>
DFACreationWallClockTimeInMS</H3>
<PRE>
public long <B>DFACreationWallClockTimeInMS</B></PRE>
<DL>
<DD>How long in ms did it take to build DFAs for this grammar?
  If this grammar is a combined grammar, it only records time for
  the parser grammar component.  This only records the time to
  do the LL(*) work; NFA->DFA conversion.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="numberOfSemanticPredicates"><!-- --></A><H3>
numberOfSemanticPredicates</H3>
<PRE>
public int <B>numberOfSemanticPredicates</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="numberOfManualLookaheadOptions"><!-- --></A><H3>
numberOfManualLookaheadOptions</H3>
<PRE>
public int <B>numberOfManualLookaheadOptions</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="setOfNondeterministicDecisionNumbers"><!-- --></A><H3>
setOfNondeterministicDecisionNumbers</H3>
<PRE>
public java.util.Set&lt;java.lang.Integer&gt; <B>setOfNondeterministicDecisionNumbers</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="setOfNondeterministicDecisionNumbersResolvedWithPredicates"><!-- --></A><H3>
setOfNondeterministicDecisionNumbersResolvedWithPredicates</H3>
<PRE>
public java.util.Set&lt;java.lang.Integer&gt; <B>setOfNondeterministicDecisionNumbersResolvedWithPredicates</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="setOfDFAWhoseAnalysisTimedOut"><!-- --></A><H3>
setOfDFAWhoseAnalysisTimedOut</H3>
<PRE>
public java.util.Set <B>setOfDFAWhoseAnalysisTimedOut</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="blocksWithSynPreds"><!-- --></A><H3>
blocksWithSynPreds</H3>
<PRE>
public java.util.Set&lt;<A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&gt; <B>blocksWithSynPreds</B></PRE>
<DL>
<DD>Track decisions with syn preds specified for reporting.
  This is the a set of BLOCK type AST nodes.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="decisionsWhoseDFAsUsesSynPreds"><!-- --></A><H3>
decisionsWhoseDFAsUsesSynPreds</H3>
<PRE>
public java.util.Set&lt;<A HREF="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</A>&gt; <B>decisionsWhoseDFAsUsesSynPreds</B></PRE>
<DL>
<DD>Track decisions that actually use the syn preds in the DFA.
  Computed during NFA to DFA conversion.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="synPredNamesUsedInDFA"><!-- --></A><H3>
synPredNamesUsedInDFA</H3>
<PRE>
public java.util.Set&lt;java.lang.String&gt; <B>synPredNamesUsedInDFA</B></PRE>
<DL>
<DD>Track names of preds so we can avoid generating preds that aren't used
  Computed during NFA to DFA conversion.  Just walk accept states
  and look for synpreds because that is the only state target whose
  incident edges can have synpreds.  Same is try for
  decisionsWhoseDFAsUsesSynPreds.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="blocksWithSemPreds"><!-- --></A><H3>
blocksWithSemPreds</H3>
<PRE>
public java.util.Set&lt;<A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&gt; <B>blocksWithSemPreds</B></PRE>
<DL>
<DD>Track decisions with syn preds specified for reporting.
  This is the a set of BLOCK type AST nodes.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="decisionsWhoseDFAsUsesSemPreds"><!-- --></A><H3>
decisionsWhoseDFAsUsesSemPreds</H3>
<PRE>
public java.util.Set&lt;<A HREF="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</A>&gt; <B>decisionsWhoseDFAsUsesSemPreds</B></PRE>
<DL>
<DD>Track decisions that actually use the syn preds in the DFA.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="allDecisionDFACreated"><!-- --></A><H3>
allDecisionDFACreated</H3>
<PRE>
protected boolean <B>allDecisionDFACreated</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="builtFromString"><!-- --></A><H3>
builtFromString</H3>
<PRE>
protected boolean <B>builtFromString</B></PRE>
<DL>
<DD>We need a way to detect when a lexer grammar is autogenerated from
  another grammar or we are just sending in a string representing a
  grammar.  We don't want to generate a .tokens file, for example,
  in such cases.
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Grammar(org.antlr.Tool, java.lang.String, org.antlr.tool.CompositeGrammar)"><!-- --></A><H3>
Grammar</H3>
<PRE>
public <B>Grammar</B>(<A HREF="../../../org/antlr/Tool.html" title="class in org.antlr">Tool</A>&nbsp;tool,
               java.lang.String&nbsp;fileName,
               <A HREF="../../../org/antlr/tool/CompositeGrammar.html" title="class in org.antlr.tool">CompositeGrammar</A>&nbsp;composite)</PRE>
<DL>
<DD>Create a grammar from file name.
<P>
</DL>
<HR>

<A NAME="Grammar()"><!-- --></A><H3>
Grammar</H3>
<PRE>
public <B>Grammar</B>()</PRE>
<DL>
<DD>Useful for when you are sure that you are not part of a composite
  already.  Used in Interp/RandomPhrase and testing.
<P>
</DL>
<HR>

<A NAME="Grammar(java.lang.String)"><!-- --></A><H3>
Grammar</H3>
<PRE>
public <B>Grammar</B>(java.lang.String&nbsp;grammarString)
        throws antlr.RecognitionException,
               antlr.TokenStreamException</PRE>
<DL>
<DD>Used for testing; only useful on noncomposite grammars.
<P>
<DL>

<DT><B>Throws:</B>
<DD><CODE>antlr.RecognitionException</CODE>
<DD><CODE>antlr.TokenStreamException</CODE></DL>
</DL>
<HR>

<A NAME="Grammar(org.antlr.Tool, java.lang.String)"><!-- --></A><H3>
Grammar</H3>
<PRE>
public <B>Grammar</B>(<A HREF="../../../org/antlr/Tool.html" title="class in org.antlr">Tool</A>&nbsp;tool,
               java.lang.String&nbsp;grammarString)
        throws antlr.RecognitionException</PRE>
<DL>
<DD>Used for testing and Interp/RandomPhrase.  Only useful on
  noncomposite grammars.
<P>
<DL>

<DT><B>Throws:</B>
<DD><CODE>antlr.RecognitionException</CODE></DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="setFileName(java.lang.String)"><!-- --></A><H3>
setFileName</H3>
<PRE>
public void <B>setFileName</B>(java.lang.String&nbsp;fileName)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getFileName()"><!-- --></A><H3>
getFileName</H3>
<PRE>
public java.lang.String <B>getFileName</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setName(java.lang.String)"><!-- --></A><H3>
setName</H3>
<PRE>
public void <B>setName</B>(java.lang.String&nbsp;name)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setGrammarContent(java.lang.String)"><!-- --></A><H3>
setGrammarContent</H3>
<PRE>
public void <B>setGrammarContent</B>(java.lang.String&nbsp;grammarString)
                       throws antlr.RecognitionException</PRE>
<DL>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>antlr.RecognitionException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="parseAndBuildAST()"><!-- --></A><H3>
parseAndBuildAST</H3>
<PRE>
public void <B>parseAndBuildAST</B>()
                      throws java.io.IOException</PRE>
<DL>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="parseAndBuildAST(java.io.Reader)"><!-- --></A><H3>
parseAndBuildAST</H3>
<PRE>
public void <B>parseAndBuildAST</B>(java.io.Reader&nbsp;r)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="dealWithTreeFilterMode()"><!-- --></A><H3>
dealWithTreeFilterMode</H3>
<PRE>
protected void <B>dealWithTreeFilterMode</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="defineGrammarSymbols()"><!-- --></A><H3>
defineGrammarSymbols</H3>
<PRE>
public void <B>defineGrammarSymbols</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="checkNameSpaceAndActions()"><!-- --></A><H3>
checkNameSpaceAndActions</H3>
<PRE>
public void <B>checkNameSpaceAndActions</B>()</PRE>
<DL>
<DD>ANALYZE ACTIONS, LOOKING FOR LABEL AND ATTR REFS, sanity check
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="validImport(org.antlr.tool.Grammar)"><!-- --></A><H3>
validImport</H3>
<PRE>
public boolean <B>validImport</B>(<A HREF="../../../org/antlr/tool/Grammar.html" title="class in org.antlr.tool">Grammar</A>&nbsp;delegate)</PRE>
<DL>
<DD>Many imports are illegal such as lexer into a tree grammar
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getLexerGrammar()"><!-- --></A><H3>
getLexerGrammar</H3>
<PRE>
public java.lang.String <B>getLexerGrammar</B>()</PRE>
<DL>
<DD>If the grammar is a combined grammar, return the text of the implicit
  lexer grammar.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getImplicitlyGeneratedLexerFileName()"><!-- --></A><H3>
getImplicitlyGeneratedLexerFileName</H3>
<PRE>
public java.lang.String <B>getImplicitlyGeneratedLexerFileName</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getRecognizerName()"><!-- --></A><H3>
getRecognizerName</H3>
<PRE>
public java.lang.String <B>getRecognizerName</B>()</PRE>
<DL>
<DD>Get the name of the generated recognizer; may or may not be same
  as grammar name.
  Recognizer is TParser and TLexer from T if combined, else
  just use T regardless of grammar type.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="addArtificialMatchTokensRule(org.antlr.tool.GrammarAST, java.util.List, java.util.List, boolean)"><!-- --></A><H3>
addArtificialMatchTokensRule</H3>
<PRE>
public <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A> <B>addArtificialMatchTokensRule</B>(<A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;grammarAST,
                                               java.util.List&lt;java.lang.String&gt;&nbsp;ruleNames,
                                               java.util.List&lt;java.lang.String&gt;&nbsp;delegateNames,
                                               boolean&nbsp;filterMode)</PRE>
<DL>
<DD>Parse a rule we add artificially that is a list of the other lexer
  rules like this: "Tokens : ID | INT | SEMI ;"  nextToken() will invoke
  this to set the current token.  Add char literals before
  the rule references.

  If in filter mode, we want every alt to backtrack and we need to
  do k=1 to force the "first token def wins" rule.  Otherwise, the
  longest-match rule comes into play with LL(*).

  The ANTLRParser antlr.g file now invokes this when parsing a lexer
  grammar, which I think is proper even though it peeks at the info
  that later phases will (re)compute.  It gets a list of lexer rules
  and builds a string representing the rule; then it creates a parser
  and adds the resulting tree to the grammar's tree.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getArtificialRulesForSyntacticPredicates(org.antlr.grammar.v2.ANTLRParser, java.util.LinkedHashMap)"><!-- --></A><H3>
getArtificialRulesForSyntacticPredicates</H3>
<PRE>
protected java.util.List <B>getArtificialRulesForSyntacticPredicates</B>(org.antlr.grammar.v2.ANTLRParser&nbsp;parser,
                                                                  java.util.LinkedHashMap&nbsp;nameToSynpredASTMap)</PRE>
<DL>
<DD>for any syntactic predicates, we need to define rules for them; they will get
  defined automatically like any other rule. :)
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="createRuleStartAndStopNFAStates()"><!-- --></A><H3>
createRuleStartAndStopNFAStates</H3>
<PRE>
public void <B>createRuleStartAndStopNFAStates</B>()</PRE>
<DL>
<DD>Define all the rule begin/end NFAStates to solve forward reference
  issues.  Critical for composite grammars too.
  This is normally called on all root/delegates manually and then
  buildNFA() is called afterwards because the NFA construction needs
  to see rule start/stop states from potentially every grammar. Has
  to be have these created a priori.  Testing routines will often
  just call buildNFA(), which forces a call to this method if not
  done already. Works ONLY for single noncomposite grammars.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="buildNFA()"><!-- --></A><H3>
buildNFA</H3>
<PRE>
public void <B>buildNFA</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="createLookaheadDFAs()"><!-- --></A><H3>
createLookaheadDFAs</H3>
<PRE>
public void <B>createLookaheadDFAs</B>()</PRE>
<DL>
<DD>For each decision in this grammar, compute a single DFA using the
  NFA states associated with the decision.  The DFA construction
  determines whether or not the alternatives in the decision are
  separable using a regular lookahead language.

  Store the lookahead DFAs in the AST created from the user's grammar
  so the code generator or whoever can easily access it.

  This is a separate method because you might want to create a
  Grammar without doing the expensive analysis.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="createLookaheadDFAs(boolean)"><!-- --></A><H3>
createLookaheadDFAs</H3>
<PRE>
public void <B>createLookaheadDFAs</B>(boolean&nbsp;wackTempStructures)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="createLL_1_LookaheadDFA(int)"><!-- --></A><H3>
createLL_1_LookaheadDFA</H3>
<PRE>
public <A HREF="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</A> <B>createLL_1_LookaheadDFA</B>(int&nbsp;decision)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="makeEdgeSetsDisjoint(java.util.List)"><!-- --></A><H3>
makeEdgeSetsDisjoint</H3>
<PRE>
protected java.util.List&lt;<A HREF="../../../org/antlr/misc/IntervalSet.html" title="class in org.antlr.misc">IntervalSet</A>&gt; <B>makeEdgeSetsDisjoint</B>(java.util.List&lt;<A HREF="../../../org/antlr/misc/IntervalSet.html" title="class in org.antlr.misc">IntervalSet</A>&gt;&nbsp;edges)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="createLookaheadDFA(int, boolean)"><!-- --></A><H3>
createLookaheadDFA</H3>
<PRE>
public <A HREF="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</A> <B>createLookaheadDFA</B>(int&nbsp;decision,
                              boolean&nbsp;wackTempStructures)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="externallyAbortNFAToDFAConversion()"><!-- --></A><H3>
externallyAbortNFAToDFAConversion</H3>
<PRE>
public void <B>externallyAbortNFAToDFAConversion</B>()</PRE>
<DL>
<DD>Terminate DFA creation (grammar analysis).
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="NFAToDFAConversionExternallyAborted()"><!-- --></A><H3>
NFAToDFAConversionExternallyAborted</H3>
<PRE>
public boolean <B>NFAToDFAConversionExternallyAborted</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getNewTokenType()"><!-- --></A><H3>
getNewTokenType</H3>
<PRE>
public int <B>getNewTokenType</B>()</PRE>
<DL>
<DD>Return a new unique integer in the token type space
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="defineToken(java.lang.String, int)"><!-- --></A><H3>
defineToken</H3>
<PRE>
public void <B>defineToken</B>(java.lang.String&nbsp;text,
                        int&nbsp;tokenType)</PRE>
<DL>
<DD>Define a token at a particular token type value.  Blast an
  old value with a new one.  This is called normal grammar processsing
  and during import vocab operations to set tokens with specific values.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="defineRule(antlr.Token, java.lang.String, java.util.Map, org.antlr.tool.GrammarAST, org.antlr.tool.GrammarAST, int)"><!-- --></A><H3>
defineRule</H3>
<PRE>
public void <B>defineRule</B>(antlr.Token&nbsp;ruleToken,
                       java.lang.String&nbsp;modifier,
                       java.util.Map&nbsp;options,
                       <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;tree,
                       <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;argActionAST,
                       int&nbsp;numAlts)</PRE>
<DL>
<DD>Define a new rule.  A new rule index is created by incrementing
  ruleIndex.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="defineSyntacticPredicate(org.antlr.tool.GrammarAST, java.lang.String)"><!-- --></A><H3>
defineSyntacticPredicate</H3>
<PRE>
public java.lang.String <B>defineSyntacticPredicate</B>(<A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;blockAST,
                                                 java.lang.String&nbsp;currentRuleName)</PRE>
<DL>
<DD>Define a new predicate and get back its name for use in building
  a semantic predicate reference to the syn pred.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getSyntacticPredicates()"><!-- --></A><H3>
getSyntacticPredicates</H3>
<PRE>
public java.util.LinkedHashMap <B>getSyntacticPredicates</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getSyntacticPredicate(java.lang.String)"><!-- --></A><H3>
getSyntacticPredicate</H3>
<PRE>
public <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A> <B>getSyntacticPredicate</B>(java.lang.String&nbsp;name)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="synPredUsedInDFA(org.antlr.analysis.DFA, org.antlr.analysis.SemanticContext)"><!-- --></A><H3>
synPredUsedInDFA</H3>
<PRE>
public void <B>synPredUsedInDFA</B>(<A HREF="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</A>&nbsp;dfa,
                             <A HREF="../../../org/antlr/analysis/SemanticContext.html" title="class in org.antlr.analysis">SemanticContext</A>&nbsp;semCtx)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="defineNamedAction(org.antlr.tool.GrammarAST, java.lang.String, org.antlr.tool.GrammarAST, org.antlr.tool.GrammarAST)"><!-- --></A><H3>
defineNamedAction</H3>
<PRE>
public void <B>defineNamedAction</B>(<A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;ampersandAST,
                              java.lang.String&nbsp;scope,
                              <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;nameAST,
                              <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;actionAST)</PRE>
<DL>
<DD>Given @scope::name {action} define it for this grammar.  Later,
  the code generator will ask for the actions table.  For composite
  grammars, make sure header action propogates down to all delegates.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setSynPredGateIfNotAlready(org.antlr.stringtemplate.StringTemplate)"><!-- --></A><H3>
setSynPredGateIfNotAlready</H3>
<PRE>
public void <B>setSynPredGateIfNotAlready</B>(org.antlr.stringtemplate.StringTemplate&nbsp;gateST)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getActions()"><!-- --></A><H3>
getActions</H3>
<PRE>
public java.util.Map <B>getActions</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDefaultActionScope(int)"><!-- --></A><H3>
getDefaultActionScope</H3>
<PRE>
public java.lang.String <B>getDefaultActionScope</B>(int&nbsp;grammarType)</PRE>
<DL>
<DD>Given a grammar type, what should be the default action scope?
  If I say @members in a COMBINED grammar, for example, the
  default scope should be "parser".
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="defineLexerRuleFoundInParser(antlr.Token, org.antlr.tool.GrammarAST)"><!-- --></A><H3>
defineLexerRuleFoundInParser</H3>
<PRE>
public void <B>defineLexerRuleFoundInParser</B>(antlr.Token&nbsp;ruleToken,
                                         <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;ruleAST)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="defineLexerRuleForAliasedStringLiteral(java.lang.String, java.lang.String, int)"><!-- --></A><H3>
defineLexerRuleForAliasedStringLiteral</H3>
<PRE>
public void <B>defineLexerRuleForAliasedStringLiteral</B>(java.lang.String&nbsp;tokenID,
                                                   java.lang.String&nbsp;literal,
                                                   int&nbsp;tokenType)</PRE>
<DL>
<DD>If someone does PLUS='+' in the parser, must make sure we get
  "PLUS : '+' ;" in lexer not "T73 : '+';"
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="defineLexerRuleForStringLiteral(java.lang.String, int)"><!-- --></A><H3>
defineLexerRuleForStringLiteral</H3>
<PRE>
public void <B>defineLexerRuleForStringLiteral</B>(java.lang.String&nbsp;literal,
                                            int&nbsp;tokenType)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getLocallyDefinedRule(java.lang.String)"><!-- --></A><H3>
getLocallyDefinedRule</H3>
<PRE>
public <A HREF="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</A> <B>getLocallyDefinedRule</B>(java.lang.String&nbsp;ruleName)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getRule(java.lang.String)"><!-- --></A><H3>
getRule</H3>
<PRE>
public <A HREF="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</A> <B>getRule</B>(java.lang.String&nbsp;ruleName)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getRule(java.lang.String, java.lang.String)"><!-- --></A><H3>
getRule</H3>
<PRE>
public <A HREF="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</A> <B>getRule</B>(java.lang.String&nbsp;scopeName,
                    java.lang.String&nbsp;ruleName)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getRuleIndex(java.lang.String, java.lang.String)"><!-- --></A><H3>
getRuleIndex</H3>
<PRE>
public int <B>getRuleIndex</B>(java.lang.String&nbsp;scopeName,
                        java.lang.String&nbsp;ruleName)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getRuleIndex(java.lang.String)"><!-- --></A><H3>
getRuleIndex</H3>
<PRE>
public int <B>getRuleIndex</B>(java.lang.String&nbsp;ruleName)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getRuleName(int)"><!-- --></A><H3>
getRuleName</H3>
<PRE>
public java.lang.String <B>getRuleName</B>(int&nbsp;ruleIndex)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="generateMethodForRule(java.lang.String)"><!-- --></A><H3>
generateMethodForRule</H3>
<PRE>
public boolean <B>generateMethodForRule</B>(java.lang.String&nbsp;ruleName)</PRE>
<DL>
<DD>Should codegen.g gen rule for ruleName?
        If synpred, only gen if used in a DFA.
  If regular rule, only gen if not overridden in delegator
  Always gen Tokens rule though.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="defineGlobalScope(java.lang.String, antlr.Token)"><!-- --></A><H3>
defineGlobalScope</H3>
<PRE>
public <A HREF="../../../org/antlr/tool/AttributeScope.html" title="class in org.antlr.tool">AttributeScope</A> <B>defineGlobalScope</B>(java.lang.String&nbsp;name,
                                        antlr.Token&nbsp;scopeAction)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="createReturnScope(java.lang.String, antlr.Token)"><!-- --></A><H3>
createReturnScope</H3>
<PRE>
public <A HREF="../../../org/antlr/tool/AttributeScope.html" title="class in org.antlr.tool">AttributeScope</A> <B>createReturnScope</B>(java.lang.String&nbsp;ruleName,
                                        antlr.Token&nbsp;retAction)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="createRuleScope(java.lang.String, antlr.Token)"><!-- --></A><H3>
createRuleScope</H3>
<PRE>
public <A HREF="../../../org/antlr/tool/AttributeScope.html" title="class in org.antlr.tool">AttributeScope</A> <B>createRuleScope</B>(java.lang.String&nbsp;ruleName,
                                      antlr.Token&nbsp;scopeAction)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="createParameterScope(java.lang.String, antlr.Token)"><!-- --></A><H3>
createParameterScope</H3>
<PRE>
public <A HREF="../../../org/antlr/tool/AttributeScope.html" title="class in org.antlr.tool">AttributeScope</A> <B>createParameterScope</B>(java.lang.String&nbsp;ruleName,
                                           antlr.Token&nbsp;argAction)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getGlobalScope(java.lang.String)"><!-- --></A><H3>
getGlobalScope</H3>
<PRE>
public <A HREF="../../../org/antlr/tool/AttributeScope.html" title="class in org.antlr.tool">AttributeScope</A> <B>getGlobalScope</B>(java.lang.String&nbsp;name)</PRE>
<DL>
<DD>Get a global scope
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getGlobalScopes()"><!-- --></A><H3>
getGlobalScopes</H3>
<PRE>
public java.util.Map <B>getGlobalScopes</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="defineLabel(org.antlr.tool.Rule, antlr.Token, org.antlr.tool.GrammarAST, int)"><!-- --></A><H3>
defineLabel</H3>
<PRE>
protected void <B>defineLabel</B>(<A HREF="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</A>&nbsp;r,
                           antlr.Token&nbsp;label,
                           <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;element,
                           int&nbsp;type)</PRE>
<DL>
<DD>Define a label defined in a rule r; check the validity then ask the
  Rule object to actually define it.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="defineTokenRefLabel(java.lang.String, antlr.Token, org.antlr.tool.GrammarAST)"><!-- --></A><H3>
defineTokenRefLabel</H3>
<PRE>
public void <B>defineTokenRefLabel</B>(java.lang.String&nbsp;ruleName,
                                antlr.Token&nbsp;label,
                                <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;tokenRef)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="defineWildcardTreeLabel(java.lang.String, antlr.Token, org.antlr.tool.GrammarAST)"><!-- --></A><H3>
defineWildcardTreeLabel</H3>
<PRE>
public void <B>defineWildcardTreeLabel</B>(java.lang.String&nbsp;ruleName,
                                    antlr.Token&nbsp;label,
                                    <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;tokenRef)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="defineWildcardTreeListLabel(java.lang.String, antlr.Token, org.antlr.tool.GrammarAST)"><!-- --></A><H3>
defineWildcardTreeListLabel</H3>
<PRE>
public void <B>defineWildcardTreeListLabel</B>(java.lang.String&nbsp;ruleName,
                                        antlr.Token&nbsp;label,
                                        <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;tokenRef)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="defineRuleRefLabel(java.lang.String, antlr.Token, org.antlr.tool.GrammarAST)"><!-- --></A><H3>
defineRuleRefLabel</H3>
<PRE>
public void <B>defineRuleRefLabel</B>(java.lang.String&nbsp;ruleName,
                               antlr.Token&nbsp;label,
                               <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;ruleRef)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="defineTokenListLabel(java.lang.String, antlr.Token, org.antlr.tool.GrammarAST)"><!-- --></A><H3>
defineTokenListLabel</H3>
<PRE>
public void <B>defineTokenListLabel</B>(java.lang.String&nbsp;ruleName,
                                 antlr.Token&nbsp;label,
                                 <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;element)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="defineRuleListLabel(java.lang.String, antlr.Token, org.antlr.tool.GrammarAST)"><!-- --></A><H3>
defineRuleListLabel</H3>
<PRE>
public void <B>defineRuleListLabel</B>(java.lang.String&nbsp;ruleName,
                                antlr.Token&nbsp;label,
                                <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;element)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getLabels(java.util.Set, int)"><!-- --></A><H3>
getLabels</H3>
<PRE>
public java.util.Set&lt;java.lang.String&gt; <B>getLabels</B>(java.util.Set&lt;<A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&gt;&nbsp;rewriteElements,
                                                 int&nbsp;labelType)</PRE>
<DL>
<DD>Given a set of all rewrite elements on right of ->, filter for
  label types such as Grammar.TOKEN_LABEL, Grammar.TOKEN_LIST_LABEL, ...
  Return a displayable token type name computed from the GrammarAST.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="examineAllExecutableActions()"><!-- --></A><H3>
examineAllExecutableActions</H3>
<PRE>
protected void <B>examineAllExecutableActions</B>()</PRE>
<DL>
<DD>Before generating code, we examine all actions that can have
  $x.y and $y stuff in them because some code generation depends on
  Rule.referencedPredefinedRuleAttributes.  I need to remove unused
  rule labels for example.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="checkAllRulesForUselessLabels()"><!-- --></A><H3>
checkAllRulesForUselessLabels</H3>
<PRE>
public void <B>checkAllRulesForUselessLabels</B>()</PRE>
<DL>
<DD>Remove all labels on rule refs whose target rules have no return value.
  Do this for all rules in grammar.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="removeUselessLabels(java.util.Map)"><!-- --></A><H3>
removeUselessLabels</H3>
<PRE>
protected void <B>removeUselessLabels</B>(java.util.Map&nbsp;ruleToElementLabelPairMap)</PRE>
<DL>
<DD>A label on a rule is useless if the rule has no return value, no
  tree or template output, and it is not referenced in an action.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="altReferencesRule(java.lang.String, org.antlr.tool.GrammarAST, org.antlr.tool.GrammarAST, int)"><!-- --></A><H3>
altReferencesRule</H3>
<PRE>
public void <B>altReferencesRule</B>(java.lang.String&nbsp;enclosingRuleName,
                              <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;refScopeAST,
                              <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;refAST,
                              int&nbsp;outerAltNum)</PRE>
<DL>
<DD>Track a rule reference within an outermost alt of a rule.  Used
  at the moment to decide if $ruleref refers to a unique rule ref in
  the alt.  Rewrite rules force tracking of all rule AST results.

  This data is also used to verify that all rules have been defined.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="altReferencesTokenID(java.lang.String, org.antlr.tool.GrammarAST, int)"><!-- --></A><H3>
altReferencesTokenID</H3>
<PRE>
public void <B>altReferencesTokenID</B>(java.lang.String&nbsp;ruleName,
                                 <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;refAST,
                                 int&nbsp;outerAltNum)</PRE>
<DL>
<DD>Track a token reference within an outermost alt of a rule.  Used
  to decide if $tokenref refers to a unique token ref in
  the alt. Does not track literals!

  Rewrite rules force tracking of all tokens.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="referenceRuleLabelPredefinedAttribute(java.lang.String)"><!-- --></A><H3>
referenceRuleLabelPredefinedAttribute</H3>
<PRE>
public void <B>referenceRuleLabelPredefinedAttribute</B>(java.lang.String&nbsp;ruleName)</PRE>
<DL>
<DD>To yield smaller, more readable code, track which rules have their
  predefined attributes accessed.  If the rule has no user-defined
  return values, then don't generate the return value scope classes
  etc...  Make the rule have void return value.  Don't track for lexer
  rules.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="checkAllRulesForLeftRecursion()"><!-- --></A><H3>
checkAllRulesForLeftRecursion</H3>
<PRE>
public java.util.List <B>checkAllRulesForLeftRecursion</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getLeftRecursiveRules()"><!-- --></A><H3>
getLeftRecursiveRules</H3>
<PRE>
public java.util.Set&lt;<A HREF="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</A>&gt; <B>getLeftRecursiveRules</B>()</PRE>
<DL>
<DD>Return a list of left-recursive rules; no analysis can be done
  successfully on these.  Useful to skip these rules then and also
  for ANTLRWorks to highlight them.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="checkRuleReference(org.antlr.tool.GrammarAST, org.antlr.tool.GrammarAST, org.antlr.tool.GrammarAST, java.lang.String)"><!-- --></A><H3>
checkRuleReference</H3>
<PRE>
public void <B>checkRuleReference</B>(<A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;scopeAST,
                               <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;refAST,
                               <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;argsAST,
                               java.lang.String&nbsp;currentRuleName)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isEmptyRule(org.antlr.tool.GrammarAST)"><!-- --></A><H3>
isEmptyRule</H3>
<PRE>
public boolean <B>isEmptyRule</B>(<A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;block)</PRE>
<DL>
<DD>Rules like "a : ;" and "a : {...} ;" should not generate
  try/catch blocks for RecognitionException.  To detect this
  it's probably ok to just look for any reference to an atom
  that can match some input.  W/o that, the rule is unlikey to have
  any else.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isAtomTokenType(int)"><!-- --></A><H3>
isAtomTokenType</H3>
<PRE>
public boolean <B>isAtomTokenType</B>(int&nbsp;ttype)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getTokenType(java.lang.String)"><!-- --></A><H3>
getTokenType</H3>
<PRE>
public int <B>getTokenType</B>(java.lang.String&nbsp;tokenName)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getTokenIDs()"><!-- --></A><H3>
getTokenIDs</H3>
<PRE>
public java.util.Set <B>getTokenIDs</B>()</PRE>
<DL>
<DD>Get the list of tokens that are IDs like BLOCK and LPAREN
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getTokenTypesWithoutID()"><!-- --></A><H3>
getTokenTypesWithoutID</H3>
<PRE>
public java.util.Collection <B>getTokenTypesWithoutID</B>()</PRE>
<DL>
<DD>Return an ordered integer list of token types that have no
  corresponding token ID like INT or KEYWORD_BEGIN; for stuff
  like 'begin'.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getTokenDisplayNames()"><!-- --></A><H3>
getTokenDisplayNames</H3>
<PRE>
public java.util.Set&lt;java.lang.String&gt; <B>getTokenDisplayNames</B>()</PRE>
<DL>
<DD>Get a list of all token IDs and literals that have an associated
  token type.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getCharValueFromGrammarCharLiteral(java.lang.String)"><!-- --></A><H3>
getCharValueFromGrammarCharLiteral</H3>
<PRE>
public static int <B>getCharValueFromGrammarCharLiteral</B>(java.lang.String&nbsp;literal)</PRE>
<DL>
<DD>Given a literal like (the 3 char sequence with single quotes) 'a',
  return the int value of 'a'. Convert escape sequences here also.
  ANTLR's antlr.g parser does not convert escape sequences.

  11/26/2005: I changed literals to always be '...' even for strings.
  This routine still works though.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getUnescapedStringFromGrammarStringLiteral(java.lang.String)"><!-- --></A><H3>
getUnescapedStringFromGrammarStringLiteral</H3>
<PRE>
public static java.lang.StringBuffer <B>getUnescapedStringFromGrammarStringLiteral</B>(java.lang.String&nbsp;literal)</PRE>
<DL>
<DD>ANTLR does not convert escape sequences during the parse phase because
  it could not know how to print String/char literals back out when
  printing grammars etc...  Someone in China might use the real unicode
  char in a literal as it will display on their screen; when printing
  back out, I could not know whether to display or use a unicode escape.

  This routine converts a string literal with possible escape sequences
  into a pure string of 16-bit char values.  Escapes and unicode  
  specs are converted to pure chars.  return in a buffer; people may
  want to walk/manipulate further.

  The NFA construction routine must know the actual char values.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="importTokenVocabulary(org.antlr.tool.Grammar)"><!-- --></A><H3>
importTokenVocabulary</H3>
<PRE>
public int <B>importTokenVocabulary</B>(<A HREF="../../../org/antlr/tool/Grammar.html" title="class in org.antlr.tool">Grammar</A>&nbsp;importFromGr)</PRE>
<DL>
<DD>Pull your token definitions from an existing grammar in memory.
  You must use Grammar() ctor then this method then setGrammarContent()
  to make this work.  This was useful primarily for testing and
  interpreting grammars until I added import grammar functionality.
  When you import a grammar you implicitly import its vocabulary as well
  and keep the same token type values.

  Returns the max token type found.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="importGrammar(org.antlr.tool.GrammarAST, java.lang.String)"><!-- --></A><H3>
importGrammar</H3>
<PRE>
public void <B>importGrammar</B>(<A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;grammarNameAST,
                          java.lang.String&nbsp;label)</PRE>
<DL>
<DD>Import the rules/tokens of a delegate grammar. All delegate grammars are
  read during the ctor of first Grammar created.

  Do not create NFA here because NFA construction needs to hook up with
  overridden rules in delegation root grammar.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="addDelegateGrammar(org.antlr.tool.Grammar)"><!-- --></A><H3>
addDelegateGrammar</H3>
<PRE>
protected void <B>addDelegateGrammar</B>(<A HREF="../../../org/antlr/tool/Grammar.html" title="class in org.antlr.tool">Grammar</A>&nbsp;delegateGrammar)</PRE>
<DL>
<DD>add new delegate to composite tree
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="importTokenVocabulary(org.antlr.tool.GrammarAST, java.lang.String)"><!-- --></A><H3>
importTokenVocabulary</H3>
<PRE>
public int <B>importTokenVocabulary</B>(<A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;tokenVocabOptionAST,
                                 java.lang.String&nbsp;vocabName)</PRE>
<DL>
<DD>Load a vocab file <vocabName>.tokens and return max token type found.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getTokenDisplayName(int)"><!-- --></A><H3>
getTokenDisplayName</H3>
<PRE>
public java.lang.String <B>getTokenDisplayName</B>(int&nbsp;ttype)</PRE>
<DL>
<DD>Given a token type, get a meaningful name for it such as the ID
  or string literal.  If this is a lexer and the ttype is in the
  char vocabulary, compute an ANTLR-valid (possibly escaped) char literal.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getStringLiterals()"><!-- --></A><H3>
getStringLiterals</H3>
<PRE>
public java.util.Set&lt;java.lang.String&gt; <B>getStringLiterals</B>()</PRE>
<DL>
<DD>Get the list of ANTLR String literals
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getGrammarTypeString()"><!-- --></A><H3>
getGrammarTypeString</H3>
<PRE>
public java.lang.String <B>getGrammarTypeString</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getGrammarMaxLookahead()"><!-- --></A><H3>
getGrammarMaxLookahead</H3>
<PRE>
public int <B>getGrammarMaxLookahead</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setOption(java.lang.String, java.lang.Object, antlr.Token)"><!-- --></A><H3>
setOption</H3>
<PRE>
public java.lang.String <B>setOption</B>(java.lang.String&nbsp;key,
                                  java.lang.Object&nbsp;value,
                                  antlr.Token&nbsp;optionsStartToken)</PRE>
<DL>
<DD>Save the option key/value pair and process it; return the key
  or null if invalid option.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="legalOption(java.lang.String)"><!-- --></A><H3>
legalOption</H3>
<PRE>
public boolean <B>legalOption</B>(java.lang.String&nbsp;key)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setOptions(java.util.Map, antlr.Token)"><!-- --></A><H3>
setOptions</H3>
<PRE>
public void <B>setOptions</B>(java.util.Map&nbsp;options,
                       antlr.Token&nbsp;optionsStartToken)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getOption(java.lang.String)"><!-- --></A><H3>
getOption</H3>
<PRE>
public java.lang.Object <B>getOption</B>(java.lang.String&nbsp;key)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getLocallyDefinedOption(java.lang.String)"><!-- --></A><H3>
getLocallyDefinedOption</H3>
<PRE>
public java.lang.Object <B>getLocallyDefinedOption</B>(java.lang.String&nbsp;key)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getBlockOption(org.antlr.tool.GrammarAST, java.lang.String)"><!-- --></A><H3>
getBlockOption</H3>
<PRE>
public java.lang.Object <B>getBlockOption</B>(<A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;blockAST,
                                       java.lang.String&nbsp;key)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getUserMaxLookahead(int)"><!-- --></A><H3>
getUserMaxLookahead</H3>
<PRE>
public int <B>getUserMaxLookahead</B>(int&nbsp;decision)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getAutoBacktrackMode(int)"><!-- --></A><H3>
getAutoBacktrackMode</H3>
<PRE>
public boolean <B>getAutoBacktrackMode</B>(int&nbsp;decision)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="optionIsValid(java.lang.String, java.lang.Object)"><!-- --></A><H3>
optionIsValid</H3>
<PRE>
public boolean <B>optionIsValid</B>(java.lang.String&nbsp;key,
                             java.lang.Object&nbsp;value)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="buildAST()"><!-- --></A><H3>
buildAST</H3>
<PRE>
public boolean <B>buildAST</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="rewriteMode()"><!-- --></A><H3>
rewriteMode</H3>
<PRE>
public boolean <B>rewriteMode</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isBuiltFromString()"><!-- --></A><H3>
isBuiltFromString</H3>
<PRE>
public boolean <B>isBuiltFromString</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="buildTemplate()"><!-- --></A><H3>
buildTemplate</H3>
<PRE>
public boolean <B>buildTemplate</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getRules()"><!-- --></A><H3>
getRules</H3>
<PRE>
public java.util.Collection&lt;<A HREF="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</A>&gt; <B>getRules</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDelegatedRules()"><!-- --></A><H3>
getDelegatedRules</H3>
<PRE>
public java.util.Set&lt;<A HREF="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</A>&gt; <B>getDelegatedRules</B>()</PRE>
<DL>
<DD>Get the set of Rules that need to have manual delegations
  like "void rule() { importedGrammar.rule(); }"

  If this grammar is master, get list of all rule definitions from all
  delegate grammars.  Only master has complete interface from combined
  grammars...we will generated delegates as helper objects.

  Composite grammars that are not the root/master do not have complete
  interfaces.  It is not my intention that people use subcomposites.
  Only the outermost grammar should be used from outside code.  The
  other grammar components are specifically generated to work only
  with the master/root. 

  delegatedRules = imported - overridden
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getAllImportedRules()"><!-- --></A><H3>
getAllImportedRules</H3>
<PRE>
public java.util.Set&lt;<A HREF="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</A>&gt; <B>getAllImportedRules</B>()</PRE>
<DL>
<DD>Get set of all rules imported from all delegate grammars even if
  indirectly delegated.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDelegates()"><!-- --></A><H3>
getDelegates</H3>
<PRE>
public java.util.List&lt;<A HREF="../../../org/antlr/tool/Grammar.html" title="class in org.antlr.tool">Grammar</A>&gt; <B>getDelegates</B>()</PRE>
<DL>
<DD>Get list of all delegates from all grammars directly or indirectly
  imported into this grammar.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDelegateNames()"><!-- --></A><H3>
getDelegateNames</H3>
<PRE>
public java.util.List&lt;java.lang.String&gt; <B>getDelegateNames</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDirectDelegates()"><!-- --></A><H3>
getDirectDelegates</H3>
<PRE>
public java.util.List&lt;<A HREF="../../../org/antlr/tool/Grammar.html" title="class in org.antlr.tool">Grammar</A>&gt; <B>getDirectDelegates</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getIndirectDelegates()"><!-- --></A><H3>
getIndirectDelegates</H3>
<PRE>
public java.util.List&lt;<A HREF="../../../org/antlr/tool/Grammar.html" title="class in org.antlr.tool">Grammar</A>&gt; <B>getIndirectDelegates</B>()</PRE>
<DL>
<DD>Get delegates below direct delegates
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDelegators()"><!-- --></A><H3>
getDelegators</H3>
<PRE>
public java.util.List&lt;<A HREF="../../../org/antlr/tool/Grammar.html" title="class in org.antlr.tool">Grammar</A>&gt; <B>getDelegators</B>()</PRE>
<DL>
<DD>Get list of all delegators.  This amounts to the grammars on the path
  to the root of the delegation tree.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDelegator()"><!-- --></A><H3>
getDelegator</H3>
<PRE>
public <A HREF="../../../org/antlr/tool/Grammar.html" title="class in org.antlr.tool">Grammar</A> <B>getDelegator</B>()</PRE>
<DL>
<DD>Who's my direct parent grammar?
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDelegatedRuleReferences()"><!-- --></A><H3>
getDelegatedRuleReferences</H3>
<PRE>
public java.util.Set&lt;<A HREF="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</A>&gt; <B>getDelegatedRuleReferences</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getGrammarIsRoot()"><!-- --></A><H3>
getGrammarIsRoot</H3>
<PRE>
public boolean <B>getGrammarIsRoot</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setRuleAST(java.lang.String, org.antlr.tool.GrammarAST)"><!-- --></A><H3>
setRuleAST</H3>
<PRE>
public void <B>setRuleAST</B>(java.lang.String&nbsp;ruleName,
                       <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;t)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getRuleStartState(java.lang.String)"><!-- --></A><H3>
getRuleStartState</H3>
<PRE>
public <A HREF="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</A> <B>getRuleStartState</B>(java.lang.String&nbsp;ruleName)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getRuleStartState(java.lang.String, java.lang.String)"><!-- --></A><H3>
getRuleStartState</H3>
<PRE>
public <A HREF="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</A> <B>getRuleStartState</B>(java.lang.String&nbsp;scopeName,
                                  java.lang.String&nbsp;ruleName)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getRuleModifier(java.lang.String)"><!-- --></A><H3>
getRuleModifier</H3>
<PRE>
public java.lang.String <B>getRuleModifier</B>(java.lang.String&nbsp;ruleName)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getRuleStopState(java.lang.String)"><!-- --></A><H3>
getRuleStopState</H3>
<PRE>
public <A HREF="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</A> <B>getRuleStopState</B>(java.lang.String&nbsp;ruleName)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="assignDecisionNumber(org.antlr.analysis.NFAState)"><!-- --></A><H3>
assignDecisionNumber</H3>
<PRE>
public int <B>assignDecisionNumber</B>(<A HREF="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</A>&nbsp;state)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDecision(int)"><!-- --></A><H3>
getDecision</H3>
<PRE>
protected <A HREF="../../../org/antlr/tool/Grammar.Decision.html" title="class in org.antlr.tool">Grammar.Decision</A> <B>getDecision</B>(int&nbsp;decision)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="createDecision(int)"><!-- --></A><H3>
createDecision</H3>
<PRE>
protected <A HREF="../../../org/antlr/tool/Grammar.Decision.html" title="class in org.antlr.tool">Grammar.Decision</A> <B>createDecision</B>(int&nbsp;decision)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDecisionNFAStartStateList()"><!-- --></A><H3>
getDecisionNFAStartStateList</H3>
<PRE>
public java.util.List <B>getDecisionNFAStartStateList</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDecisionNFAStartState(int)"><!-- --></A><H3>
getDecisionNFAStartState</H3>
<PRE>
public <A HREF="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</A> <B>getDecisionNFAStartState</B>(int&nbsp;decision)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getLookaheadDFA(int)"><!-- --></A><H3>
getLookaheadDFA</H3>
<PRE>
public <A HREF="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</A> <B>getLookaheadDFA</B>(int&nbsp;decision)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDecisionBlockAST(int)"><!-- --></A><H3>
getDecisionBlockAST</H3>
<PRE>
public <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A> <B>getDecisionBlockAST</B>(int&nbsp;decision)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getLookaheadDFAColumnsForLineInFile(int)"><!-- --></A><H3>
getLookaheadDFAColumnsForLineInFile</H3>
<PRE>
public java.util.List <B>getLookaheadDFAColumnsForLineInFile</B>(int&nbsp;line)</PRE>
<DL>
<DD>returns a list of column numbers for all decisions
  on a particular line so ANTLRWorks choose the decision
  depending on the location of the cursor (otherwise,
  ANTLRWorks has to give the *exact* location which
  is not easy from the user point of view).

  This is not particularly fast as it walks entire line:col->DFA map
  looking for a prefix of "line:".
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getLookaheadDFAFromPositionInFile(int, int)"><!-- --></A><H3>
getLookaheadDFAFromPositionInFile</H3>
<PRE>
public <A HREF="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</A> <B>getLookaheadDFAFromPositionInFile</B>(int&nbsp;line,
                                             int&nbsp;col)</PRE>
<DL>
<DD>Useful for ANTLRWorks to map position in file to the DFA for display
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getLineColumnToLookaheadDFAMap()"><!-- --></A><H3>
getLineColumnToLookaheadDFAMap</H3>
<PRE>
public java.util.Map <B>getLineColumnToLookaheadDFAMap</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getNumberOfDecisions()"><!-- --></A><H3>
getNumberOfDecisions</H3>
<PRE>
public int <B>getNumberOfDecisions</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getNumberOfCyclicDecisions()"><!-- --></A><H3>
getNumberOfCyclicDecisions</H3>
<PRE>
public int <B>getNumberOfCyclicDecisions</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setLookaheadDFA(int, org.antlr.analysis.DFA)"><!-- --></A><H3>
setLookaheadDFA</H3>
<PRE>
public void <B>setLookaheadDFA</B>(int&nbsp;decision,
                            <A HREF="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</A>&nbsp;lookaheadDFA)</PRE>
<DL>
<DD>Set the lookahead DFA for a particular decision.  This means
  that the appropriate AST node must updated to have the new lookahead
  DFA.  This method could be used to properly set the DFAs without
  using the createLookaheadDFAs() method.  You could do this

    Grammar g = new Grammar("...");
    g.setLookahead(1, dfa1);
    g.setLookahead(2, dfa2);
    ...
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setDecisionNFA(int, org.antlr.analysis.NFAState)"><!-- --></A><H3>
setDecisionNFA</H3>
<PRE>
public void <B>setDecisionNFA</B>(int&nbsp;decision,
                           <A HREF="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</A>&nbsp;state)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setDecisionBlockAST(int, org.antlr.tool.GrammarAST)"><!-- --></A><H3>
setDecisionBlockAST</H3>
<PRE>
public void <B>setDecisionBlockAST</B>(int&nbsp;decision,
                                <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;blockAST)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="allDecisionDFAHaveBeenCreated()"><!-- --></A><H3>
allDecisionDFAHaveBeenCreated</H3>
<PRE>
public boolean <B>allDecisionDFAHaveBeenCreated</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getMaxTokenType()"><!-- --></A><H3>
getMaxTokenType</H3>
<PRE>
public int <B>getMaxTokenType</B>()</PRE>
<DL>
<DD>How many token types have been allocated so far?
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getMaxCharValue()"><!-- --></A><H3>
getMaxCharValue</H3>
<PRE>
public int <B>getMaxCharValue</B>()</PRE>
<DL>
<DD>What is the max char value possible for this grammar's target?  Use
  unicode max if no target defined.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getTokenTypes()"><!-- --></A><H3>
getTokenTypes</H3>
<PRE>
public <A HREF="../../../org/antlr/misc/IntSet.html" title="interface in org.antlr.misc">IntSet</A> <B>getTokenTypes</B>()</PRE>
<DL>
<DD>Return a set of all possible token or char types for this grammar
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getAllCharValues()"><!-- --></A><H3>
getAllCharValues</H3>
<PRE>
public <A HREF="../../../org/antlr/misc/IntSet.html" title="interface in org.antlr.misc">IntSet</A> <B>getAllCharValues</B>()</PRE>
<DL>
<DD>If there is a char vocabulary, use it; else return min to max char
  as defined by the target.  If no target, use max unicode char value.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getANTLRCharLiteralForChar(int)"><!-- --></A><H3>
getANTLRCharLiteralForChar</H3>
<PRE>
public static java.lang.String <B>getANTLRCharLiteralForChar</B>(int&nbsp;c)</PRE>
<DL>
<DD>Return a string representing the escaped char for code c.  E.g., If c
  has value 0x100, you will get "Ā".  ASCII gets the usual
  char (non-hex) representation.  Control characters are spit out
  as unicode.  While this is specially set up for returning Java strings,
  it can be used by any language target that has the same syntax. :)

  11/26/2005: I changed this to use double quotes, consistent with antlr.g
  12/09/2005: I changed so everything is single quotes
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="complement(org.antlr.misc.IntSet)"><!-- --></A><H3>
complement</H3>
<PRE>
public <A HREF="../../../org/antlr/misc/IntSet.html" title="interface in org.antlr.misc">IntSet</A> <B>complement</B>(<A HREF="../../../org/antlr/misc/IntSet.html" title="interface in org.antlr.misc">IntSet</A>&nbsp;set)</PRE>
<DL>
<DD>For lexer grammars, return everything in unicode not in set.
  For parser and tree grammars, return everything in token space
  from MIN_TOKEN_TYPE to last valid token type or char value.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="complement(int)"><!-- --></A><H3>
complement</H3>
<PRE>
public <A HREF="../../../org/antlr/misc/IntSet.html" title="interface in org.antlr.misc">IntSet</A> <B>complement</B>(int&nbsp;atom)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isValidSet(org.antlr.grammar.v2.TreeToNFAConverter, org.antlr.tool.GrammarAST)"><!-- --></A><H3>
isValidSet</H3>
<PRE>
public boolean <B>isValidSet</B>(org.antlr.grammar.v2.TreeToNFAConverter&nbsp;nfabuilder,
                          <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;t)</PRE>
<DL>
<DD>Given set tree like ( SET A B ), check that A and B
  are both valid sets themselves, else we must tree like a BLOCK
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getSetFromRule(org.antlr.grammar.v2.TreeToNFAConverter, java.lang.String)"><!-- --></A><H3>
getSetFromRule</H3>
<PRE>
public <A HREF="../../../org/antlr/misc/IntSet.html" title="interface in org.antlr.misc">IntSet</A> <B>getSetFromRule</B>(org.antlr.grammar.v2.TreeToNFAConverter&nbsp;nfabuilder,
                             java.lang.String&nbsp;ruleName)
                      throws antlr.RecognitionException</PRE>
<DL>
<DD>Get the set equivalent (if any) of the indicated rule from this
  grammar.  Mostly used in the lexer to do ~T for some fragment rule
  T.  If the rule AST has a SET use that.  If the rule is a single char
  convert it to a set and return.  If rule is not a simple set (w/o actions)
  then return null.
  Rules have AST form:

                ^( RULE ID modifier ARG RET SCOPE block EOR )
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>antlr.RecognitionException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="getNumberOfAltsForDecisionNFA(org.antlr.analysis.NFAState)"><!-- --></A><H3>
getNumberOfAltsForDecisionNFA</H3>
<PRE>
public int <B>getNumberOfAltsForDecisionNFA</B>(<A HREF="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</A>&nbsp;decisionState)</PRE>
<DL>
<DD>Decisions are linked together with transition(1).  Count how
  many there are.  This is here rather than in NFAState because
  a grammar decides how NFAs are put together to form a decision.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getNFAStateForAltOfDecision(org.antlr.analysis.NFAState, int)"><!-- --></A><H3>
getNFAStateForAltOfDecision</H3>
<PRE>
public <A HREF="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</A> <B>getNFAStateForAltOfDecision</B>(<A HREF="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</A>&nbsp;decisionState,
                                            int&nbsp;alt)</PRE>
<DL>
<DD>Get the ith alternative (1..n) from a decision; return null when
  an invalid alt is requested.  I must count in to find the right
  alternative number.  For (A|B), you get NFA structure (roughly):

  o->o-A->o
  |
  o->o-B->o

  This routine returns the leftmost state for each alt.  So alt=1, returns
  the upperleft most state in this structure.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="FIRST(org.antlr.analysis.NFAState)"><!-- --></A><H3>
FIRST</H3>
<PRE>
public <A HREF="../../../org/antlr/analysis/LookaheadSet.html" title="class in org.antlr.analysis">LookaheadSet</A> <B>FIRST</B>(<A HREF="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</A>&nbsp;s)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="LOOK(org.antlr.analysis.NFAState)"><!-- --></A><H3>
LOOK</H3>
<PRE>
public <A HREF="../../../org/antlr/analysis/LookaheadSet.html" title="class in org.antlr.analysis">LookaheadSet</A> <B>LOOK</B>(<A HREF="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</A>&nbsp;s)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setCodeGenerator(org.antlr.codegen.CodeGenerator)"><!-- --></A><H3>
setCodeGenerator</H3>
<PRE>
public void <B>setCodeGenerator</B>(<A HREF="../../../org/antlr/codegen/CodeGenerator.html" title="class in org.antlr.codegen">CodeGenerator</A>&nbsp;generator)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getCodeGenerator()"><!-- --></A><H3>
getCodeGenerator</H3>
<PRE>
public <A HREF="../../../org/antlr/codegen/CodeGenerator.html" title="class in org.antlr.codegen">CodeGenerator</A> <B>getCodeGenerator</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getGrammarTree()"><!-- --></A><H3>
getGrammarTree</H3>
<PRE>
public <A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A> <B>getGrammarTree</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getTool()"><!-- --></A><H3>
getTool</H3>
<PRE>
public <A HREF="../../../org/antlr/Tool.html" title="class in org.antlr">Tool</A> <B>getTool</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setTool(org.antlr.Tool)"><!-- --></A><H3>
setTool</H3>
<PRE>
public void <B>setTool</B>(<A HREF="../../../org/antlr/Tool.html" title="class in org.antlr">Tool</A>&nbsp;tool)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="computeTokenNameFromLiteral(int, java.lang.String)"><!-- --></A><H3>
computeTokenNameFromLiteral</H3>
<PRE>
public java.lang.String <B>computeTokenNameFromLiteral</B>(int&nbsp;tokenType,
                                                    java.lang.String&nbsp;literal)</PRE>
<DL>
<DD>given a token type and the text of the literal, come up with a
  decent token type label.  For now it's just T<type>.  Actually,
  if there is an aliased name from tokens like PLUS='+', use it.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public java.lang.String <B>toString</B>()</PRE>
<DL>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>toString</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="grammarTreeToString(org.antlr.tool.GrammarAST)"><!-- --></A><H3>
grammarTreeToString</H3>
<PRE>
public java.lang.String <B>grammarTreeToString</B>(<A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;t)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="grammarTreeToString(org.antlr.tool.GrammarAST, boolean)"><!-- --></A><H3>
grammarTreeToString</H3>
<PRE>
public java.lang.String <B>grammarTreeToString</B>(<A HREF="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</A>&nbsp;t,
                                            boolean&nbsp;showActions)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="printGrammar(java.io.PrintStream)"><!-- --></A><H3>
printGrammar</H3>
<PRE>
public void <B>printGrammar</B>(java.io.PrintStream&nbsp;output)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/antlr/tool/FASerializer.html" title="class in org.antlr.tool"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../org/antlr/tool/Grammar.Decision.html" title="class in org.antlr.tool"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/antlr/tool/Grammar.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Grammar.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
