<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_16) on Wed Oct 14 09:00:04 EDT 2009 -->
<TITLE>
NFAContext
</TITLE>

<META NAME="date" CONTENT="2009-10-14">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="NFAContext";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/antlr/analysis/NFAConfiguration.html" title="class in org.antlr.analysis"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../org/antlr/analysis/NFAConversionThread.html" title="class in org.antlr.analysis"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/antlr/analysis/NFAContext.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="NFAContext.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.antlr.analysis</FONT>
<BR>
Class NFAContext</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>org.antlr.analysis.NFAContext</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>NFAContext</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
A tree node for tracking the call chains for NFAs that invoke
  other NFAs.  These trees only have to point upwards to their parents
  so we can walk back up the tree (i.e., pop stuff off the stack).  We
  never walk from stack down down through the children.

  Each alt predicted in a decision has its own context tree,
  representing all possible return nodes.  The initial stack has
  EOF ("$") in it.  So, for m alternative productions, the lookahead
  DFA will have m NFAContext trees.

  To "push" a new context, just do "new NFAContext(context-parent, state)"
  which will add itself to the parent.  The root is NFAContext(null, null).

  The complete context for an NFA configuration is the set of invoking states
  on the path from this node thru the parent pointers to the root.
<P>

<P>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAContext.html#cachedHashCode">cachedHashCode</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing the hashCode is very expensive and closureBusy()
  uses it to track when it's seen a state|ctx before to avoid
  infinite loops.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAContext.html#invokingState">invokingState</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The NFA state that invoked another rule's start state is recorded
  on the rule invocation context stack.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAContext.html#MAX_SAME_RULE_INVOCATIONS_PER_NFA_CONFIG_STACK">MAX_SAME_RULE_INVOCATIONS_PER_NFA_CONFIG_STACK</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is similar to Bermudez's m constant in his LAR(m) where
  you bound the stack so your states don't explode.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/analysis/NFAContext.html" title="class in org.antlr.analysis">NFAContext</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAContext.html#parent">parent</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAContext.html#NFAContext(org.antlr.analysis.NFAContext, org.antlr.analysis.NFAState)">NFAContext</A></B>(<A HREF="../../../org/antlr/analysis/NFAContext.html" title="class in org.antlr.analysis">NFAContext</A>&nbsp;parent,
           <A HREF="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</A>&nbsp;invokingState)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAContext.html#conflictsWith(org.antlr.analysis.NFAContext)">conflictsWith</A></B>(<A HREF="../../../org/antlr/analysis/NFAContext.html" title="class in org.antlr.analysis">NFAContext</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Two contexts conflict() if they are equals() or one is a stack suffix
  of the other.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAContext.html#equals(java.lang.Object)">equals</A></B>(java.lang.Object&nbsp;o)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Two contexts are equals() if both have
  same call stack; walk upwards to the root.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAContext.html#hashCode()">hashCode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAContext.html#isEmpty()">isEmpty</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A context is empty if there is no parent; meaning nobody pushed
  anything on the call stack.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAContext.html#recursionDepthEmanatingFromState(int)">recursionDepthEmanatingFromState</A></B>(int&nbsp;state)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given an NFA state number, how many times has the NFA-to-DFA
  conversion pushed that state on the stack?  In other words,
  the NFA state must be a rule invocation state and this method
  tells you how many times you've been to this state.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAContext.html#suffix(org.antlr.analysis.NFAContext)">suffix</A></B>(<A HREF="../../../org/antlr/analysis/NFAContext.html" title="class in org.antlr.analysis">NFAContext</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[$] suffix any context
  [21 $] suffix [21 12 $]
  [21 12 $] suffix [21 $]
  [21 18 $] suffix [21 18 12 9 $]
  [21 18 12 9 $] suffix [21 18 $]
  [21 12 $] not suffix [21 9 $]

  Example "[21 $] suffix [21 12 $]" means: rule r invoked current rule
  from state 21.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAContext.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, finalize, getClass, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="MAX_SAME_RULE_INVOCATIONS_PER_NFA_CONFIG_STACK"><!-- --></A><H3>
MAX_SAME_RULE_INVOCATIONS_PER_NFA_CONFIG_STACK</H3>
<PRE>
public static int <B>MAX_SAME_RULE_INVOCATIONS_PER_NFA_CONFIG_STACK</B></PRE>
<DL>
<DD>This is similar to Bermudez's m constant in his LAR(m) where
  you bound the stack so your states don't explode.  The main difference
  is that I bound only recursion on the stack, not the simple stack size.
  This looser constraint will let the conversion roam further to find
  lookahead to resolve a decision.

  Bermudez's m operates differently as it is his LR stack depth
  I'm pretty sure it therefore includes all stack symbols.  Here I
  restrict the size of an NFA configuration to be finite because a
  stack component may mention the same NFA invocation state at
  most m times.  Hence, the number of DFA states will not grow forever.
  With recursive rules like

    e : '(' e ')' | INT ;

  you could chase your tail forever if somebody said "s : e '.' | e ';' ;"
  This constant prevents new states from being created after a stack gets
  "too big".  Actually (12/14/2007) I realize that this example is
  trapped by the non-LL(*) detector for recursion in > 1 alt.  Here is
  an example that trips stack overflow:

          s : a Y | A A A A A X ; // force recursion past m=4
          a : A a | Q;

  If that were:

          s : a Y | A+ X ;

  it could loop forever.

  Imagine doing a depth-first search on the e DFA...as you chase an input
  sequence you can recurse to same rule such as e above.  You'd have a
  chain of ((((.  When you get do some point, you have to give up.  The
  states in the chain will have longer and longer NFA config stacks.
  Must limit size.

  max=0 implies you cannot ever jump to another rule during closure.
  max=1 implies you can make as many calls as you want--you just
        can't ever visit a state that is on your rule invocation stack.
                  I.e., you cannot ever recurse.
  max=2 implies you are able to recurse once (i.e., call a rule twice
          from the same place).

  This tracks recursion to a rule specific to an invocation site!
  It does not detect multiple calls to a rule from different rule
  invocation states.  We are guaranteed to terminate because the
  stack can only grow as big as the number of NFA states * max.

  I noticed that the Java grammar didn't work with max=1, but did with
  max=4.  Let's set to 4. Recursion is sometimes needed to resolve some
  fixed lookahead decisions.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="parent"><!-- --></A><H3>
parent</H3>
<PRE>
public <A HREF="../../../org/antlr/analysis/NFAContext.html" title="class in org.antlr.analysis">NFAContext</A> <B>parent</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="invokingState"><!-- --></A><H3>
invokingState</H3>
<PRE>
public <A HREF="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</A> <B>invokingState</B></PRE>
<DL>
<DD>The NFA state that invoked another rule's start state is recorded
  on the rule invocation context stack.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="cachedHashCode"><!-- --></A><H3>
cachedHashCode</H3>
<PRE>
protected int <B>cachedHashCode</B></PRE>
<DL>
<DD>Computing the hashCode is very expensive and closureBusy()
  uses it to track when it's seen a state|ctx before to avoid
  infinite loops.  As we add new contexts, record the hash code
  as this.invokingState + parent.cachedHashCode.  Avoids walking
  up the tree for every hashCode().  Note that this caching works
  because a context is a monotonically growing tree of context nodes
  and nothing on the stack is ever modified...ctx just grows
  or shrinks.
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="NFAContext(org.antlr.analysis.NFAContext, org.antlr.analysis.NFAState)"><!-- --></A><H3>
NFAContext</H3>
<PRE>
public <B>NFAContext</B>(<A HREF="../../../org/antlr/analysis/NFAContext.html" title="class in org.antlr.analysis">NFAContext</A>&nbsp;parent,
                  <A HREF="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</A>&nbsp;invokingState)</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="equals(java.lang.Object)"><!-- --></A><H3>
equals</H3>
<PRE>
public boolean <B>equals</B>(java.lang.Object&nbsp;o)</PRE>
<DL>
<DD>Two contexts are equals() if both have
  same call stack; walk upwards to the root.
  Recall that the root sentinel node has no invokingStates and no parent.
  Note that you may be comparing contexts in different alt trees.

  The hashCode is now cheap as it's computed once upon each context
  push on the stack.  Use it to make equals() more efficient.
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>equals</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="conflictsWith(org.antlr.analysis.NFAContext)"><!-- --></A><H3>
conflictsWith</H3>
<PRE>
public boolean <B>conflictsWith</B>(<A HREF="../../../org/antlr/analysis/NFAContext.html" title="class in org.antlr.analysis">NFAContext</A>&nbsp;other)</PRE>
<DL>
<DD>Two contexts conflict() if they are equals() or one is a stack suffix
  of the other.  For example, contexts [21 12 $] and [21 9 $] do not
  conflict, but [21 $] and [21 12 $] do conflict.  Note that I should
  probably not show the $ in this case.  There is a dummy node for each
  stack that just means empty; $ is a marker that's all.

  This is used in relation to checking conflicts associated with a
  single NFA state's configurations within a single DFA state.
  If there are configurations s and t within a DFA state such that
  s.state=t.state && s.alt != t.alt && s.ctx conflicts t.ctx then
  the DFA state predicts more than a single alt--it's nondeterministic.
  Two contexts conflict if they are the same or if one is a suffix
  of the other.

  When comparing contexts, if one context has a stack and the other
  does not then they should be considered the same context.  The only
  way for an NFA state p to have an empty context and a nonempty context
  is the case when closure falls off end of rule without a call stack
  and re-enters the rule with a context.  This resolves the issue I
  discussed with Sriram Srinivasan Feb 28, 2005 about not terminating
  fast enough upon nondeterminism.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="suffix(org.antlr.analysis.NFAContext)"><!-- --></A><H3>
suffix</H3>
<PRE>
protected boolean <B>suffix</B>(<A HREF="../../../org/antlr/analysis/NFAContext.html" title="class in org.antlr.analysis">NFAContext</A>&nbsp;other)</PRE>
<DL>
<DD>[$] suffix any context
  [21 $] suffix [21 12 $]
  [21 12 $] suffix [21 $]
  [21 18 $] suffix [21 18 12 9 $]
  [21 18 12 9 $] suffix [21 18 $]
  [21 12 $] not suffix [21 9 $]

  Example "[21 $] suffix [21 12 $]" means: rule r invoked current rule
  from state 21.  Rule s invoked rule r from state 12 which then invoked
  current rule also via state 21.  While the context prior to state 21
  is different, the fact that both contexts emanate from state 21 implies
  that they are now going to track perfectly together.  Once they
  converged on state 21, there is no way they can separate.  In other
  words, the prior stack state is not consulted when computing where to
  go in the closure operation.  ?$ and ??$ are considered the same stack.
  If ? is popped off then $ and ?$ remain; they are now an empty and
  nonempty context comparison.  So, if one stack is a suffix of
  another, then it will still degenerate to the simple empty stack
  comparison case.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="recursionDepthEmanatingFromState(int)"><!-- --></A><H3>
recursionDepthEmanatingFromState</H3>
<PRE>
public int <B>recursionDepthEmanatingFromState</B>(int&nbsp;state)</PRE>
<DL>
<DD>Given an NFA state number, how many times has the NFA-to-DFA
  conversion pushed that state on the stack?  In other words,
  the NFA state must be a rule invocation state and this method
  tells you how many times you've been to this state.  If none,
  then you have not called the target rule from this state before
  (though another NFA state could have called that target rule).
  If n=1, then you've been to this state before during this
  DFA construction and are going to invoke that rule again.

  Note that many NFA states can invoke rule r, but we ignore recursion
  unless you hit the same rule invocation state again.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode()"><!-- --></A><H3>
hashCode</H3>
<PRE>
public int <B>hashCode</B>()</PRE>
<DL>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>hashCode</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isEmpty()"><!-- --></A><H3>
isEmpty</H3>
<PRE>
public boolean <B>isEmpty</B>()</PRE>
<DL>
<DD>A context is empty if there is no parent; meaning nobody pushed
  anything on the call stack.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public java.lang.String <B>toString</B>()</PRE>
<DL>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>toString</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/antlr/analysis/NFAConfiguration.html" title="class in org.antlr.analysis"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../org/antlr/analysis/NFAConversionThread.html" title="class in org.antlr.analysis"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/antlr/analysis/NFAContext.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="NFAContext.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
