<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_16) on Wed Oct 14 09:00:04 EDT 2009 -->
<TITLE>
DFAState
</TITLE>

<META NAME="date" CONTENT="2009-10-14">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="DFAState";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/antlr/analysis/DFAOptimizer.html" title="class in org.antlr.analysis"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../org/antlr/analysis/Label.html" title="class in org.antlr.analysis"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/antlr/analysis/DFAState.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="DFAState.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.antlr.analysis</FONT>
<BR>
Class DFAState</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><A HREF="../../../org/antlr/analysis/State.html" title="class in org.antlr.analysis">org.antlr.analysis.State</A>
      <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>org.antlr.analysis.DFAState</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>DFAState</B><DT>extends <A HREF="../../../org/antlr/analysis/State.html" title="class in org.antlr.analysis">State</A></DL>
</PRE>

<P>
A DFA state represents a set of possible NFA configurations.
  As Aho, Sethi, Ullman p. 117 says "The DFA uses its state
  to keep track of all possible states the NFA can be in after
  reading each input symbol.  That is to say, after reading
  input a1a2..an, the DFA is in a state that represents the
  subset T of the states of the NFA that are reachable from the
  NFA's start state along some path labeled a1a2..an."
  In conventional NFA->DFA conversion, therefore, the subset T
  would be a bitset representing the set of states the
  NFA could be in.  We need to track the alt predicted by each
  state as well, however.  More importantly, we need to maintain
  a stack of states, tracking the closure operations as they
  jump from rule to rule, emulating rule invocations (method calls).
  Recall that NFAs do not normally have a stack like a pushdown-machine
  so I have to add one to simulate the proper lookahead sequences for
  the underlying LL grammar from which the NFA was derived.

  I use a list of NFAConfiguration objects.  An NFAConfiguration
  is both a state (ala normal conversion) and an NFAContext describing
  the chain of rules (if any) followed to arrive at that state.  There
  is also the semantic context, which is the "set" of predicates found
  on the path to this configuration.

  A DFA state may have multiple references to a particular state,
  but with different NFAContexts (with same or different alts)
  meaning that state was reached via a different set of rule invocations.
<P>

<P>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#abortedDueToMultipleRecursiveAlts">abortedDueToMultipleRecursiveAlts</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If we detect recursion on more than one alt, decision is non-LL(*),
  but try to isolate it to only those states whose closure operations
  detect recursion.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#abortedDueToRecursionOverflow">abortedDueToRecursionOverflow</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If a closure operation finds that we tried to invoke the same
  rule too many times (stack would grow beyond a threshold), it
  marks the state has aborted and notifies the DecisionProbe.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#acceptStateReachable">acceptStateReachable</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The NFA->DFA algorithm may terminate leaving some states
  without a path to an accept state, implying that upon certain
  input, the decision is not deterministic--no decision about
  predicting a unique alternative can be made.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#atLeastOneConfigurationHasAPredicate">atLeastOneConfigurationHasAPredicate</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#cachedHashCode">cachedHashCode</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Build up the hash code for this state as NFA configurations
  are added as it's monotonically increasing list of configurations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#cachedUniquelyPredicatedAlt">cachedUniquelyPredicatedAlt</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Set&lt;<A HREF="../../../org/antlr/analysis/NFAConfiguration.html" title="class in org.antlr.analysis">NFAConfiguration</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#closureBusy">closureBusy</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Used to prevent the closure operation from looping to itself and
  hence looping forever.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List&lt;<A HREF="../../../org/antlr/analysis/NFAConfiguration.html" title="class in org.antlr.analysis">NFAConfiguration</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#configurationsWithLabeledEdges">configurationsWithLabeledEdges</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#dfa">dfa</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;We are part of what DFA?  Use this ref to get access to the
  context trees for an alt.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#INITIAL_NUM_TRANSITIONS">INITIAL_NUM_TRANSITIONS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#k">k</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When doing an acyclic DFA, this is the number of lookahead symbols
  consumed to reach this state.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#minAltInConfigurations">minAltInConfigurations</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/misc/OrderedHashSet.html" title="class in org.antlr.misc">OrderedHashSet</A>&lt;<A HREF="../../../org/antlr/analysis/NFAConfiguration.html" title="class in org.antlr.analysis">NFAConfiguration</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#nfaConfigurations">nfaConfigurations</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The set of NFA configurations (state,alt,context) for this DFA state</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#PREDICTED_ALT_UNSET">PREDICTED_ALT_UNSET</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../org/antlr/misc/OrderedHashSet.html" title="class in org.antlr.misc">OrderedHashSet</A>&lt;<A HREF="../../../org/antlr/analysis/Label.html" title="class in org.antlr.analysis">Label</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#reachableLabels">reachableLabels</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;As this state is constructed (i.e., as NFA states are added), we
  can easily check for non-epsilon transitions because the only
  transition that could be a valid label is transition(0).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#resolvedWithPredicates">resolvedWithPredicates</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rather than recheck every NFA configuration in a DFA state (after
  resolving) in findNewDFAStatesAndAddDFATransitions just check
  this boolean.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.List&lt;<A HREF="../../../org/antlr/analysis/Transition.html" title="class in org.antlr.analysis">Transition</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#transitions">transitions</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Track the transitions emanating from this DFA state.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_org.antlr.analysis.State"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Fields inherited from class org.antlr.analysis.<A HREF="../../../org/antlr/analysis/State.html" title="class in org.antlr.analysis">State</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../org/antlr/analysis/State.html#acceptState">acceptState</A>, <A HREF="../../../org/antlr/analysis/State.html#INVALID_STATE_NUMBER">INVALID_STATE_NUMBER</A>, <A HREF="../../../org/antlr/analysis/State.html#stateNumber">stateNumber</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#DFAState(org.antlr.analysis.DFA)">DFAState</A></B>(<A HREF="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</A>&nbsp;dfa)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/analysis/NFAConfiguration.html" title="class in org.antlr.analysis">NFAConfiguration</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#addNFAConfiguration(org.antlr.analysis.NFAState, int, org.antlr.analysis.NFAContext, org.antlr.analysis.SemanticContext)">addNFAConfiguration</A></B>(<A HREF="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</A>&nbsp;state,
                    int&nbsp;alt,
                    <A HREF="../../../org/antlr/analysis/NFAContext.html" title="class in org.antlr.analysis">NFAContext</A>&nbsp;context,
                    <A HREF="../../../org/antlr/analysis/SemanticContext.html" title="class in org.antlr.analysis">SemanticContext</A>&nbsp;semanticContext)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#addNFAConfiguration(org.antlr.analysis.NFAState, org.antlr.analysis.NFAConfiguration)">addNFAConfiguration</A></B>(<A HREF="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</A>&nbsp;state,
                    <A HREF="../../../org/antlr/analysis/NFAConfiguration.html" title="class in org.antlr.analysis">NFAConfiguration</A>&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add an NFA configuration to this DFA node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#addReachableLabel(org.antlr.analysis.Label)">addReachableLabel</A></B>(<A HREF="../../../org/antlr/analysis/Label.html" title="class in org.antlr.analysis">Label</A>&nbsp;label)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add label uniquely and disjointly; intersection with
  another set or int/char forces breaking up the set(s).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#addTransition(org.antlr.analysis.DFAState, org.antlr.analysis.Label)">addTransition</A></B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;target,
              <A HREF="../../../org/antlr/analysis/Label.html" title="class in org.antlr.analysis">Label</A>&nbsp;label)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add a transition from this state to target with label.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#addTransition(org.antlr.analysis.Transition)">addTransition</A></B>(<A HREF="../../../org/antlr/analysis/Transition.html" title="class in org.antlr.analysis">Transition</A>&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#equals(java.lang.Object)">equals</A></B>(java.lang.Object&nbsp;o)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Two DFAStates are equal if their NFA configuration sets are the
  same.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#getAcceptStateReachable()">getAcceptStateReachable</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Is an accept state reachable from this state?</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#getAltSet()">getAltSet</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the set of all alts mentioned by all NFA configurations in this
  DFA state.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Set&lt;java.lang.Integer&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#getConflictingAlts()">getConflictingAlts</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Walk each NFA configuration in this DFA state looking for a conflict
  where (s|i|ctx) and (s|j|ctx) exist, indicating that state s with
  context conflicting ctx predicts alts i and j.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#getDisabledAlternatives()">getDisabledAlternatives</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When more than one alternative can match the same input, the first
  alternative is chosen to resolve the conflict.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/analysis/SemanticContext.html" title="class in org.antlr.analysis">SemanticContext</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#getGatedPredicatesInNFAConfigurations()">getGatedPredicatesInNFAConfigurations</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For gated productions, we need an OR'd list of all predicates for the
  target of an edge so we can gate the edge based upon the predicates
  associated with taking that path (if any).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#getGatedSyntacticPredicatesInNFAConfigurations()">getGatedSyntacticPredicatesInNFAConfigurations</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#getLookaheadDepth()">getLookaheadDepth</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Set</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#getNonDeterministicAlts()">getNonDeterministicAlts</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#getNumberOfTransitions()">getNumberOfTransitions</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/misc/OrderedHashSet.html" title="class in org.antlr.misc">OrderedHashSet</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#getReachableLabels()">getReachableLabels</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/analysis/Transition.html" title="class in org.antlr.analysis">Transition</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#getTransition(int)">getTransition</A></B>(int&nbsp;trans)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#getUniqueAlt()">getUniqueAlt</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the uniquely mentioned alt from the NFA configurations;
  Ignore the resolved bit etc...</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#getUniquelyPredictedAlt()">getUniquelyPredictedAlt</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Walk each configuration and if they are all the same alt, return
  that alt else return NFA.INVALID_ALT_NUMBER.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#hashCode()">hashCode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A decent hash for a DFA state is the sum of the NFA state/alt pairs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#isResolvedWithPredicates()">isResolvedWithPredicates</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#removeTransition(int)">removeTransition</A></B>(int&nbsp;trans)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#reset()">reset</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#setAcceptStateReachable(int)">setAcceptStateReachable</A></B>(int&nbsp;acceptStateReachable)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#setLookaheadDepth(int)">setLookaheadDepth</A></B>(int&nbsp;k)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#setNFAConfigurations(org.antlr.misc.OrderedHashSet)">setNFAConfigurations</A></B>(<A HREF="../../../org/antlr/misc/OrderedHashSet.html" title="class in org.antlr.misc">OrderedHashSet</A>&lt;<A HREF="../../../org/antlr/analysis/NFAConfiguration.html" title="class in org.antlr.analysis">NFAConfiguration</A>&gt;&nbsp;configs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Print all NFA states plus what alts they predict</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/analysis/Transition.html" title="class in org.antlr.analysis">Transition</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DFAState.html#transition(int)">transition</A></B>(int&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_org.antlr.analysis.State"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class org.antlr.analysis.<A HREF="../../../org/antlr/analysis/State.html" title="class in org.antlr.analysis">State</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../org/antlr/analysis/State.html#isAcceptState()">isAcceptState</A>, <A HREF="../../../org/antlr/analysis/State.html#setAcceptState(boolean)">setAcceptState</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, finalize, getClass, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="INITIAL_NUM_TRANSITIONS"><!-- --></A><H3>
INITIAL_NUM_TRANSITIONS</H3>
<PRE>
public static final int <B>INITIAL_NUM_TRANSITIONS</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.antlr.analysis.DFAState.INITIAL_NUM_TRANSITIONS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="PREDICTED_ALT_UNSET"><!-- --></A><H3>
PREDICTED_ALT_UNSET</H3>
<PRE>
public static final int <B>PREDICTED_ALT_UNSET</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.antlr.analysis.DFAState.PREDICTED_ALT_UNSET">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="dfa"><!-- --></A><H3>
dfa</H3>
<PRE>
public <A HREF="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</A> <B>dfa</B></PRE>
<DL>
<DD>We are part of what DFA?  Use this ref to get access to the
  context trees for an alt.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="transitions"><!-- --></A><H3>
transitions</H3>
<PRE>
protected java.util.List&lt;<A HREF="../../../org/antlr/analysis/Transition.html" title="class in org.antlr.analysis">Transition</A>&gt; <B>transitions</B></PRE>
<DL>
<DD>Track the transitions emanating from this DFA state.  The List
  elements are Transition objects.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="k"><!-- --></A><H3>
k</H3>
<PRE>
protected int <B>k</B></PRE>
<DL>
<DD>When doing an acyclic DFA, this is the number of lookahead symbols
  consumed to reach this state.  This value may be nonzero for most
  dfa states, but it is only a valid value if the user has specified
  a max fixed lookahead.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="acceptStateReachable"><!-- --></A><H3>
acceptStateReachable</H3>
<PRE>
protected int <B>acceptStateReachable</B></PRE>
<DL>
<DD>The NFA->DFA algorithm may terminate leaving some states
  without a path to an accept state, implying that upon certain
  input, the decision is not deterministic--no decision about
  predicting a unique alternative can be made.  Recall that an
  accept state is one in which a unique alternative is predicted.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="resolvedWithPredicates"><!-- --></A><H3>
resolvedWithPredicates</H3>
<PRE>
protected boolean <B>resolvedWithPredicates</B></PRE>
<DL>
<DD>Rather than recheck every NFA configuration in a DFA state (after
  resolving) in findNewDFAStatesAndAddDFATransitions just check
  this boolean.  Saves a linear walk perhaps DFA state creation.
  Every little bit helps.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="abortedDueToRecursionOverflow"><!-- --></A><H3>
abortedDueToRecursionOverflow</H3>
<PRE>
public boolean <B>abortedDueToRecursionOverflow</B></PRE>
<DL>
<DD>If a closure operation finds that we tried to invoke the same
  rule too many times (stack would grow beyond a threshold), it
  marks the state has aborted and notifies the DecisionProbe.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="abortedDueToMultipleRecursiveAlts"><!-- --></A><H3>
abortedDueToMultipleRecursiveAlts</H3>
<PRE>
protected boolean <B>abortedDueToMultipleRecursiveAlts</B></PRE>
<DL>
<DD>If we detect recursion on more than one alt, decision is non-LL(*),
  but try to isolate it to only those states whose closure operations
  detect recursion.  There may be other alts that are cool:

  a : recur '.'
    | recur ';'
    | X Y  // LL(2) decision; don't abort and use k=1 plus backtracking
    | X Z
    ;

  12/13/2007: Actually this has caused problems.  If k=*, must terminate
  and throw out entire DFA; retry with k=1.  Since recursive, do not
  attempt more closure ops as it may take forever.  Exception thrown
  now and we simply report the problem.  If synpreds exist, I'll retry
  with k=1.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="cachedHashCode"><!-- --></A><H3>
cachedHashCode</H3>
<PRE>
protected int <B>cachedHashCode</B></PRE>
<DL>
<DD>Build up the hash code for this state as NFA configurations
  are added as it's monotonically increasing list of configurations.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="cachedUniquelyPredicatedAlt"><!-- --></A><H3>
cachedUniquelyPredicatedAlt</H3>
<PRE>
protected int <B>cachedUniquelyPredicatedAlt</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="minAltInConfigurations"><!-- --></A><H3>
minAltInConfigurations</H3>
<PRE>
public int <B>minAltInConfigurations</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="atLeastOneConfigurationHasAPredicate"><!-- --></A><H3>
atLeastOneConfigurationHasAPredicate</H3>
<PRE>
public boolean <B>atLeastOneConfigurationHasAPredicate</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="nfaConfigurations"><!-- --></A><H3>
nfaConfigurations</H3>
<PRE>
public <A HREF="../../../org/antlr/misc/OrderedHashSet.html" title="class in org.antlr.misc">OrderedHashSet</A>&lt;<A HREF="../../../org/antlr/analysis/NFAConfiguration.html" title="class in org.antlr.analysis">NFAConfiguration</A>&gt; <B>nfaConfigurations</B></PRE>
<DL>
<DD>The set of NFA configurations (state,alt,context) for this DFA state
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="configurationsWithLabeledEdges"><!-- --></A><H3>
configurationsWithLabeledEdges</H3>
<PRE>
public java.util.List&lt;<A HREF="../../../org/antlr/analysis/NFAConfiguration.html" title="class in org.antlr.analysis">NFAConfiguration</A>&gt; <B>configurationsWithLabeledEdges</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="closureBusy"><!-- --></A><H3>
closureBusy</H3>
<PRE>
protected java.util.Set&lt;<A HREF="../../../org/antlr/analysis/NFAConfiguration.html" title="class in org.antlr.analysis">NFAConfiguration</A>&gt; <B>closureBusy</B></PRE>
<DL>
<DD>Used to prevent the closure operation from looping to itself and
  hence looping forever.  Sensitive to the NFA state, the alt, and
  the stack context.  This just the nfa config set because we want to
  prevent closures only on states contributed by closure not reach
  operations.

  Two configurations identical including semantic context are
  considered the same closure computation.  @see NFAToDFAConverter.closureBusy().
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="reachableLabels"><!-- --></A><H3>
reachableLabels</H3>
<PRE>
protected <A HREF="../../../org/antlr/misc/OrderedHashSet.html" title="class in org.antlr.misc">OrderedHashSet</A>&lt;<A HREF="../../../org/antlr/analysis/Label.html" title="class in org.antlr.analysis">Label</A>&gt; <B>reachableLabels</B></PRE>
<DL>
<DD>As this state is constructed (i.e., as NFA states are added), we
  can easily check for non-epsilon transitions because the only
  transition that could be a valid label is transition(0).  When we
  process this node eventually, we'll have to walk all states looking
  for all possible transitions.  That is of the order: size(label space)
  times size(nfa states), which can be pretty damn big.  It's better
  to simply track possible labels.
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="DFAState(org.antlr.analysis.DFA)"><!-- --></A><H3>
DFAState</H3>
<PRE>
public <B>DFAState</B>(<A HREF="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</A>&nbsp;dfa)</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="reset()"><!-- --></A><H3>
reset</H3>
<PRE>
public void <B>reset</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="transition(int)"><!-- --></A><H3>
transition</H3>
<PRE>
public <A HREF="../../../org/antlr/analysis/Transition.html" title="class in org.antlr.analysis">Transition</A> <B>transition</B>(int&nbsp;i)</PRE>
<DL>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../org/antlr/analysis/State.html#transition(int)">transition</A></CODE> in class <CODE><A HREF="../../../org/antlr/analysis/State.html" title="class in org.antlr.analysis">State</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getNumberOfTransitions()"><!-- --></A><H3>
getNumberOfTransitions</H3>
<PRE>
public int <B>getNumberOfTransitions</B>()</PRE>
<DL>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../org/antlr/analysis/State.html#getNumberOfTransitions()">getNumberOfTransitions</A></CODE> in class <CODE><A HREF="../../../org/antlr/analysis/State.html" title="class in org.antlr.analysis">State</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="addTransition(org.antlr.analysis.Transition)"><!-- --></A><H3>
addTransition</H3>
<PRE>
public void <B>addTransition</B>(<A HREF="../../../org/antlr/analysis/Transition.html" title="class in org.antlr.analysis">Transition</A>&nbsp;t)</PRE>
<DL>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../org/antlr/analysis/State.html#addTransition(org.antlr.analysis.Transition)">addTransition</A></CODE> in class <CODE><A HREF="../../../org/antlr/analysis/State.html" title="class in org.antlr.analysis">State</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="addTransition(org.antlr.analysis.DFAState, org.antlr.analysis.Label)"><!-- --></A><H3>
addTransition</H3>
<PRE>
public int <B>addTransition</B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;target,
                         <A HREF="../../../org/antlr/analysis/Label.html" title="class in org.antlr.analysis">Label</A>&nbsp;label)</PRE>
<DL>
<DD>Add a transition from this state to target with label.  Return
  the transition number from 0..n-1.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getTransition(int)"><!-- --></A><H3>
getTransition</H3>
<PRE>
public <A HREF="../../../org/antlr/analysis/Transition.html" title="class in org.antlr.analysis">Transition</A> <B>getTransition</B>(int&nbsp;trans)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="removeTransition(int)"><!-- --></A><H3>
removeTransition</H3>
<PRE>
public void <B>removeTransition</B>(int&nbsp;trans)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="addNFAConfiguration(org.antlr.analysis.NFAState, org.antlr.analysis.NFAConfiguration)"><!-- --></A><H3>
addNFAConfiguration</H3>
<PRE>
public void <B>addNFAConfiguration</B>(<A HREF="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</A>&nbsp;state,
                                <A HREF="../../../org/antlr/analysis/NFAConfiguration.html" title="class in org.antlr.analysis">NFAConfiguration</A>&nbsp;c)</PRE>
<DL>
<DD>Add an NFA configuration to this DFA node.  Add uniquely
  an NFA state/alt/syntactic&semantic context (chain of invoking state(s)
  and semantic predicate contexts).

  I don't see how there could be two configurations with same
  state|alt|synCtx and different semantic contexts because the
  semantic contexts are computed along the path to a particular state
  so those two configurations would have to have the same predicate.
  Nonetheless, the addition of configurations is unique on all
  configuration info.  I guess I'm saying that syntactic context
  implies semantic context as the latter is computed according to the
  former.

  As we add configurations to this DFA state, track the set of all possible
  transition labels so we can simply walk it later rather than doing a
  loop over all possible labels in the NFA.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="addNFAConfiguration(org.antlr.analysis.NFAState, int, org.antlr.analysis.NFAContext, org.antlr.analysis.SemanticContext)"><!-- --></A><H3>
addNFAConfiguration</H3>
<PRE>
public <A HREF="../../../org/antlr/analysis/NFAConfiguration.html" title="class in org.antlr.analysis">NFAConfiguration</A> <B>addNFAConfiguration</B>(<A HREF="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</A>&nbsp;state,
                                            int&nbsp;alt,
                                            <A HREF="../../../org/antlr/analysis/NFAContext.html" title="class in org.antlr.analysis">NFAContext</A>&nbsp;context,
                                            <A HREF="../../../org/antlr/analysis/SemanticContext.html" title="class in org.antlr.analysis">SemanticContext</A>&nbsp;semanticContext)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="addReachableLabel(org.antlr.analysis.Label)"><!-- --></A><H3>
addReachableLabel</H3>
<PRE>
protected void <B>addReachableLabel</B>(<A HREF="../../../org/antlr/analysis/Label.html" title="class in org.antlr.analysis">Label</A>&nbsp;label)</PRE>
<DL>
<DD>Add label uniquely and disjointly; intersection with
  another set or int/char forces breaking up the set(s).

  Example, if reachable list of labels is [a..z, {k,9}, 0..9],
  the disjoint list will be [{a..j,l..z}, k, 9, 0..8].

  As we add NFA configurations to a DFA state, we might as well track
  the set of all possible transition labels to make the DFA conversion
  more efficient.  W/o the reachable labels, we'd need to check the
  whole vocabulary space (could be 0..￿)!  The problem is that
  labels can be sets, which may overlap with int labels or other sets.
  As we need a deterministic set of transitions from any
  state in the DFA, we must make the reachable labels set disjoint.
  This operation amounts to finding the character classes for this
  DFA state whereas with tools like flex, that need to generate a
  homogeneous DFA, must compute char classes across all states.
  We are going to generate DFAs with heterogeneous states so we
  only care that the set of transitions out of a single state are
  unique. :)

  The idea for adding a new set, t, is to look for overlap with the
  elements of existing list s.  Upon overlap, replace
  existing set s[i] with two new disjoint sets, s[i]-t and s[i]&t.
  (if s[i]-t is nil, don't add).  The remainder is t-s[i], which is
  what you want to add to the set minus what was already there.  The
  remainder must then be compared against the i+1..n elements in s
  looking for another collision.  Each collision results in a smaller
  and smaller remainder.  Stop when you run out of s elements or
  remainder goes to nil.  If remainder is non nil when you run out of
  s elements, then add remainder to the end.

  Single element labels are treated as sets to make the code uniform.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getReachableLabels()"><!-- --></A><H3>
getReachableLabels</H3>
<PRE>
public <A HREF="../../../org/antlr/misc/OrderedHashSet.html" title="class in org.antlr.misc">OrderedHashSet</A> <B>getReachableLabels</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setNFAConfigurations(org.antlr.misc.OrderedHashSet)"><!-- --></A><H3>
setNFAConfigurations</H3>
<PRE>
public void <B>setNFAConfigurations</B>(<A HREF="../../../org/antlr/misc/OrderedHashSet.html" title="class in org.antlr.misc">OrderedHashSet</A>&lt;<A HREF="../../../org/antlr/analysis/NFAConfiguration.html" title="class in org.antlr.analysis">NFAConfiguration</A>&gt;&nbsp;configs)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode()"><!-- --></A><H3>
hashCode</H3>
<PRE>
public int <B>hashCode</B>()</PRE>
<DL>
<DD>A decent hash for a DFA state is the sum of the NFA state/alt pairs.
  This is used when we add DFAState objects to the DFA.states Map and
  when we compare DFA states.  Computed in addNFAConfiguration()
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>hashCode</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="equals(java.lang.Object)"><!-- --></A><H3>
equals</H3>
<PRE>
public boolean <B>equals</B>(java.lang.Object&nbsp;o)</PRE>
<DL>
<DD>Two DFAStates are equal if their NFA configuration sets are the
  same. This method is used to see if a DFA state already exists.

  Because the number of alternatives and number of NFA configurations are
  finite, there is a finite number of DFA states that can be processed.
  This is necessary to show that the algorithm terminates.

  Cannot test the DFA state numbers here because in DFA.addState we need
  to know if any other state exists that has this exact set of NFA
  configurations.  The DFAState state number is irrelevant.
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>equals</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getUniquelyPredictedAlt()"><!-- --></A><H3>
getUniquelyPredictedAlt</H3>
<PRE>
public int <B>getUniquelyPredictedAlt</B>()</PRE>
<DL>
<DD>Walk each configuration and if they are all the same alt, return
  that alt else return NFA.INVALID_ALT_NUMBER.  Ignore resolved
  configurations, but don't ignore resolveWithPredicate configs
  because this state should not be an accept state.  We need to add
  this to the work list and then have semantic predicate edges
  emanating from it.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getUniqueAlt()"><!-- --></A><H3>
getUniqueAlt</H3>
<PRE>
public int <B>getUniqueAlt</B>()</PRE>
<DL>
<DD>Return the uniquely mentioned alt from the NFA configurations;
  Ignore the resolved bit etc...  Return INVALID_ALT_NUMBER
  if there is more than one alt mentioned.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDisabledAlternatives()"><!-- --></A><H3>
getDisabledAlternatives</H3>
<PRE>
public java.util.Set <B>getDisabledAlternatives</B>()</PRE>
<DL>
<DD>When more than one alternative can match the same input, the first
  alternative is chosen to resolve the conflict.  The other alts
  are "turned off" by setting the "resolved" flag in the NFA
  configurations.  Return the set of disabled alternatives.  For

  a : A | A | A ;

  this method returns {2,3} as disabled.  This does not mean that
  the alternative is totally unreachable, it just means that for this
  DFA state, that alt is disabled.  There may be other accept states
  for that alt.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getNonDeterministicAlts()"><!-- --></A><H3>
getNonDeterministicAlts</H3>
<PRE>
protected java.util.Set <B>getNonDeterministicAlts</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getConflictingAlts()"><!-- --></A><H3>
getConflictingAlts</H3>
<PRE>
protected java.util.Set&lt;java.lang.Integer&gt; <B>getConflictingAlts</B>()</PRE>
<DL>
<DD>Walk each NFA configuration in this DFA state looking for a conflict
  where (s|i|ctx) and (s|j|ctx) exist, indicating that state s with
  context conflicting ctx predicts alts i and j.  Return an Integer set
  of the alternative numbers that conflict.  Two contexts conflict if
  they are equal or one is a stack suffix of the other or one is
  the empty context.

  Use a hash table to record the lists of configs for each state
  as they are encountered.  We need only consider states for which
  there is more than one configuration.  The configurations' predicted
  alt must be different or must have different contexts to avoid a
  conflict.

  Don't report conflicts for DFA states that have conflicting Tokens
  rule NFA states; they will be resolved in favor of the first rule.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getAltSet()"><!-- --></A><H3>
getAltSet</H3>
<PRE>
public java.util.Set <B>getAltSet</B>()</PRE>
<DL>
<DD>Get the set of all alts mentioned by all NFA configurations in this
  DFA state.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getGatedSyntacticPredicatesInNFAConfigurations()"><!-- --></A><H3>
getGatedSyntacticPredicatesInNFAConfigurations</H3>
<PRE>
public java.util.Set <B>getGatedSyntacticPredicatesInNFAConfigurations</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getGatedPredicatesInNFAConfigurations()"><!-- --></A><H3>
getGatedPredicatesInNFAConfigurations</H3>
<PRE>
public <A HREF="../../../org/antlr/analysis/SemanticContext.html" title="class in org.antlr.analysis">SemanticContext</A> <B>getGatedPredicatesInNFAConfigurations</B>()</PRE>
<DL>
<DD>For gated productions, we need an OR'd list of all predicates for the
  target of an edge so we can gate the edge based upon the predicates
  associated with taking that path (if any).

  For syntactic predicates, we only want to generate predicate
  evaluations as it transitions to an accept state; waste to
  do it earlier.  So, only add gated preds derived from manually-
  specified syntactic predicates if this is an accept state.

  Also, since configurations w/o gated predicates are like true
  gated predicates, finding a configuration whose alt has no gated
  predicate implies we should evaluate the predicate to true. This
  means the whole edge has to be ungated. Consider:

         X : ('a' | {p}?=> 'a')
           | 'a' 'b'
           ;

  Here, you 'a' gets you from s0 to s1 but you can't test p because
  plain 'a' is ok.  It's also ok for starting alt 2.  Hence, you can't
  test p.  Even on the edge going to accept state for alt 1 of X, you
  can't test p.  You can get to the same place with and w/o the context.
  Therefore, it is never ok to test p in this situation. 

  TODO: cache this as it's called a lot; or at least set bit if >1 present in state
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getAcceptStateReachable()"><!-- --></A><H3>
getAcceptStateReachable</H3>
<PRE>
public int <B>getAcceptStateReachable</B>()</PRE>
<DL>
<DD>Is an accept state reachable from this state?
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setAcceptStateReachable(int)"><!-- --></A><H3>
setAcceptStateReachable</H3>
<PRE>
public void <B>setAcceptStateReachable</B>(int&nbsp;acceptStateReachable)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isResolvedWithPredicates()"><!-- --></A><H3>
isResolvedWithPredicates</H3>
<PRE>
public boolean <B>isResolvedWithPredicates</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public java.lang.String <B>toString</B>()</PRE>
<DL>
<DD>Print all NFA states plus what alts they predict
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>toString</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getLookaheadDepth()"><!-- --></A><H3>
getLookaheadDepth</H3>
<PRE>
public int <B>getLookaheadDepth</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setLookaheadDepth(int)"><!-- --></A><H3>
setLookaheadDepth</H3>
<PRE>
public void <B>setLookaheadDepth</B>(int&nbsp;k)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/antlr/analysis/DFAOptimizer.html" title="class in org.antlr.analysis"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../org/antlr/analysis/Label.html" title="class in org.antlr.analysis"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/antlr/analysis/DFAState.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="DFAState.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
