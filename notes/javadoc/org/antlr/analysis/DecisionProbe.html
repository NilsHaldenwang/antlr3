<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_16) on Wed Oct 14 09:00:04 EDT 2009 -->
<TITLE>
DecisionProbe
</TITLE>

<META NAME="date" CONTENT="2009-10-14">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="DecisionProbe";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/antlr/analysis/AnalysisTimeoutException.html" title="class in org.antlr.analysis"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/antlr/analysis/DecisionProbe.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="DecisionProbe.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.antlr.analysis</FONT>
<BR>
Class DecisionProbe</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>org.antlr.analysis.DecisionProbe</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>DecisionProbe</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
Collection of information about what is wrong with a decision as
  discovered while building the DFA predictor.

  The information is collected during NFA->DFA conversion and, while
  some of this is available elsewhere, it is nice to have it all tracked
  in one spot so a great error message can be easily had.  I also like
  the fact that this object tracks it all for later perusing to make an
  excellent error message instead of lots of imprecise on-the-fly warnings
  (during conversion).

  A decision normally only has one problem; e.g., some input sequence
  can be matched by multiple alternatives.  Unfortunately, some decisions
  such as

  a : ( A | B ) | ( A | B ) | A ;

  have multiple problems.  So in general, you should approach a decision
  as having multiple flaws each one uniquely identified by a DFAState.
  For example, statesWithSyntacticallyAmbiguousAltsSet tracks the set of
  all DFAStates where ANTLR has discovered a problem.  Recall that a decision
  is represented internall with a DFA comprised of multiple states, each of
  which could potentially have problems.

  Because of this, you need to iterate over this list of DFA states.  You'll
  note that most of the informational methods like
  getSampleNonDeterministicInputSequence() require a DFAState.  This state
  will be one of the iterated states from stateToSyntacticallyAmbiguousAltsSet.

  This class is not thread safe due to shared use of visited maps etc...
  Only one thread should really need to access one DecisionProbe anyway.
<P>

<P>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Set&lt;java.lang.Integer&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#altsWithProblem">altsWithProblem</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The overall list of alts within the decision that have at least one
  conflicting input sequence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Set&lt;<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#danglingStates">danglingStates</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The set of states w/o emanating edges and w/o resolving sem preds.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#dfa">dfa</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#nonLLStarDecision">nonLLStarDecision</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If decision with > 1 alt has recursion in > 1 alt, it's nonregular
  lookahead.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#REACHABLE_BUSY">REACHABLE_BUSY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#REACHABLE_NO">REACHABLE_NO</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#REACHABLE_YES">REACHABLE_YES</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Map&lt;java.lang.Integer,java.lang.Integer&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#stateReachable">stateReachable</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Used to find paths through syntactically ambiguous DFA.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Set&lt;<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#statesResolvedWithSemanticPredicatesSet">statesResolvedWithSemanticPredicatesSet</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Was a syntactic ambiguity resolved with predicates?  Any DFA
  state that predicts more than one alternative, must be resolved
  with predicates or it should be reported to the user.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Set&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#statesVisitedAtInputDepth">statesVisitedAtInputDepth</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Used while finding a path through an NFA whose edge labels match
  an input sequence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Set&lt;java.lang.Integer&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#statesVisitedDuringSampleSequence">statesVisitedDuringSampleSequence</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Set&lt;<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#statesWithSyntacticallyAmbiguousAltsSet">statesWithSyntacticallyAmbiguousAltsSet</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Track all DFA states with nondeterministic alternatives.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Map&lt;<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>,java.util.Map&lt;java.lang.Integer,<A HREF="../../../org/antlr/analysis/SemanticContext.html" title="class in org.antlr.analysis">SemanticContext</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#stateToAltSetWithSemanticPredicatesMap">stateToAltSetWithSemanticPredicatesMap</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Track the predicates for each alt per DFA state;
  more than one DFA state might have syntactically ambig alt prediction.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Map&lt;<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>,java.util.Map&lt;java.lang.Integer,java.util.Set&lt;antlr.Token&gt;&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#stateToIncompletelyCoveredAltsMap">stateToIncompletelyCoveredAltsMap</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tracks alts insufficiently covered.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../org/antlr/misc/MultiMap.html" title="class in org.antlr.misc">MultiMap</A>&lt;java.lang.Integer,<A HREF="../../../org/antlr/analysis/NFAConfiguration.html" title="class in org.antlr.analysis">NFAConfiguration</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#stateToRecursionOverflowConfigurationsMap">stateToRecursionOverflowConfigurationsMap</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Recursion is limited to a particular depth.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Map&lt;<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>,java.util.Set&lt;java.lang.Integer&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#stateToSyntacticallyAmbiguousTokensRuleAltsMap">stateToSyntacticallyAmbiguousTokensRuleAltsMap</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Track just like stateToSyntacticallyAmbiguousAltsMap, but only
  for nondeterminisms that arise in the Tokens rule such as keyword vs
  ID rule.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#timedOut">timedOut</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Did ANTLR have to terminate early on the analysis of this decision?</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#verbose">verbose</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#DecisionProbe(org.antlr.analysis.DFA)">DecisionProbe</A></B>(<A HREF="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</A>&nbsp;dfa)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#analysisOverflowed()">analysisOverflowed</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Took too long to analyze a DFA</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#analysisTimedOut()">analysisTimedOut</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Did the analysis complete it's work?</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#getDanglingStates()">getDanglingStates</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return set of states w/o emanating edges and w/o resolving sem preds.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#getDescription()">getDescription</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a string like "3:22: ( A {;} | B )" that describes this
  decision.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Set</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#getDFAPathStatesToTarget(org.antlr.analysis.DFAState)">getDFAPathStatesToTarget</A></B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;targetState)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#getDFAStatesWithSyntacticallyAmbiguousAlts()">getDFAStatesWithSyntacticallyAmbiguousAlts</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return all DFA states in this DFA that have NFA configurations that
  conflict.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#getDisabledAlternatives(org.antlr.analysis.DFAState)">getDisabledAlternatives</A></B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Which alts were specifically turned off to resolve nondeterminisms?
  This is different than the unreachable alts.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Map&lt;java.lang.Integer,java.util.Set&lt;antlr.Token&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#getIncompletelyCoveredAlts(org.antlr.analysis.DFAState)">getIncompletelyCoveredAlts</A></B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a list of alts whose predicate context was insufficient to
  resolve a nondeterminism for state d.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#getInputSequenceDisplay(java.util.List)">getInputSequenceDisplay</A></B>(java.util.List&nbsp;labels)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given List<Label>, return a String with a useful representation
  of the associated input string.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#getNFAPath(org.antlr.analysis.NFAState, int, java.util.List, java.util.List)">getNFAPath</A></B>(<A HREF="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</A>&nbsp;s,
           int&nbsp;labelIndex,
           java.util.List&nbsp;labels,
           java.util.List&nbsp;path)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given a sample input sequence, you usually would like to know the
  path taken through the NFA.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#getNFAPathStatesForAlt(int, int, java.util.List)">getNFAPathStatesForAlt</A></B>(int&nbsp;firstAlt,
                       int&nbsp;alt,
                       java.util.List&nbsp;labels)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given an alternative associated with a nondeterministic DFA state,
  find the path of NFA states associated with the labels sequence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#getNonDeterministicAlts()">getNonDeterministicAlts</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#getNonDeterministicAltsForState(org.antlr.analysis.DFAState)">getNonDeterministicAltsForState</A></B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;targetState)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the sorted list of alts that conflict within a single state.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#getNondeterministicStatesResolvedWithSemanticPredicate()">getNondeterministicStatesResolvedWithSemanticPredicate</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#getNumberOfStates()">getNumberOfStates</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;How many states does the DFA predictor have?</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#getSampleInputSequenceUsingStateSet(org.antlr.analysis.State, org.antlr.analysis.State, java.util.Set, java.util.List)">getSampleInputSequenceUsingStateSet</A></B>(<A HREF="../../../org/antlr/analysis/State.html" title="class in org.antlr.analysis">State</A>&nbsp;startState,
                                    <A HREF="../../../org/antlr/analysis/State.html" title="class in org.antlr.analysis">State</A>&nbsp;targetState,
                                    java.util.Set&nbsp;states,
                                    java.util.List&lt;<A HREF="../../../org/antlr/analysis/Label.html" title="class in org.antlr.analysis">Label</A>&gt;&nbsp;labels)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given a start state and a final state, find a list of edge labels
  between the two ignoring epsilon.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List&lt;<A HREF="../../../org/antlr/analysis/Label.html" title="class in org.antlr.analysis">Label</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#getSampleNonDeterministicInputSequence(org.antlr.analysis.DFAState)">getSampleNonDeterministicInputSequence</A></B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;targetState)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a List<Label> indicating an input sequence that can be matched
  from the start state of the DFA to the targetState (which is known
  to have a problem).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/analysis/SemanticContext.html" title="class in org.antlr.analysis">SemanticContext</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#getSemanticContextForAlt(org.antlr.analysis.DFAState, int)">getSemanticContextForAlt</A></B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d,
                         int&nbsp;alt)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Each state in the DFA represents a different input sequence for an
  alt of the decision.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#getStateLabelIndexKey(int, int)">getStateLabelIndexKey</A></B>(int&nbsp;s,
                      int&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#getTokenNameForTokensRuleAlt(int)">getTokenNameForTokensRuleAlt</A></B>(int&nbsp;alt)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;From an alt number associated with artificial Tokens rule, return
  the name of the token that is associated with that alt.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List&lt;java.lang.Integer&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#getUnreachableAlts()">getUnreachableAlts</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a list of all unreachable alternatives for this decision.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#hasPredicate()">hasPredicate</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;At least one alt refs a sem or syn pred</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#isCyclic()">isCyclic</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#isDeterministic()">isDeterministic</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If no states are dead-ends, no alts are unreachable, there are
  no nondeterminisms unresolved by syn preds, all is ok with decision.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#isNonLLStarDecision()">isNonLLStarDecision</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Found recursion in > 1 alt</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#isReduced()">isReduced</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#issueRecursionWarnings()">issueRecursionWarnings</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#issueWarnings()">issueWarnings</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#reachesState(org.antlr.analysis.DFAState, org.antlr.analysis.DFAState, java.util.Set)">reachesState</A></B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;startState,
             <A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;targetState,
             java.util.Set&nbsp;states)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given a start state and a target state, return true if start can reach
  target state.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#removeRecursiveOverflowState(org.antlr.analysis.DFAState)">removeRecursiveOverflowState</A></B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If a recursion overflow is resolve with predicates, then we need
  to shut off the warning that would be generated.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#reportAltPredicateContext(org.antlr.analysis.DFAState, java.util.Map)">reportAltPredicateContext</A></B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d,
                          java.util.Map&nbsp;altPredicateContext)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Report the list of predicates found for each alternative; copy
  the list because this set gets altered later by the method
  tryToResolveWithSemanticPredicates() while flagging NFA configurations
  in d as resolved.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#reportAnalysisTimeout()">reportAnalysisTimeout</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#reportDanglingState(org.antlr.analysis.DFAState)">reportDanglingState</A></B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Report the fact that DFA state d is not a state resolved with
  predicates and yet it has no emanating edges.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#reportIncompletelyCoveredAlts(org.antlr.analysis.DFAState, java.util.Map)">reportIncompletelyCoveredAlts</A></B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d,
                              java.util.Map&lt;java.lang.Integer,java.util.Set&lt;antlr.Token&gt;&gt;&nbsp;altToLocationsReachableWithoutPredicate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#reportLexerRuleNondeterminism(org.antlr.analysis.DFAState, java.util.Set)">reportLexerRuleNondeterminism</A></B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d,
                              java.util.Set&lt;java.lang.Integer&gt;&nbsp;nondeterministicAlts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Currently the analysis reports issues between token definitions, but
  we don't print out warnings in favor of just picking the first token
  definition found in the grammar ala lex/flex.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#reportNondeterminism(org.antlr.analysis.DFAState, java.util.Set)">reportNondeterminism</A></B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d,
                     java.util.Set&lt;java.lang.Integer&gt;&nbsp;nondeterministicAlts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#reportNondeterminismResolvedWithSemanticPredicate(org.antlr.analysis.DFAState)">reportNondeterminismResolvedWithSemanticPredicate</A></B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#reportNonLLStarDecision(org.antlr.analysis.DFA)">reportNonLLStarDecision</A></B>(<A HREF="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</A>&nbsp;dfa)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Report that at least 2 alts have recursive constructs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#reportRecursionOverflow(org.antlr.analysis.DFAState, org.antlr.analysis.NFAConfiguration)">reportRecursionOverflow</A></B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d,
                        <A HREF="../../../org/antlr/analysis/NFAConfiguration.html" title="class in org.antlr.analysis">NFAConfiguration</A>&nbsp;recursionNFAConfiguration)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#reset()">reset</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/DecisionProbe.html#stripWildCardAlts(java.util.Set)">stripWildCardAlts</A></B>(java.util.Set&nbsp;disabledAlts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the last disabled alt number and check in the grammar to see
  if that alt is a simple wildcard.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="dfa"><!-- --></A><H3>
dfa</H3>
<PRE>
public <A HREF="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</A> <B>dfa</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="statesWithSyntacticallyAmbiguousAltsSet"><!-- --></A><H3>
statesWithSyntacticallyAmbiguousAltsSet</H3>
<PRE>
protected java.util.Set&lt;<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&gt; <B>statesWithSyntacticallyAmbiguousAltsSet</B></PRE>
<DL>
<DD>Track all DFA states with nondeterministic alternatives.
  By reaching the same DFA state, a path through the NFA for some input
  is able to reach the same NFA state by starting at more than one
  alternative's left edge.  Though, later, we may find that predicates
  resolve the issue, but track info anyway.
  Note that from the DFA state, you can ask for
  which alts are nondeterministic.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="stateToSyntacticallyAmbiguousTokensRuleAltsMap"><!-- --></A><H3>
stateToSyntacticallyAmbiguousTokensRuleAltsMap</H3>
<PRE>
protected java.util.Map&lt;<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>,java.util.Set&lt;java.lang.Integer&gt;&gt; <B>stateToSyntacticallyAmbiguousTokensRuleAltsMap</B></PRE>
<DL>
<DD>Track just like stateToSyntacticallyAmbiguousAltsMap, but only
  for nondeterminisms that arise in the Tokens rule such as keyword vs
  ID rule.  The state maps to the list of Tokens rule alts that are
  in conflict.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="statesResolvedWithSemanticPredicatesSet"><!-- --></A><H3>
statesResolvedWithSemanticPredicatesSet</H3>
<PRE>
protected java.util.Set&lt;<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&gt; <B>statesResolvedWithSemanticPredicatesSet</B></PRE>
<DL>
<DD>Was a syntactic ambiguity resolved with predicates?  Any DFA
  state that predicts more than one alternative, must be resolved
  with predicates or it should be reported to the user.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="stateToAltSetWithSemanticPredicatesMap"><!-- --></A><H3>
stateToAltSetWithSemanticPredicatesMap</H3>
<PRE>
protected java.util.Map&lt;<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>,java.util.Map&lt;java.lang.Integer,<A HREF="../../../org/antlr/analysis/SemanticContext.html" title="class in org.antlr.analysis">SemanticContext</A>&gt;&gt; <B>stateToAltSetWithSemanticPredicatesMap</B></PRE>
<DL>
<DD>Track the predicates for each alt per DFA state;
  more than one DFA state might have syntactically ambig alt prediction.
  Maps DFA state to another map, mapping alt number to a
  SemanticContext (pred(s) to execute to resolve syntactic ambiguity).
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="stateToIncompletelyCoveredAltsMap"><!-- --></A><H3>
stateToIncompletelyCoveredAltsMap</H3>
<PRE>
protected java.util.Map&lt;<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>,java.util.Map&lt;java.lang.Integer,java.util.Set&lt;antlr.Token&gt;&gt;&gt; <B>stateToIncompletelyCoveredAltsMap</B></PRE>
<DL>
<DD>Tracks alts insufficiently covered.
  For example, p1||true gets reduced to true and so leaves
  whole alt uncovered.  This maps DFA state to the set of alts
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="danglingStates"><!-- --></A><H3>
danglingStates</H3>
<PRE>
protected java.util.Set&lt;<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&gt; <B>danglingStates</B></PRE>
<DL>
<DD>The set of states w/o emanating edges and w/o resolving sem preds.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="altsWithProblem"><!-- --></A><H3>
altsWithProblem</H3>
<PRE>
protected java.util.Set&lt;java.lang.Integer&gt; <B>altsWithProblem</B></PRE>
<DL>
<DD>The overall list of alts within the decision that have at least one
  conflicting input sequence.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="nonLLStarDecision"><!-- --></A><H3>
nonLLStarDecision</H3>
<PRE>
protected boolean <B>nonLLStarDecision</B></PRE>
<DL>
<DD>If decision with > 1 alt has recursion in > 1 alt, it's nonregular
  lookahead.  The decision cannot be made with a DFA.
  the alts are stored in altsWithProblem.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="stateToRecursionOverflowConfigurationsMap"><!-- --></A><H3>
stateToRecursionOverflowConfigurationsMap</H3>
<PRE>
protected <A HREF="../../../org/antlr/misc/MultiMap.html" title="class in org.antlr.misc">MultiMap</A>&lt;java.lang.Integer,<A HREF="../../../org/antlr/analysis/NFAConfiguration.html" title="class in org.antlr.analysis">NFAConfiguration</A>&gt; <B>stateToRecursionOverflowConfigurationsMap</B></PRE>
<DL>
<DD>Recursion is limited to a particular depth.  If that limit is exceeded
  the proposed new NFAConfiguration is recorded for the associated DFA state.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="timedOut"><!-- --></A><H3>
timedOut</H3>
<PRE>
protected boolean <B>timedOut</B></PRE>
<DL>
<DD>Did ANTLR have to terminate early on the analysis of this decision?
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="stateReachable"><!-- --></A><H3>
stateReachable</H3>
<PRE>
protected java.util.Map&lt;java.lang.Integer,java.lang.Integer&gt; <B>stateReachable</B></PRE>
<DL>
<DD>Used to find paths through syntactically ambiguous DFA. If we've
  seen statement number before, what did we learn?
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="REACHABLE_BUSY"><!-- --></A><H3>
REACHABLE_BUSY</H3>
<PRE>
public static final java.lang.Integer <B>REACHABLE_BUSY</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="REACHABLE_NO"><!-- --></A><H3>
REACHABLE_NO</H3>
<PRE>
public static final java.lang.Integer <B>REACHABLE_NO</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="REACHABLE_YES"><!-- --></A><H3>
REACHABLE_YES</H3>
<PRE>
public static final java.lang.Integer <B>REACHABLE_YES</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="statesVisitedAtInputDepth"><!-- --></A><H3>
statesVisitedAtInputDepth</H3>
<PRE>
protected java.util.Set&lt;java.lang.String&gt; <B>statesVisitedAtInputDepth</B></PRE>
<DL>
<DD>Used while finding a path through an NFA whose edge labels match
  an input sequence.  Tracks the input position
  we were at the last time at this node.  If same input position, then
  we'd have reached same state without consuming input...probably an
  infinite loop.  Stop.  Set<String>.  The strings look like
  stateNumber_labelIndex.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="statesVisitedDuringSampleSequence"><!-- --></A><H3>
statesVisitedDuringSampleSequence</H3>
<PRE>
protected java.util.Set&lt;java.lang.Integer&gt; <B>statesVisitedDuringSampleSequence</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="verbose"><!-- --></A><H3>
verbose</H3>
<PRE>
public static boolean <B>verbose</B></PRE>
<DL>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="DecisionProbe(org.antlr.analysis.DFA)"><!-- --></A><H3>
DecisionProbe</H3>
<PRE>
public <B>DecisionProbe</B>(<A HREF="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</A>&nbsp;dfa)</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getDescription()"><!-- --></A><H3>
getDescription</H3>
<PRE>
public java.lang.String <B>getDescription</B>()</PRE>
<DL>
<DD>Return a string like "3:22: ( A {;} | B )" that describes this
  decision.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isReduced()"><!-- --></A><H3>
isReduced</H3>
<PRE>
public boolean <B>isReduced</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isCyclic()"><!-- --></A><H3>
isCyclic</H3>
<PRE>
public boolean <B>isCyclic</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isDeterministic()"><!-- --></A><H3>
isDeterministic</H3>
<PRE>
public boolean <B>isDeterministic</B>()</PRE>
<DL>
<DD>If no states are dead-ends, no alts are unreachable, there are
  no nondeterminisms unresolved by syn preds, all is ok with decision.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="analysisTimedOut()"><!-- --></A><H3>
analysisTimedOut</H3>
<PRE>
public boolean <B>analysisTimedOut</B>()</PRE>
<DL>
<DD>Did the analysis complete it's work?
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="analysisOverflowed()"><!-- --></A><H3>
analysisOverflowed</H3>
<PRE>
public boolean <B>analysisOverflowed</B>()</PRE>
<DL>
<DD>Took too long to analyze a DFA
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isNonLLStarDecision()"><!-- --></A><H3>
isNonLLStarDecision</H3>
<PRE>
public boolean <B>isNonLLStarDecision</B>()</PRE>
<DL>
<DD>Found recursion in > 1 alt
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getNumberOfStates()"><!-- --></A><H3>
getNumberOfStates</H3>
<PRE>
public int <B>getNumberOfStates</B>()</PRE>
<DL>
<DD>How many states does the DFA predictor have?
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getUnreachableAlts()"><!-- --></A><H3>
getUnreachableAlts</H3>
<PRE>
public java.util.List&lt;java.lang.Integer&gt; <B>getUnreachableAlts</B>()</PRE>
<DL>
<DD>Get a list of all unreachable alternatives for this decision.  There
  may be multiple alternatives with ambiguous input sequences, but this
  is the overall list of unreachable alternatives (either due to
  conflict resolution or alts w/o accept states).
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDanglingStates()"><!-- --></A><H3>
getDanglingStates</H3>
<PRE>
public java.util.Set <B>getDanglingStates</B>()</PRE>
<DL>
<DD>return set of states w/o emanating edges and w/o resolving sem preds.
  These states come about because the analysis algorithm had to
  terminate early to avoid infinite recursion for example (due to
  left recursion perhaps).
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getNonDeterministicAlts()"><!-- --></A><H3>
getNonDeterministicAlts</H3>
<PRE>
public java.util.Set <B>getNonDeterministicAlts</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getNonDeterministicAltsForState(org.antlr.analysis.DFAState)"><!-- --></A><H3>
getNonDeterministicAltsForState</H3>
<PRE>
public java.util.List <B>getNonDeterministicAltsForState</B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;targetState)</PRE>
<DL>
<DD>Return the sorted list of alts that conflict within a single state.
  Note that predicates may resolve the conflict.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDFAStatesWithSyntacticallyAmbiguousAlts()"><!-- --></A><H3>
getDFAStatesWithSyntacticallyAmbiguousAlts</H3>
<PRE>
public java.util.Set <B>getDFAStatesWithSyntacticallyAmbiguousAlts</B>()</PRE>
<DL>
<DD>Return all DFA states in this DFA that have NFA configurations that
  conflict.  You must report a problem for each state in this set
  because each state represents a different input sequence.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDisabledAlternatives(org.antlr.analysis.DFAState)"><!-- --></A><H3>
getDisabledAlternatives</H3>
<PRE>
public java.util.Set <B>getDisabledAlternatives</B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d)</PRE>
<DL>
<DD>Which alts were specifically turned off to resolve nondeterminisms?
  This is different than the unreachable alts.  Disabled doesn't mean that
  the alternative is totally unreachable necessarily, it just means
  that for this DFA state, that alt is disabled.  There may be other
  accept states for that alt that make an alt reachable.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="removeRecursiveOverflowState(org.antlr.analysis.DFAState)"><!-- --></A><H3>
removeRecursiveOverflowState</H3>
<PRE>
public void <B>removeRecursiveOverflowState</B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d)</PRE>
<DL>
<DD>If a recursion overflow is resolve with predicates, then we need
  to shut off the warning that would be generated.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getSampleNonDeterministicInputSequence(org.antlr.analysis.DFAState)"><!-- --></A><H3>
getSampleNonDeterministicInputSequence</H3>
<PRE>
public java.util.List&lt;<A HREF="../../../org/antlr/analysis/Label.html" title="class in org.antlr.analysis">Label</A>&gt; <B>getSampleNonDeterministicInputSequence</B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;targetState)</PRE>
<DL>
<DD>Return a List<Label> indicating an input sequence that can be matched
  from the start state of the DFA to the targetState (which is known
  to have a problem).
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getInputSequenceDisplay(java.util.List)"><!-- --></A><H3>
getInputSequenceDisplay</H3>
<PRE>
public java.lang.String <B>getInputSequenceDisplay</B>(java.util.List&nbsp;labels)</PRE>
<DL>
<DD>Given List<Label>, return a String with a useful representation
  of the associated input string.  One could show something different
  for lexers and parsers, for example.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getNFAPathStatesForAlt(int, int, java.util.List)"><!-- --></A><H3>
getNFAPathStatesForAlt</H3>
<PRE>
public java.util.List <B>getNFAPathStatesForAlt</B>(int&nbsp;firstAlt,
                                             int&nbsp;alt,
                                             java.util.List&nbsp;labels)</PRE>
<DL>
<DD>Given an alternative associated with a nondeterministic DFA state,
  find the path of NFA states associated with the labels sequence.
  Useful tracing where in the NFA, a single input sequence can be
  matched.  For different alts, you should get different NFA paths.

  The first NFA state for all NFA paths will be the same: the starting
  NFA state of the first nondeterministic alt.  Imagine (A|B|A|A):

        5->9-A->o
  |
  6->10-B->o
  |
  7->11-A->o
  |
  8->12-A->o

  There are 3 nondeterministic alts.  The paths should be:
  5 9 ...
  5 6 7 11 ...
  5 6 7 8 12 ...

  The NFA path matching the sample input sequence (labels) is computed
  using states 9, 11, and 12 rather than 5, 7, 8 because state 5, for
  example can get to all ambig paths.  Must isolate for each alt (hence,
  the extra state beginning each alt in my NFA structures).  Here,
  firstAlt=1.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getSemanticContextForAlt(org.antlr.analysis.DFAState, int)"><!-- --></A><H3>
getSemanticContextForAlt</H3>
<PRE>
public <A HREF="../../../org/antlr/analysis/SemanticContext.html" title="class in org.antlr.analysis">SemanticContext</A> <B>getSemanticContextForAlt</B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d,
                                                int&nbsp;alt)</PRE>
<DL>
<DD>Each state in the DFA represents a different input sequence for an
  alt of the decision.  Given a DFA state, what is the semantic
  predicate context for a particular alt.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="hasPredicate()"><!-- --></A><H3>
hasPredicate</H3>
<PRE>
public boolean <B>hasPredicate</B>()</PRE>
<DL>
<DD>At least one alt refs a sem or syn pred
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getNondeterministicStatesResolvedWithSemanticPredicate()"><!-- --></A><H3>
getNondeterministicStatesResolvedWithSemanticPredicate</H3>
<PRE>
public java.util.Set <B>getNondeterministicStatesResolvedWithSemanticPredicate</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getIncompletelyCoveredAlts(org.antlr.analysis.DFAState)"><!-- --></A><H3>
getIncompletelyCoveredAlts</H3>
<PRE>
public java.util.Map&lt;java.lang.Integer,java.util.Set&lt;antlr.Token&gt;&gt; <B>getIncompletelyCoveredAlts</B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d)</PRE>
<DL>
<DD>Return a list of alts whose predicate context was insufficient to
  resolve a nondeterminism for state d.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="issueWarnings()"><!-- --></A><H3>
issueWarnings</H3>
<PRE>
public void <B>issueWarnings</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="stripWildCardAlts(java.util.Set)"><!-- --></A><H3>
stripWildCardAlts</H3>
<PRE>
protected void <B>stripWildCardAlts</B>(java.util.Set&nbsp;disabledAlts)</PRE>
<DL>
<DD>Get the last disabled alt number and check in the grammar to see
  if that alt is a simple wildcard.  If so, treat like an else clause
  and don't emit the error.  Strip out the last alt if it's wildcard.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="issueRecursionWarnings()"><!-- --></A><H3>
issueRecursionWarnings</H3>
<PRE>
protected void <B>issueRecursionWarnings</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="reportDanglingState(org.antlr.analysis.DFAState)"><!-- --></A><H3>
reportDanglingState</H3>
<PRE>
public void <B>reportDanglingState</B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d)</PRE>
<DL>
<DD>Report the fact that DFA state d is not a state resolved with
  predicates and yet it has no emanating edges.  Usually this
  is a result of the closure/reach operations being unable to proceed
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="reportAnalysisTimeout()"><!-- --></A><H3>
reportAnalysisTimeout</H3>
<PRE>
public void <B>reportAnalysisTimeout</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="reportNonLLStarDecision(org.antlr.analysis.DFA)"><!-- --></A><H3>
reportNonLLStarDecision</H3>
<PRE>
public void <B>reportNonLLStarDecision</B>(<A HREF="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</A>&nbsp;dfa)</PRE>
<DL>
<DD>Report that at least 2 alts have recursive constructs.  There is
  no way to build a DFA so we terminated.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="reportRecursionOverflow(org.antlr.analysis.DFAState, org.antlr.analysis.NFAConfiguration)"><!-- --></A><H3>
reportRecursionOverflow</H3>
<PRE>
public void <B>reportRecursionOverflow</B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d,
                                    <A HREF="../../../org/antlr/analysis/NFAConfiguration.html" title="class in org.antlr.analysis">NFAConfiguration</A>&nbsp;recursionNFAConfiguration)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="reportNondeterminism(org.antlr.analysis.DFAState, java.util.Set)"><!-- --></A><H3>
reportNondeterminism</H3>
<PRE>
public void <B>reportNondeterminism</B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d,
                                 java.util.Set&lt;java.lang.Integer&gt;&nbsp;nondeterministicAlts)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="reportLexerRuleNondeterminism(org.antlr.analysis.DFAState, java.util.Set)"><!-- --></A><H3>
reportLexerRuleNondeterminism</H3>
<PRE>
public void <B>reportLexerRuleNondeterminism</B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d,
                                          java.util.Set&lt;java.lang.Integer&gt;&nbsp;nondeterministicAlts)</PRE>
<DL>
<DD>Currently the analysis reports issues between token definitions, but
  we don't print out warnings in favor of just picking the first token
  definition found in the grammar ala lex/flex.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="reportNondeterminismResolvedWithSemanticPredicate(org.antlr.analysis.DFAState)"><!-- --></A><H3>
reportNondeterminismResolvedWithSemanticPredicate</H3>
<PRE>
public void <B>reportNondeterminismResolvedWithSemanticPredicate</B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="reportAltPredicateContext(org.antlr.analysis.DFAState, java.util.Map)"><!-- --></A><H3>
reportAltPredicateContext</H3>
<PRE>
public void <B>reportAltPredicateContext</B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d,
                                      java.util.Map&nbsp;altPredicateContext)</PRE>
<DL>
<DD>Report the list of predicates found for each alternative; copy
  the list because this set gets altered later by the method
  tryToResolveWithSemanticPredicates() while flagging NFA configurations
  in d as resolved.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="reportIncompletelyCoveredAlts(org.antlr.analysis.DFAState, java.util.Map)"><!-- --></A><H3>
reportIncompletelyCoveredAlts</H3>
<PRE>
public void <B>reportIncompletelyCoveredAlts</B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d,
                                          java.util.Map&lt;java.lang.Integer,java.util.Set&lt;antlr.Token&gt;&gt;&nbsp;altToLocationsReachableWithoutPredicate)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="reachesState(org.antlr.analysis.DFAState, org.antlr.analysis.DFAState, java.util.Set)"><!-- --></A><H3>
reachesState</H3>
<PRE>
protected boolean <B>reachesState</B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;startState,
                               <A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;targetState,
                               java.util.Set&nbsp;states)</PRE>
<DL>
<DD>Given a start state and a target state, return true if start can reach
  target state.  Also, compute the set of DFA states
  that are on a path from start to target; return in states parameter.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDFAPathStatesToTarget(org.antlr.analysis.DFAState)"><!-- --></A><H3>
getDFAPathStatesToTarget</H3>
<PRE>
protected java.util.Set <B>getDFAPathStatesToTarget</B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;targetState)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getSampleInputSequenceUsingStateSet(org.antlr.analysis.State, org.antlr.analysis.State, java.util.Set, java.util.List)"><!-- --></A><H3>
getSampleInputSequenceUsingStateSet</H3>
<PRE>
protected void <B>getSampleInputSequenceUsingStateSet</B>(<A HREF="../../../org/antlr/analysis/State.html" title="class in org.antlr.analysis">State</A>&nbsp;startState,
                                                   <A HREF="../../../org/antlr/analysis/State.html" title="class in org.antlr.analysis">State</A>&nbsp;targetState,
                                                   java.util.Set&nbsp;states,
                                                   java.util.List&lt;<A HREF="../../../org/antlr/analysis/Label.html" title="class in org.antlr.analysis">Label</A>&gt;&nbsp;labels)</PRE>
<DL>
<DD>Given a start state and a final state, find a list of edge labels
  between the two ignoring epsilon.  Limit your scan to a set of states
  passed in.  This is used to show a sample input sequence that is
  nondeterministic with respect to this decision.  Return List<Label> as
  a parameter.  The incoming states set must be all states that lead
  from startState to targetState and no others so this algorithm doesn't
  take a path that eventually leads to a state other than targetState.
  Don't follow loops, leading to short (possibly shortest) path.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getNFAPath(org.antlr.analysis.NFAState, int, java.util.List, java.util.List)"><!-- --></A><H3>
getNFAPath</H3>
<PRE>
protected boolean <B>getNFAPath</B>(<A HREF="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</A>&nbsp;s,
                             int&nbsp;labelIndex,
                             java.util.List&nbsp;labels,
                             java.util.List&nbsp;path)</PRE>
<DL>
<DD>Given a sample input sequence, you usually would like to know the
  path taken through the NFA.  Return the list of NFA states visited
  while matching a list of labels.  This cannot use the usual
  interpreter, which does a deterministic walk.  We need to be able to
  take paths that are turned off during nondeterminism resolution. So,
  just do a depth-first walk traversing edges labeled with the current
  label.  Return true if a path was found emanating from state s.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getStateLabelIndexKey(int, int)"><!-- --></A><H3>
getStateLabelIndexKey</H3>
<PRE>
protected java.lang.String <B>getStateLabelIndexKey</B>(int&nbsp;s,
                                                 int&nbsp;i)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getTokenNameForTokensRuleAlt(int)"><!-- --></A><H3>
getTokenNameForTokensRuleAlt</H3>
<PRE>
public java.lang.String <B>getTokenNameForTokensRuleAlt</B>(int&nbsp;alt)</PRE>
<DL>
<DD>From an alt number associated with artificial Tokens rule, return
  the name of the token that is associated with that alt.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="reset()"><!-- --></A><H3>
reset</H3>
<PRE>
public void <B>reset</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/antlr/analysis/AnalysisTimeoutException.html" title="class in org.antlr.analysis"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/antlr/analysis/DecisionProbe.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="DecisionProbe.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
