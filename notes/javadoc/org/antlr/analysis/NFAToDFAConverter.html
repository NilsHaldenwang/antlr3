<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_16) on Wed Oct 14 09:00:04 EDT 2009 -->
<TITLE>
NFAToDFAConverter
</TITLE>

<META NAME="date" CONTENT="2009-10-14">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="NFAToDFAConverter";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../org/antlr/analysis/NonLLStarDecisionException.html" title="class in org.antlr.analysis"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/antlr/analysis/NFAToDFAConverter.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="NFAToDFAConverter.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.antlr.analysis</FONT>
<BR>
Class NFAToDFAConverter</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>org.antlr.analysis.NFAToDFAConverter</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>NFAToDFAConverter</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
Code that embodies the NFA conversion to DFA. A new object is needed
  per DFA (also required for thread safety if multiple conversions
  launched).
<P>

<P>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAToDFAConverter.html#computingStartState">computingStartState</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../org/antlr/analysis/NFAContext.html" title="class in org.antlr.analysis">NFAContext</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAToDFAConverter.html#contextTrees">contextTrees</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;While converting NFA, we must track states that
  reference other rule's NFAs so we know what to do
  at the end of a rule.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAToDFAConverter.html#debug">debug</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAToDFAConverter.html#dfa">dfa</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;We are converting which DFA?</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAToDFAConverter.html#SINGLE_THREADED_NFA_CONVERSION">SINGLE_THREADED_NFA_CONVERSION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Should ANTLR launch multiple threads to convert NFAs to DFAs?
  With a 2-CPU box, I note that it's about the same single or
  multithreaded.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAToDFAConverter.html#work">work</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A list of DFA states we still need to process during NFA conversion</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAToDFAConverter.html#NFAToDFAConverter(org.antlr.analysis.DFA)">NFAToDFAConverter</A></B>(<A HREF="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</A>&nbsp;dfa)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAToDFAConverter.html#addDFAStateToWorkList(org.antlr.analysis.DFAState)">addDFAStateToWorkList</A></B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add a new DFA state to the DFA if not already present.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAToDFAConverter.html#addPredicateTransitions(org.antlr.analysis.DFAState)">addPredicateTransitions</A></B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for each NFA config in d, look for "predicate required" sign set
  during nondeterminism resolution.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAToDFAConverter.html#addTransition(org.antlr.analysis.DFAState, org.antlr.analysis.Label, org.antlr.analysis.DFAState, java.util.Map)">addTransition</A></B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d,
              <A HREF="../../../org/antlr/analysis/Label.html" title="class in org.antlr.analysis">Label</A>&nbsp;label,
              <A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;targetState,
              java.util.Map&nbsp;targetToLabelMap)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add a transition from state d to targetState with label in normal case.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAToDFAConverter.html#closure(org.antlr.analysis.DFAState)">closure</A></B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For all NFA states (configurations) merged in d,
  compute the epsilon closure; that is, find all NFA states reachable
  from the NFA states in d via purely epsilon transitions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAToDFAConverter.html#closure(org.antlr.analysis.NFAState, int, org.antlr.analysis.NFAContext, org.antlr.analysis.SemanticContext, org.antlr.analysis.DFAState, boolean)">closure</A></B>(<A HREF="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</A>&nbsp;p,
        int&nbsp;alt,
        <A HREF="../../../org/antlr/analysis/NFAContext.html" title="class in org.antlr.analysis">NFAContext</A>&nbsp;context,
        <A HREF="../../../org/antlr/analysis/SemanticContext.html" title="class in org.antlr.analysis">SemanticContext</A>&nbsp;semanticContext,
        <A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d,
        boolean&nbsp;collectPredicates)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Where can we get from NFA state p traversing only epsilon transitions?
  Add new NFA states + context to DFA state d.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAToDFAConverter.html#closureIsBusy(org.antlr.analysis.DFAState, org.antlr.analysis.NFAConfiguration)">closureIsBusy</A></B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d,
              <A HREF="../../../org/antlr/analysis/NFAConfiguration.html" title="class in org.antlr.analysis">NFAConfiguration</A>&nbsp;proposedNFAConfiguration)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A closure operation should abort if that computation has already
  been done or a computation with a conflicting context has already
  been done.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAToDFAConverter.html#computeStartState()">computeStartState</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;From this first NFA state of a decision, create a DFA.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAToDFAConverter.html#convert()">convert</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAToDFAConverter.html#convertToAcceptState(org.antlr.analysis.DFAState, int)">convertToAcceptState</A></B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d,
                     int&nbsp;alt)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAToDFAConverter.html#convertToEOTAcceptState(org.antlr.analysis.DFAState)">convertToEOTAcceptState</A></B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Walk the configurations of this DFA state d looking for the
  configuration, c, that has a transition on EOT.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAToDFAConverter.html#findNewDFAStatesAndAddDFATransitions(org.antlr.analysis.DFAState)">findNewDFAStatesAndAddDFATransitions</A></B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;From this node, add a d--a-->t transition for all
  labels 'a' where t is a DFA node created
  from the set of NFA states reachable from any NFA
  state in DFA state d.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAToDFAConverter.html#getMinAlt(java.util.Set)">getMinAlt</A></B>(java.util.Set&lt;java.lang.Integer&gt;&nbsp;nondeterministicAlts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Map&lt;java.lang.Integer,<A HREF="../../../org/antlr/analysis/SemanticContext.html" title="class in org.antlr.analysis">SemanticContext</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAToDFAConverter.html#getPredicatesPerNonDeterministicAlt(org.antlr.analysis.DFAState, java.util.Set)">getPredicatesPerNonDeterministicAlt</A></B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d,
                                    java.util.Set&nbsp;nondeterministicAlts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a mapping from nondeterministc alt to combined list of predicates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;<A HREF="../../../org/antlr/analysis/SemanticContext.html" title="class in org.antlr.analysis">SemanticContext</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAToDFAConverter.html#getUnionOfPredicates(java.util.Map)">getUnionOfPredicates</A></B>(java.util.Map&nbsp;altToPredMap)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OR together all predicates from the alts.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAToDFAConverter.html#initContextTrees(int)">initContextTrees</A></B>(int&nbsp;numberOfAlts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAToDFAConverter.html#max(java.util.Set)">max</A></B>(java.util.Set&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAToDFAConverter.html#reach(org.antlr.analysis.DFAState, org.antlr.analysis.Label)">reach</A></B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d,
      <A HREF="../../../org/antlr/analysis/Label.html" title="class in org.antlr.analysis">Label</A>&nbsp;label)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given the set of NFA states in DFA state d, find all NFA states
  reachable traversing label arcs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAToDFAConverter.html#resolveByChoosingFirstAlt(org.antlr.analysis.DFAState, java.util.Set)">resolveByChoosingFirstAlt</A></B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d,
                          java.util.Set&nbsp;nondeterministicAlts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAToDFAConverter.html#resolveByPickingExitAlt(org.antlr.analysis.DFAState, java.util.Set)">resolveByPickingExitAlt</A></B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d,
                        java.util.Set&nbsp;nondeterministicAlts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Resolve state d by choosing exit alt, which is same value as the
  number of alternatives.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAToDFAConverter.html#resolveByPickingMinAlt(org.antlr.analysis.DFAState, java.util.Set)">resolveByPickingMinAlt</A></B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d,
                       java.util.Set&nbsp;nondeterministicAlts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Turn off all configurations associated with the
  set of incoming nondeterministic alts except the min alt number.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAToDFAConverter.html#resolveNonDeterminisms(org.antlr.analysis.DFAState)">resolveNonDeterminisms</A></B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If > 1 NFA configurations within this DFA state have identical
  NFA state and context, but differ in their predicted
  TODO update for new context suffix stuff 3-9-2005
  alternative then a single input sequence predicts multiple alts.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAToDFAConverter.html#tryToResolveWithSemanticPredicates(org.antlr.analysis.DFAState, java.util.Set)">tryToResolveWithSemanticPredicates</A></B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d,
                                   java.util.Set&nbsp;nondeterministicAlts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;See if a set of nondeterministic alternatives can be disambiguated
  with the semantic predicate contexts of the alternatives.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/antlr/analysis/NFAToDFAConverter.html#turnOffOtherAlts(org.antlr.analysis.DFAState, int, java.util.Set)">turnOffOtherAlts</A></B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d,
                 int&nbsp;min,
                 java.util.Set&lt;java.lang.Integer&gt;&nbsp;nondeterministicAlts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;turn off all states associated with alts other than the good one
  (as long as they are one of the nondeterministic ones)</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="work"><!-- --></A><H3>
work</H3>
<PRE>
protected java.util.List <B>work</B></PRE>
<DL>
<DD>A list of DFA states we still need to process during NFA conversion
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="contextTrees"><!-- --></A><H3>
contextTrees</H3>
<PRE>
protected <A HREF="../../../org/antlr/analysis/NFAContext.html" title="class in org.antlr.analysis">NFAContext</A>[] <B>contextTrees</B></PRE>
<DL>
<DD>While converting NFA, we must track states that
  reference other rule's NFAs so we know what to do
  at the end of a rule.  We need to know what context invoked
  this rule so we can know where to continue looking for NFA
  states.  I'm tracking a context tree (record of rule invocation
  stack trace) for each alternative that could be predicted.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="dfa"><!-- --></A><H3>
dfa</H3>
<PRE>
protected <A HREF="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</A> <B>dfa</B></PRE>
<DL>
<DD>We are converting which DFA?
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="debug"><!-- --></A><H3>
debug</H3>
<PRE>
public static boolean <B>debug</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="SINGLE_THREADED_NFA_CONVERSION"><!-- --></A><H3>
SINGLE_THREADED_NFA_CONVERSION</H3>
<PRE>
public static boolean <B>SINGLE_THREADED_NFA_CONVERSION</B></PRE>
<DL>
<DD>Should ANTLR launch multiple threads to convert NFAs to DFAs?
  With a 2-CPU box, I note that it's about the same single or
  multithreaded.  Both CPU meters are going even when single-threaded
  so I assume the GC is killing us.  Could be the compiler.  When I
  run java -Xint mode, I get about 15% speed improvement with multiple
  threads.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="computingStartState"><!-- --></A><H3>
computingStartState</H3>
<PRE>
protected boolean <B>computingStartState</B></PRE>
<DL>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="NFAToDFAConverter(org.antlr.analysis.DFA)"><!-- --></A><H3>
NFAToDFAConverter</H3>
<PRE>
public <B>NFAToDFAConverter</B>(<A HREF="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</A>&nbsp;dfa)</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="convert()"><!-- --></A><H3>
convert</H3>
<PRE>
public void <B>convert</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="computeStartState()"><!-- --></A><H3>
computeStartState</H3>
<PRE>
protected <A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A> <B>computeStartState</B>()</PRE>
<DL>
<DD>From this first NFA state of a decision, create a DFA.
  Walk each alt in decision and compute closure from the start of that
  rule, making sure that the closure does not include other alts within
  that same decision.  The idea is to associate a specific alt number
  with the starting closure so we can trace the alt number for all states
  derived from this.  At a stop state in the DFA, we can return this alt
  number, indicating which alt is predicted.

  If this DFA is derived from an loop back NFA state, then the first
  transition is actually the exit branch of the loop.  Rather than make
  this alternative one, let's make this alt n+1 where n is the number of
  alts in this block.  This is nice to keep the alts of the block 1..n;
  helps with error messages.

  I handle nongreedy in findNewDFAStatesAndAddDFATransitions
  when nongreedy and EOT transition.  Make state with EOT emanating
  from it the accept state.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="findNewDFAStatesAndAddDFATransitions(org.antlr.analysis.DFAState)"><!-- --></A><H3>
findNewDFAStatesAndAddDFATransitions</H3>
<PRE>
protected void <B>findNewDFAStatesAndAddDFATransitions</B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d)</PRE>
<DL>
<DD>From this node, add a d--a-->t transition for all
  labels 'a' where t is a DFA node created
  from the set of NFA states reachable from any NFA
  state in DFA state d.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="addTransition(org.antlr.analysis.DFAState, org.antlr.analysis.Label, org.antlr.analysis.DFAState, java.util.Map)"><!-- --></A><H3>
addTransition</H3>
<PRE>
protected static int <B>addTransition</B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d,
                                   <A HREF="../../../org/antlr/analysis/Label.html" title="class in org.antlr.analysis">Label</A>&nbsp;label,
                                   <A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;targetState,
                                   java.util.Map&nbsp;targetToLabelMap)</PRE>
<DL>
<DD>Add a transition from state d to targetState with label in normal case.
  if COLLAPSE_ALL_INCIDENT_EDGES, however, try to merge all edges from
  d to targetState; this means merging their labels.  Another optimization
  is to reduce to a single EOT edge any set of edges from d to targetState
  where there exists an EOT state.  EOT is like the wildcard so don't
  bother to test any other edges.  Example:

  NUM_INT
    : '1'..'9' ('0'..'9')* ('l'|'L')?
    | '0' ('x'|'X') ('0'..'9'|'a'..'f'|'A'..'F')+ ('l'|'L')?
    | '0' ('0'..'7')* ('l'|'L')?
    ;

  The normal decision to predict alts 1, 2, 3 is:

  if ( (input.LA(1)>='1' && input.LA(1)<='9') ) {
       alt7=1;
  }
  else if ( input.LA(1)=='0' ) {
      if ( input.LA(2)=='X'||input.LA(2)=='x' ) {
          alt7=2;
      }
      else if ( (input.LA(2)>='0' && input.LA(2)<='7') ) {
           alt7=3;
      }
      else if ( input.LA(2)=='L'||input.LA(2)=='l' ) {
           alt7=3;
      }
      else {
           alt7=3;
      }
  }
  else error

  Clearly, alt 3 is predicted with extra work since it tests 0..7
  and [lL] before finally realizing that any character is actually
  ok at k=2.

  A better decision is as follows:

  if ( (input.LA(1)>='1' && input.LA(1)<='9') ) {
      alt7=1;
  }
  else if ( input.LA(1)=='0' ) {
      if ( input.LA(2)=='X'||input.LA(2)=='x' ) {
          alt7=2;
      }
      else {
          alt7=3;
      }
  }

  The DFA originally has 3 edges going to the state the predicts alt 3,
  but upon seeing the EOT edge (the "else"-clause), this method
  replaces the old merged label (which would have (0..7|l|L)) with EOT.
  The code generator then leaves alt 3 predicted with a simple else-
  clause. :)

  The only time the EOT optimization makes no sense is in the Tokens
  rule.  We want EOT to truly mean you have matched an entire token
  so don't bother actually rewinding to execute that rule unless there
  are actions in that rule.  For now, since I am not preventing
  backtracking from Tokens rule, I will simply allow the optimization.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="closure(org.antlr.analysis.DFAState)"><!-- --></A><H3>
closure</H3>
<PRE>
public void <B>closure</B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d)</PRE>
<DL>
<DD>For all NFA states (configurations) merged in d,
  compute the epsilon closure; that is, find all NFA states reachable
  from the NFA states in d via purely epsilon transitions.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="closure(org.antlr.analysis.NFAState, int, org.antlr.analysis.NFAContext, org.antlr.analysis.SemanticContext, org.antlr.analysis.DFAState, boolean)"><!-- --></A><H3>
closure</H3>
<PRE>
public void <B>closure</B>(<A HREF="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</A>&nbsp;p,
                    int&nbsp;alt,
                    <A HREF="../../../org/antlr/analysis/NFAContext.html" title="class in org.antlr.analysis">NFAContext</A>&nbsp;context,
                    <A HREF="../../../org/antlr/analysis/SemanticContext.html" title="class in org.antlr.analysis">SemanticContext</A>&nbsp;semanticContext,
                    <A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d,
                    boolean&nbsp;collectPredicates)</PRE>
<DL>
<DD>Where can we get from NFA state p traversing only epsilon transitions?
  Add new NFA states + context to DFA state d.  Also add semantic
  predicates to semantic context if collectPredicates is set.  We only
  collect predicates at hoisting depth 0, meaning before any token/char
  have been recognized.  This corresponds, during analysis, to the
  initial DFA start state construction closure() invocation.

  There are four cases of interest (the last being the usual transition):

   1. Traverse an edge that takes us to the start state of another
      rule, r.  We must push this state so that if the DFA
      conversion hits the end of rule r, then it knows to continue
      the conversion at state following state that "invoked" r. By
      construction, there is a single transition emanating from a rule
      ref node.

   2. Reach an NFA state associated with the end of a rule, r, in the
      grammar from which it was built.  We must add an implicit (i.e.,
      don't actually add an epsilon transition) epsilon transition
      from r's end state to the NFA state following the NFA state
      that transitioned to rule r's start state.  Because there are
      many states that could reach r, the context for a rule invocation
      is part of a call tree not a simple stack.  When we fall off end
      of rule, "pop" a state off the call tree and add that state's
      "following" node to d's NFA configuration list.  The context
      for this new addition will be the new "stack top" in the call tree.

   3. Like case 2, we reach an NFA state associated with the end of a
      rule, r, in the grammar from which NFA was built.  In this case,
      however, we realize that during this NFA->DFA conversion, no state
      invoked the current rule's NFA.  There is no choice but to add
      all NFA states that follow references to r's start state.  This is
      analogous to computing the FOLLOW(r) in the LL(k) world.  By
      construction, even rule stop state has a chain of nodes emanating
      from it that points to every possible following node.  This case
      is conveniently handled then by the 4th case.

   4. Normal case.  If p can reach another NFA state q, then add
      q to d's configuration list, copying p's context for q's context.
      If there is a semantic predicate on the transition, then AND it
      with any existing semantic context.

   Current state p is always added to d's configuration list as it's part
   of the closure as well.

  When is a closure operation in a cycle condition?  While it is
  very possible to have the same NFA state mentioned twice
  within the same DFA state, there are two situations that
  would lead to nontermination of closure operation:

  o   Whenever closure reaches a configuration where the same state
      with same or a suffix context already exists.  This catches
      the IF-THEN-ELSE tail recursion cycle and things like

      a : A a | B ;

      the context will be $ (empty stack).

      We have to check
      larger context stacks because of (...)+ loops.  For
      example, the context of a (...)+ can be nonempty if the
      surrounding rule is invoked by another rule:

      a : b A | X ;
      b : (B|)+ ;  // nondeterministic by the way

      The context of the (B|)+ loop is "invoked from item
      a : . b A ;" and then the empty alt of the loop can reach back
      to itself.  The context stack will have one "return
      address" element and so we must check for same state, same
      context for arbitrary context stacks.

      Idea: If we've seen this configuration before during closure, stop.
      We also need to avoid reaching same state with conflicting context.
      Ultimately analysis would stop and we'd find the conflict, but we
      should stop the computation.  Previously I only checked for
      exact config.  Need to check for same state, suffix context
                not just exact context.

  o   Whenever closure reaches a configuration where state p
      is present in its own context stack.  This means that
      p is a rule invocation state and the target rule has
      been called before.  NFAContext.MAX_RECURSIVE_INVOCATIONS
      (See the comment there also) determines how many times
      it's possible to recurse; clearly we cannot recurse forever.
      Some grammars such as the following actually require at
      least one recursive call to correctly compute the lookahead:

      a : L ID R
        | b
        ;
      b : ID
        | L a R
        ;

      Input L ID R is ambiguous but to figure this out, ANTLR
      needs to go a->b->a->b to find the L ID sequence.

      Do not allow closure to add a configuration that would
      allow too much recursion.

      This case also catches infinite left recursion.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="closureIsBusy(org.antlr.analysis.DFAState, org.antlr.analysis.NFAConfiguration)"><!-- --></A><H3>
closureIsBusy</H3>
<PRE>
public static boolean <B>closureIsBusy</B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d,
                                    <A HREF="../../../org/antlr/analysis/NFAConfiguration.html" title="class in org.antlr.analysis">NFAConfiguration</A>&nbsp;proposedNFAConfiguration)</PRE>
<DL>
<DD>A closure operation should abort if that computation has already
  been done or a computation with a conflicting context has already
  been done.  If proposed NFA config's state and alt are the same
  there is potentially a problem.  If the stack context is identical
  then clearly the exact same computation is proposed.  If a context
  is a suffix of the other, then again the computation is in an
  identical context.  ?$ and ??$ are considered the same stack.
  We could walk configurations linearly doing the comparison instead
  of a set for exact matches but it's much slower because you can't
  do a Set lookup.  I use exact match as ANTLR
  always detect the conflict later when checking for context suffixes...
  I check for left-recursive stuff and terminate before analysis to
  avoid need to do this more expensive computation.

  12-31-2007: I had to use the loop again rather than simple
  closureBusy.contains(proposedNFAConfiguration) lookup.  The
  semantic context should not be considered when determining if
  a closure operation is busy.  I saw a FOLLOW closure operation
  spin until time out because the predicate context kept increasing
  in size even though it's same boolean value.  This seems faster also
  because I'm not doing String.equals on the preds all the time.

  05-05-2008: Hmm...well, i think it was a mistake to remove the sem
  ctx check below...adding back in.  Coincides with report of ANTLR
  getting super slow: http://www.antlr.org:8888/browse/ANTLR-235
  This could be because it doesn't properly compute then resolve
  a predicate expression.  Seems to fix unit test:
  TestSemanticPredicates.testSemanticContextPreventsEarlyTerminationOfClosure()
  Changing back to Set from List.  Changed a large grammar from 8 minutes
  to 11 seconds.  Cool.  Closing ANTLR-235.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="reach(org.antlr.analysis.DFAState, org.antlr.analysis.Label)"><!-- --></A><H3>
reach</H3>
<PRE>
public <A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A> <B>reach</B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d,
                      <A HREF="../../../org/antlr/analysis/Label.html" title="class in org.antlr.analysis">Label</A>&nbsp;label)</PRE>
<DL>
<DD>Given the set of NFA states in DFA state d, find all NFA states
  reachable traversing label arcs.  By definition, there can be
  only one DFA state reachable by an atom from DFA state d so we must
  find and merge all NFA states reachable via label.  Return a new
  DFAState that has all of those NFA states with their context (i.e.,
  which alt do they predict and where to return to if they fall off
  end of a rule).

  Because we cannot jump to another rule nor fall off the end of a rule
  via a non-epsilon transition, NFA states reachable from d have the
  same configuration as the NFA state in d.  So if NFA state 7 in d's
  configurations can reach NFA state 13 then 13 will be added to the
  new DFAState (labelDFATarget) with the same configuration as state
  7 had.

  This method does not see EOT transitions off the end of token rule
  accept states if the rule was invoked by somebody.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="convertToEOTAcceptState(org.antlr.analysis.DFAState)"><!-- --></A><H3>
convertToEOTAcceptState</H3>
<PRE>
protected void <B>convertToEOTAcceptState</B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d)</PRE>
<DL>
<DD>Walk the configurations of this DFA state d looking for the
  configuration, c, that has a transition on EOT.  State d should
  be converted to an accept state predicting the c.alt.  Blast
  d's current configuration set and make it just have config c.

  TODO: can there be more than one config with EOT transition?
  That would mean that two NFA configurations could reach the
  end of the token with possibly different predicted alts.
  Seems like that would be rare or impossible.  Perhaps convert
  this routine to find all such configs and give error if >1.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="addDFAStateToWorkList(org.antlr.analysis.DFAState)"><!-- --></A><H3>
addDFAStateToWorkList</H3>
<PRE>
protected <A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A> <B>addDFAStateToWorkList</B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d)</PRE>
<DL>
<DD>Add a new DFA state to the DFA if not already present.
  If the DFA state uniquely predicts a single alternative, it
  becomes a stop state; don't add to work list.  Further, if
  there exists an NFA state predicted by > 1 different alternatives
  and with the same syn and sem context, the DFA is nondeterministic for
  at least one input sequence reaching that NFA state.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="convertToAcceptState(org.antlr.analysis.DFAState, int)"><!-- --></A><H3>
convertToAcceptState</H3>
<PRE>
protected <A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A> <B>convertToAcceptState</B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d,
                                        int&nbsp;alt)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="resolveNonDeterminisms(org.antlr.analysis.DFAState)"><!-- --></A><H3>
resolveNonDeterminisms</H3>
<PRE>
public void <B>resolveNonDeterminisms</B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d)</PRE>
<DL>
<DD>If > 1 NFA configurations within this DFA state have identical
  NFA state and context, but differ in their predicted
  TODO update for new context suffix stuff 3-9-2005
  alternative then a single input sequence predicts multiple alts.
  The NFA decision is therefore syntactically indistinguishable
  from the left edge upon at least one input sequence.  We may
  terminate the NFA to DFA conversion for these paths since no
  paths emanating from those NFA states can possibly separate
  these conjoined twins once interwined to make things
  deterministic (unless there are semantic predicates; see below).

  Upon a nondeterministic set of NFA configurations, we should
  report a problem to the grammar designer and resolve the issue
  by aribitrarily picking the first alternative (this usually
  ends up producing the most natural behavior).  Pick the lowest
  alt number and just turn off all NFA configurations
  associated with the other alts. Rather than remove conflicting
  NFA configurations, I set the "resolved" bit so that future
  computations will ignore them.  In this way, we maintain the
  complete DFA state with all its configurations, but prevent
  future DFA conversion operations from pursuing undesirable
  paths.  Remember that we want to terminate DFA conversion as
  soon as we know the decision is deterministic *or*
  nondeterministic.

  [BTW, I have convinced myself that there can be at most one
  set of nondeterministic configurations in a DFA state.  Only NFA
  configurations arising from the same input sequence can appear
  in a DFA state.  There is no way to have another complete set
  of nondeterministic NFA configurations without another input
  sequence, which would reach a different DFA state.  Therefore,
  the two nondeterministic NFA configuration sets cannot collide
  in the same DFA state.]

  Consider DFA state {(s|1),(s|2),(s|3),(t|3),(v|4)} where (s|a)
  is state 's' and alternative 'a'.  Here, configuration set
  {(s|1),(s|2),(s|3)} predicts 3 different alts.  Configurations
  (s|2) and (s|3) are "resolved", leaving {(s|1),(t|3),(v|4)} as
  items that must still be considered by the DFA conversion
  algorithm in DFA.findNewDFAStatesAndAddDFATransitions().

  Consider the following grammar where alts 1 and 2 are no
  problem because of the 2nd lookahead symbol.  Alts 3 and 4 are
  identical and will therefore reach the rule end NFA state but
  predicting 2 different alts (no amount of future lookahead
  will render them deterministic/separable):

  a : A B
    | A C
    | A
    | A
    ;

  Here is a (slightly reduced) NFA of this grammar:

  (1)-A->(2)-B->(end)-EOF->(8)
   |              ^
  (2)-A->(3)-C----|
   |              ^
  (4)-A->(5)------|
   |              ^
  (6)-A->(7)------|

  where (n) is NFA state n.  To begin DFA conversion, the start
  state is created:

  {(1|1),(2|2),(4|3),(6|4)}

  Upon A, all NFA configurations lead to new NFA states yielding
  new DFA state:

  {(2|1),(3|2),(5|3),(7|4),(end|3),(end|4)}

  where the configurations with state end in them are added
  during the epsilon closure operation.  State end predicts both
  alts 3 and 4.  An error is reported, the latter configuration is
  flagged as resolved leaving the DFA state as:

  {(2|1),(3|2),(5|3),(7|4|resolved),(end|3),(end|4|resolved)}

  As NFA configurations are added to a DFA state during its
  construction, the reachable set of labels is computed.  Here
  reachable is {B,C,EOF} because there is at least one NFA state
  in the DFA state that can transition upon those symbols.

  The final DFA looks like:

  {(1|1),(2|2),(4|3),(6|4)}
              |
              v
  {(2|1),(3|2),(5|3),(7|4),(end|3),(end|4)} -B-> (end|1)
              |                        |
              C                        ----EOF-> (8,3)
              |
              v
           (end|2)

  Upon AB, alt 1 is predicted.  Upon AC, alt 2 is predicted.
  Upon A EOF, alt 3 is predicted.  Alt 4 is not a viable
  alternative.

  The algorithm is essentially to walk all the configurations
  looking for a conflict of the form (s|i) and (s|j) for i!=j.
  Use a hash table to track state+context pairs for collisions
  so that we have O(n) to walk the n configurations looking for
  a conflict.  Upon every conflict, track the alt number so
  we have a list of all nondeterministically predicted alts. Also
  track the minimum alt.  Next go back over the configurations, setting
  the "resolved" bit for any that have an alt that is a member of
  the nondeterministic set.  This will effectively remove any alts
  but the one we want from future consideration.

  See resolveWithSemanticPredicates()

  AMBIGUOUS TOKENS

  With keywords and ID tokens, there is an inherit ambiguity in that
  "int" can be matched by ID also.  Each lexer rule has an EOT
  transition emanating from it which is used whenever the end of
  a rule is reached and another token rule did not invoke it.  EOT
  is the only thing that can be seen next.  If two rules are identical
  like "int" and "int" then the 2nd def is unreachable and you'll get
  a warning.  We prevent a warning though for the keyword/ID issue as
  ID is still reachable.  This can be a bit weird.  '+' rule then a
  '+'|'+=' rule will fail to match '+' for the 2nd rule.

  If all NFA states in this DFA state are targets of EOT transitions,
  (and there is more than one state plus no unique alt is predicted)
  then DFA conversion will leave this state as a dead state as nothing
  can be reached from this state.  To resolve the ambiguity, just do
  what flex and friends do: pick the first rule (alt in this case) to
  win.  This means you should put keywords before the ID rule.
  If the DFA state has only one NFA state then there is no issue:
  it uniquely predicts one alt. :)  Problem
  states will look like this during conversion:

  DFA 1:{9|1, 19|2, 14|3, 20|2, 23|2, 24|2, ...}-<EOT>->5:{41|3, 42|2}

  Worse, when you have two identical literal rules, you will see 3 alts
  in the EOT state (one for ID and one each for the identical rules).
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="resolveByChoosingFirstAlt(org.antlr.analysis.DFAState, java.util.Set)"><!-- --></A><H3>
resolveByChoosingFirstAlt</H3>
<PRE>
protected int <B>resolveByChoosingFirstAlt</B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d,
                                        java.util.Set&nbsp;nondeterministicAlts)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="resolveByPickingMinAlt(org.antlr.analysis.DFAState, java.util.Set)"><!-- --></A><H3>
resolveByPickingMinAlt</H3>
<PRE>
protected int <B>resolveByPickingMinAlt</B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d,
                                     java.util.Set&nbsp;nondeterministicAlts)</PRE>
<DL>
<DD>Turn off all configurations associated with the
  set of incoming nondeterministic alts except the min alt number.
  There may be many alts among the configurations but only turn off
  the ones with problems (other than the min alt of course).

  If nondeterministicAlts is null then turn off all configs 'cept those
  associated with the minimum alt.

  Return the min alt found.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="resolveByPickingExitAlt(org.antlr.analysis.DFAState, java.util.Set)"><!-- --></A><H3>
resolveByPickingExitAlt</H3>
<PRE>
protected int <B>resolveByPickingExitAlt</B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d,
                                      java.util.Set&nbsp;nondeterministicAlts)</PRE>
<DL>
<DD>Resolve state d by choosing exit alt, which is same value as the
  number of alternatives.  Return that exit alt.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="turnOffOtherAlts(org.antlr.analysis.DFAState, int, java.util.Set)"><!-- --></A><H3>
turnOffOtherAlts</H3>
<PRE>
protected static void <B>turnOffOtherAlts</B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d,
                                       int&nbsp;min,
                                       java.util.Set&lt;java.lang.Integer&gt;&nbsp;nondeterministicAlts)</PRE>
<DL>
<DD>turn off all states associated with alts other than the good one
  (as long as they are one of the nondeterministic ones)
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getMinAlt(java.util.Set)"><!-- --></A><H3>
getMinAlt</H3>
<PRE>
protected static int <B>getMinAlt</B>(java.util.Set&lt;java.lang.Integer&gt;&nbsp;nondeterministicAlts)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="tryToResolveWithSemanticPredicates(org.antlr.analysis.DFAState, java.util.Set)"><!-- --></A><H3>
tryToResolveWithSemanticPredicates</H3>
<PRE>
protected boolean <B>tryToResolveWithSemanticPredicates</B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d,
                                                     java.util.Set&nbsp;nondeterministicAlts)</PRE>
<DL>
<DD>See if a set of nondeterministic alternatives can be disambiguated
  with the semantic predicate contexts of the alternatives.

  Without semantic predicates, syntactic conflicts are resolved
  by simply choosing the first viable alternative.  In the
  presence of semantic predicates, you can resolve the issue by
  evaluating boolean expressions at run time.  During analysis,
  this amounts to suppressing grammar error messages to the
  developer.  NFA configurations are always marked as "to be
  resolved with predicates" so that
  DFA.findNewDFAStatesAndAddDFATransitions() will know to ignore
  these configurations and add predicate transitions to the DFA
  after adding token/char labels.

  During analysis, we can simply make sure that for n
  ambiguously predicted alternatives there are at least n-1
  unique predicate sets.  The nth alternative can be predicted
  with "not" the "or" of all other predicates.  NFA configurations without
  predicates are assumed to have the default predicate of
  "true" from a user point of view.  When true is combined via || with
  another predicate, the predicate is a tautology and must be removed
  from consideration for disambiguation:

  a : b | B ; // hoisting p1||true out of rule b, yields no predicate
  b : {p1}? B | B ;

  This is done down in getPredicatesPerNonDeterministicAlt().
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getPredicatesPerNonDeterministicAlt(org.antlr.analysis.DFAState, java.util.Set)"><!-- --></A><H3>
getPredicatesPerNonDeterministicAlt</H3>
<PRE>
protected java.util.Map&lt;java.lang.Integer,<A HREF="../../../org/antlr/analysis/SemanticContext.html" title="class in org.antlr.analysis">SemanticContext</A>&gt; <B>getPredicatesPerNonDeterministicAlt</B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d,
                                                                                               java.util.Set&nbsp;nondeterministicAlts)</PRE>
<DL>
<DD>Return a mapping from nondeterministc alt to combined list of predicates.
  If both (s|i|semCtx1) and (t|i|semCtx2) exist, then the proper predicate
  for alt i is semCtx1||semCtx2 because you have arrived at this single
  DFA state via two NFA paths, both of which have semantic predicates.
  We ignore deterministic alts because syntax alone is sufficient
  to predict those.  Do not include their predicates.

  Alts with no predicate are assumed to have {true}? pred.

  When combining via || with "true", all predicates are removed from
  consideration since the expression will always be true and hence
  not tell us how to resolve anything.  So, if any NFA configuration
  in this DFA state does not have a semantic context, the alt cannot
  be resolved with a predicate.

  If nonnull, incidentEdgeLabel tells us what NFA transition label
  we did a reach on to compute state d.  d may have insufficient
  preds, so we really want this for the error message.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getUnionOfPredicates(java.util.Map)"><!-- --></A><H3>
getUnionOfPredicates</H3>
<PRE>
protected static <A HREF="../../../org/antlr/analysis/SemanticContext.html" title="class in org.antlr.analysis">SemanticContext</A> <B>getUnionOfPredicates</B>(java.util.Map&nbsp;altToPredMap)</PRE>
<DL>
<DD>OR together all predicates from the alts.  Note that the predicate
  for an alt could itself be a combination of predicates.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="addPredicateTransitions(org.antlr.analysis.DFAState)"><!-- --></A><H3>
addPredicateTransitions</H3>
<PRE>
protected void <B>addPredicateTransitions</B>(<A HREF="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</A>&nbsp;d)</PRE>
<DL>
<DD>for each NFA config in d, look for "predicate required" sign set
  during nondeterminism resolution.

  Add the predicate edges sorted by the alternative number; I'm fairly
  sure that I could walk the configs backwards so they are added to
  the predDFATarget in the right order, but it's best to make sure.
  Predicates succeed in the order they are specifed.  Alt i wins
  over alt i+1 if both predicates are true.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="initContextTrees(int)"><!-- --></A><H3>
initContextTrees</H3>
<PRE>
protected void <B>initContextTrees</B>(int&nbsp;numberOfAlts)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="max(java.util.Set)"><!-- --></A><H3>
max</H3>
<PRE>
public static int <B>max</B>(java.util.Set&nbsp;s)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../org/antlr/analysis/NonLLStarDecisionException.html" title="class in org.antlr.analysis"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/antlr/analysis/NFAToDFAConverter.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="NFAToDFAConverter.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
