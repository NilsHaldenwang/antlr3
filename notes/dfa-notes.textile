h1. Decisions and DFAs

With respect to ANTLR, what does `decision' mean?

h2. DFA

* DFAs (Deterministic Finite Automata) are objects which simulate finite state machines
* Upon entering a rule method, a recognizer often has to decide between several possible valid input sequences before it can advance the input stream and perform actions
* Sometimes ANTLR generates straight "if/else" or "case" statements to check the input and pick a path, but sometimes it'll outsource the decision to a custom DFA object
* The workhorse of DFA objects is the method <tt>DFA#predict(input)</tt>, which takes the input stream and advances through a series of integer states using a series of tables and lists (described below) generated by ANTLR. If the prediction algorithm can link an input sequence to one of the alternative paths, it'll return the integer number of the matching alternative. Else, if it can't find a matching path from the current input point, it'll raise a NoViableAlternative error.


h2. DFA Parts

* all of these attributes are arrays.
** each index of the array corresponds to a state number
** the value of the array at the state number is a piece of information that is used to predict the next action of the DFA
* [min]: a list of integers where, the value at the current state number is the smallest possible input value to make a transition to another state
* [max]: the largest possible input value to make a transition to another state
* [eot (End of Token)]: If an input value is not within the range specified by min and max, but the integer value positioned at the state number is nonnegative, the value is the next state.
* [eof (End of File/Input)]: If input doesn't fall within the min/max range, and doesn't have an EOT state value, but has a nonnegative integer value positioned at the state number, the value is the number of an accept state which the machine must jump to.
* [special]: sometimes transition tests that are too complicated to be performed by the state machine simulation algorithm. These tests require special coding and are implemented in external methods. So, if need to be performed to make a transition, such as those required by predicates or decisions that have enormous numbers of states, the DFA will know to call the external method if the value of <tt>special</tt> at the current state number is nonnegative. 
* [accept]: if the integer value positioned at the state number is greater than zero, it is the alternative number returned by predict. 
* [transition]: a table where each index corresponds to a state number, s, and the value at position s is an array of length max[s] - min[s]. For current input value, c, transition[s][c - min[s]] is the next state number. 

h2. The prediction algorithm

* before executing the state machine simulation loop, the input stream position is saved and the state number, @s@, is initialized to 0
* then, execution enters the main loop
* each time, the dfa fetches @accept[s]
** if the value is greater than zero, the goal has been reached and the value is the number of the alternative to follow
** iteration stops and @predict@ returns the alternative number
** if the value is zero or negative, the algorithm moves on
* next, the method fetches the next input value, @c@
** for lexers, the value is an integer character value
** for parsers, the value is an integer token type
* the method checks to see if the value of @c@ falls between <tt>max[s]</tt>
** if it does, the next state is <tt>@transition[s][c - @min[s]]</tt>, so @s@ is set to that value and the algorithm skips to the next iteration
** it it doesn't move on
* the method checks to see if <tt>@eot[s]</tt> is 
