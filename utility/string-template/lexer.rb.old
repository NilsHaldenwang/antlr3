#!/usr/bin/ruby
# encoding: utf-8

=begin      ::about::
author:     Kyle Yetter <kcy5b@yahoo.com>
created on: June 07, 2009
purpose:    library: new class
summary:    creates new Lexer class which can be inheritted
            and then specified using a built in DSL
requires:   core/regexp/literal
=end

require 'core/regexp/literal'

class Lexer
  class LexerError < StandardError
    attr_reader :lexer
    def initialize(lexer)
      @lexer = lexer
      location = @lexer.location
      glimpse = @lexer.scanner.string[location.position, 13] + '...'
      message = (
        "unable to match any lexical rule of %s " % @lexer.class.name <<
        "for %s => %p" % [location, glimpse]
      )
      super(message)
    end
  end
  Location = Struct.new(:file, :position, :line, :column) do
    def self.new_file(file)
      self[file, 0, 1, 0]
    end
    def to_s
      'file %s @ (%i:%i)' % [file, line, column]
    end
    def <<(text)
      length     = text.length
      line_count = text.count("\n")
      line_count.zero? ? (self.column += length) :
        (self.column = length - text.rindex("\n") - 1)
      self.line += line_count
      self.position += length
      return self
    end
    def +(text)
      self.dup << text
    end
    def <=>(location)
      position <=> location.position
    end
    include Comparable
  end
  
  Token = Struct.new(:index, :channel, :type, :text, :location) do
    def to_s
      text
    end
    def after
      location + text
    end
    for member in Location.members
      class_eval <<-END, __FILE__, __LINE__
        def #{member}
          l = self.location and return(l.#{member})
        end
      END
    end
    
  end
  
  class Rule
    attr_accessor :name, :channel, :action
    def initialize(name, options = {}, &action)
      @name = name.to_sym
      @channel = options[:channel] || :default
      @action = options[:action] || action
    end
    def match(scanner)
      raise NotImplementedError, "#match must be implemented by subclasses"
    end
  end
  
  class RegexRule < Rule
    attr_accessor :pattern
    def initialize(name, pattern, options = {}, &action)
      super(name, options, &action)
      @pattern = pattern.is_a?(Regexp) ? pattern : Regexp.literal(pattern)
    end
    
    def match(scanner)
      scanner.scan(pattern)
    end
  end
  class DelmiterRule < Rule
    attr_accessor :open, :close, :escape
    def initialize(name, open, close = {}, options = nil, &action)
      @open = open.to_s
      if Hash === close
        @close = open
        options = close
      else
        @close = close.to_s
        options ||= {}
      end
      @escape = (options[:escape] || '\\').to_s
      super(name, options, &action)
      @escape_regexp = Regexp.new( Regexp.escape( @escape ) << '.' )
      @open_regexp   = Regexp.literal( @open )
      @close_regexp  = Regexp.literal( @close )
      @content_pause = Regexp.union( @escape_regexp, @close_regexp )
    end
    
    def match(scanner)
      start_position = scanner.pos
      catch(:nevermind) do
        if scanner.scan(@open_regexp)
          loop do
            throw(:nevermind) unless scanner.skip_until(@content_pause)
            break if scanner.matched == @close
          end
          return(scanner.string[start_position...scanner.pos])
        else return false
        end
      end
      scanner.pos = start_position
      return false
    end
  end
  
  
  class NestedDelimiterRule < DelimiterRule
    def initialize(name, open, close, options = {}, &action)
      super
      @content_pause = Regexp.union(@escape_regexp, @open_regexp, @close_regexp)
    end
    def match(scanner)
      start_position = scanner.pos
      scanner.scan(@open_regexp) or return false
      catch(:nevermind) do
        loop do
          scanner.scan_until(@content_pause) or throw(:nevermind)
          case scanner.matched
          when @escape_regexp then next
          when @close then break
          when @open
            # back up over the open delimiter, and recursively invoke the matching procedure
            scanner.pos -= scanner.matched_size
            match(scanner) or throw(:nevermind)
          else
            raise(<<-END.here_flow! % [@name, scanner.matched, @escape_regexp, @open, @close])
            | this shouldn't happen:
            | rule %p
            | scanner.matched = %p
            | @escape_regexp  = %p
            | @open = %p
            | @close = %p
            END
          end
        end
        return(scanner.string[start_position...scanner.pos])
      end
      scanner.pos = start_position
      return false
    end
    alias :match? :match
  end

  @rules = []
  class << self
    def register(rule, options = {})
      rule.channel = options[:channel] || :default
      rule.action  = options[:action]
      @rules << rule
      return rule
    end
    
    attr_accessor :rules
    def rule(name, pattern, options = {}, &action)
      pattern = Regexp.new(Regexp.escape(pattern.to_s)) unless pattern.is_a?(Regexp)
      name = name.to_s.to_sym unless name.is_a?(Symbol)
      channel = options[:channel] || :default
      action ||= options[:action]
      rule = RegexRule[name, channel, pattern, action]
      @rules << rule
      return rule
    end
    
    def delimited(name, char, *args, &action)
      name = name.to_s.to_sym unless name.is_a?(Symbol)
      open = char.to_s
      options = Hash === args.last ? args.pop : {}
      close = (args.pop || options[:close] || open).to_s
      unless args.empty?
        raise ArgumentError, (<<-END.here_flow! % [name, open, close, options, args] )
        | too many arguments: needs (name, open, close, options = {}, &action) or
        | (name, char, options = {}, &action); have name=%p, open=%p, close=%p,
        | options = %p, and don't know what to do with extra arguments %p
        END
      end
      
      channel = options[:channel] || :default
      escape = (options[:escape] || '\\')
      action ||= options[:action]
      
      rule = DelimiterRule[name, channel, open, close, escape, action]
      @rules << rule
      return rule
    end
    
    def nested(name, open, close, options = {}, &action)
      name = name.to_s.to_sym unless name.is_a?(Symbol)
      open = open.to_s
      close = close.to_s
      
      channel = options[:channel] || :default
      action ||= options[:action]
      
      rule = NestedDelimiterRule[name, channel, open, close, action]
      @rules << rule
      return rule
    end
    
    def keyword(text, options = {}, &action)
      pattern_source = Regexp.escape(text.to_s)
      pattern = /\b#{pattern_source}\b/
      name = (options[:name] || text.to_s.upcase)
      name = name.to_s.to_sym unless name.is_a?(Symbol)
      rule(name, pattern, options, &action)
    end
    
    def inherited(klass)
      klass.rules = @rules.dup
    end
    
    protected :rules=
  end
  
  attr_reader :scanner, :tokens, :location
  attr_accessor :channel
  def initialize(text, options = {})
    file_name = options[:file] || options[:file_name] || '(string)'
    channel   = options[:channel] || :default
    unless location  = options[:location]
      position  = options[:position] || 0
      line      = options[:line] || 1
      column    = options[:column] || 0
      location  = Location.new(file_name, position, line, column)
    end
    
    @scanner = StringScanner.new(text)
    @channel = channel
    @starting_line = @location = location
    @tokens = []
  end
  
  def reset
    @scanner.pos = 0
    @location = @starting_line
    @tokens.clear
  end
  
  def next(tune = true)
    @scanner.eos? and return nil
    for rule in self.rules
      text = rule.match(@scanner) and return matched!(rule, text, tune)
    end
    match_failed!
  end
  
  def token
    @tokens.last
  end
  
  def matched!(rule, text, tune)
    token = Token.new(@tokens.length, rule.channel, rule.name, text, @location)
    @tokens << token
    @location += text
    action = rule.action and instance_eval(&action)
    filter = tune && @channel != token.channel
    return(filter ? self.next(tune) : token)
  end
  private :matched!
  
  def match_failed!
    error = LexerError.new(self)
    raise(error, caller)
  end
  
  private :match_failed!
  
  def [](*args)
    @tokens[*args]
  end
  
  def rules
    self.class.rules
  end
  
  def each(tune = true)
    block_given? or return enum_for(__method__)
    if tune
      @tokens.each { |token| yield(token) }
      while token = self.next
        yield(token)
      end
    else
    end
    return self
  end
  include Enumerable
  
end




