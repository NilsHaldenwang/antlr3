h1. Parser Code and Class Structure

For a @combined@ or pure @parser@ grammar named @Language@, @antlr4ruby@ will generate a parser class. In other ANTLR targets, the generated class is named @LanguageParser@. However, this ruby implementation will generate a top level module named @Language@, which serves as a general namespace for the various entites required by the code. The actual parser class is simply named @Parser@, so the full name of the generated parser will be @Language::Parser@. Consider this combined grammar:

« antlr
grammar AddingMachine;

options {
  language = Ruby;
}

expression returns[ value ]
  : a=NUMBER '+' b=NUMBER { $value = $a.text.to_i + $b.text.to_i }
  | a=NUMBER '-' b=NUMBER { $value = $a.text.to_i - $b.to_i }
  ;

NUMBER: ( '0' .. '9' )+;
SPACE: ' '+ { $channel = HIDDEN };
»

An abbreviated form of the output generated by <code>antlr4ruby AddingMachine.g</code> is shown below:

« ruby
# editted out runtime library require procedure

module AddingMachine
  # TokenData defines all of the token type integer values
  # as constants, which will be included in all 
  # ANTLR-generated recognizers.
  const_defined?(:TokenData) or TokenData = ANTLR3::TokenScheme.new
  
  module TokenData
    # define the token constants
    define_tokens( :NUMBER => 4, :EOF => -1, :SPACE => 5, :T__7 => 7, :T__6 => 6 )

    # register the proper human-readable name or literal value
    # for each token type
    #
    # this is necessary because anonymous tokens, which are
    # created from literal values in the grammar, do not
    # have descriptive names
    register_names( "NUMBER", "SPACE", "'+'", "'-'" )
  end


  class Parser < ANTLR3::Parser
    @grammar_home = AddingMachine

    RULE_METHODS = [ :expression ].freeze

    include TokenData

    generated_using( "./AddingMachine.g", "3.2.1-SNAPSHOT Dec 18, 2009 04:29:28", "1.6.3" )

    def initialize( input, options = {} )
      super( input, options )
    end
    
    # - - - - - - - - - - - - Rules - - - - - - - - - - - - -
    # 
    # parser rule expression
    # 
    # (in ./AddingMachine.g)
    # 7:1: expression returns [ value ] : (a= NUMBER '+' b= NUMBER | a= NUMBER '-' b= NUMBER );
    # 
    def expression
      # editted 50+ lines of recognition logic
    end
    
    # editted out various other support code
  end # class Parser < ANTLR3::Parser
end
»

Thus, the generated code for a parser creates the following named entities:

# @module Language@ - where @Language@ is the name of the input grammar
# @class Language::Parser < ANTLR3::Parser@ - the parser implementation
# @module Language::TokenData@ - an @ANTLR3::TokenScheme@ (subclass of @Module@), which is used to define token types and a token class
# @class Language::TokenData::Token < ANTLR3::CommonToken@ - not apparent in the code above, this class is dynamically created along with @Language::TokenData@

h1. Instantiating Parsers

h2. Providing a Token Stream

A parser must be provided with a stream of tokens to recognize. 

« ruby
lexer = AddingMachine::Lexer.new( "1 + 1" )
tokens = ANTLR3::CommonTokenStream.new( lexer )
parser = AddingMachine::Parser.new( tokens )
»

h2. Providing a Lexer or ANTLR3::TokenSource Object

« ruby
lexer = AddingMachine::Lexer.new( "1 + 1" )
parser = AddingMachine::Parser.new( lexer )
»

h2. Providing an Input String or File

If the parser class is able to automatically figure out which lexer class to use to tokenize the input, the four-step instantiation process can be reduced to a single step as demonstrated below.

« ruby
parser = AddingMachine::Parser.new( "1 + 1" )

parser =
  open( 'sums.txt' ) { | f | AddingMachine::Parser.new( f ) }
»

This can only happen in these circumstances:

* the parser is generated from a *combined* lexer/parser grammar
* the parser class itself has an instance variable named <code>@associated_lexer</code> which has been assigned to a lexer class to use for automatic input tokenization

Since @AddingMachine.g@ is a combined grammar, the sample code above works without any extra work. To demonstrate the second scenario, consider rewriting @AddingMachine@ as a pure parser grammar. While this example is somewhat contrived and impractical, say you would like to define two different lexers -- one for decimal numbers and one for hexadecimal numbers. So you write two different lexers:

« antlr
lexer grammar Decimal;

options { language = Ruby; }

@token::members {
  def value
    return text.to_i
  end
}

NUMBER: ( '0' .. '9' )+;
PLUS: '+';
MINUS: '-';
SPACE: ' '+ { $channel = HIDDEN };
»

« antlr
lexer grammar Hexadecimal;

options {  language = Ruby; }

@token::members {
  def value
    return text.to_i( 16 )
  end
}

NUMBER: ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )+;
PLUS: '+';
MINUS: '-';
SPACE: ' '+ { $channel = HIDDEN };
»

So say you imagine the most common usage scenario for @AddingMachine@ is using decimal numbers. If you still want to use automatic input tokenization, you would write @AddingMachine@ like this:

« antlr
parser grammar AddingMachine;

options {  language = Ruby; }

@members {
  require 'Decimal'
  @associated_lexer = Decimal::Lexer
}

expression returns[ value ]
  : a=NUMBER PLUS  b=NUMBER { $value = $a.value + $b.value }
  | a=NUMBER MINUS b=NUMBER { $value = $a.value - $b.value }
  ;
»

After generating code for all three grammars, the following code will work correctly:

« ruby
require 'AddingMachine'

AddingMachine::Parser.new( "100 - 10" ).expression    # => 90

require 'Hexadecimal'
lexer = Hexadecimal::Lexer.new( "FF - 01" )
AddingMachine::Parser.new( lexer ).expression         # => 254
»

h1. Parser Rules

Each parser rule is implemented as a method of the parser class. Thus, rule @statement@ in grammar @Language.g@ will be implemented as method @Language#statement@.

h2. Rule Method Arguments

ANTLR does allow rules to be specified with arguments. For example:

« antlr
grammar Args;

statement[ include_loops ]
  : { include_loops }? ( loop | conditional )
  | conditional
  ;
»

will produce code that contains

« ruby
def statement( include_loops )
  # a whole bunch of recognition code ...
end
»

Rule argument specification is more limited than ruby's argument specification syntax. Unfortunately, this is beyond my control as a target developer. Rule argument specification is mostly controled by ANTLR's core syntax and the ANTLR tool's semantics, which is somewhat skewed in favor of Java's semantics. Thus,
* arguments may not have default values (as in "<code>include_loops = false</code>")
* you cannot specify "splat" arguments (as in "<code>*args</code>")

h2. Rule Method Visibility

By default, all rule methods are @public@. However, ANTLR permits specifying rule visibility with modifiers @public@, @protected@, or @private@. The generated source code will honor these modifiers, setting the rule method's visibility.

« antlr
grammar Whatevs;

public a      : ID '=' b ;
protected b   : c | ID ;
private c     : NUM | STR ;
»

