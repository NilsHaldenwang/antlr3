/** \file
 *  This C source file was generated by $ANTLR version 3.2.1-SNAPSHOT Dec 18, 2009 04:29:28
 *
 *     -  From the grammar source file : CSS.g
 *     -                            On : 2010-01-02 19:47:03
 *     -                for the parser : CSSParserParser *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "CSSParser.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */
 
#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pCSSParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pCSSParser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pCSSParser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pCSSParser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */
 
#undef	    PARSER		    
#undef	    RECOGNIZER		    
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO		    
#undef		DBG

#define	    PARSER							ctx->pParser  
#define	    RECOGNIZER						PARSER->rec
#define		PSRSTATE						RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)				RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define		MEMOIZE(ri,si)					RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT							PARSER->tstream
#define	    STRSTREAM						INPUT
#define		ISTREAM							INPUT->istream
#define		INDEX()							ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()					(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION						PSRSTATE->exception
#define	    MATCHT(t, fs)					RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()						RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK					    PSRSTATE->following
#define	    FOLLOWPUSH(x)					FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()						FOLLOWSTACK->pop(FOLLOWSTACK)
#define	    PRECOVER()						RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()					RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)							INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)							INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()					RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()						ISTREAM->consume(ISTREAM)
#define	    MARK()							ISTREAM->mark(ISTREAM)
#define	    REWIND(m)						ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()					ISTREAM->rewindLast(ISTREAM)
#define		SEEK(n)							ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY					PSRSTATE->errorRecovery
#define	    FAILEDFLAG						PSRSTATE->failed
#define	    HASFAILED()						(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING					PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger

#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */



/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   CSSParserTokenNames[50+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>", 
        (pANTLR3_UINT8) "<UP>", 
        (pANTLR3_UINT8) "PERCENTAGE",
        (pANTLR3_UINT8) "DIMENSION",
        (pANTLR3_UINT8) "FUNCTION",
        (pANTLR3_UINT8) "INVALID",
        (pANTLR3_UINT8) "ANGLE",
        (pANTLR3_UINT8) "LENGTH",
        (pANTLR3_UINT8) "FREQ",
        (pANTLR3_UINT8) "TIME",
        (pANTLR3_UINT8) "EMS",
        (pANTLR3_UINT8) "EXS",
        (pANTLR3_UINT8) "STRING",
        (pANTLR3_UINT8) "URI",
        (pANTLR3_UINT8) "ID",
        (pANTLR3_UINT8) "HASH",
        (pANTLR3_UINT8) "IMPORTANT",
        (pANTLR3_UINT8) "NUMBER",
        (pANTLR3_UINT8) "WS",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "NEWLINE",
        (pANTLR3_UINT8) "ESCAPE",
        (pANTLR3_UINT8) "PLAIN_ID",
        (pANTLR3_UINT8) "NONASCII",
        (pANTLR3_UINT8) "AT_KEYWORD",
        (pANTLR3_UINT8) "S",
        (pANTLR3_UINT8) "HEX",
        (pANTLR3_UINT8) "UNICODE_RANGE",
        (pANTLR3_UINT8) "DELIM",
        (pANTLR3_UINT8) "'@charset'",
        (pANTLR3_UINT8) "';'",
        (pANTLR3_UINT8) "'<!--'",
        (pANTLR3_UINT8) "'-->'",
        (pANTLR3_UINT8) "'@import'",
        (pANTLR3_UINT8) "'@media'",
        (pANTLR3_UINT8) "'{'",
        (pANTLR3_UINT8) "'}'",
        (pANTLR3_UINT8) "','",
        (pANTLR3_UINT8) "'@page'",
        (pANTLR3_UINT8) "':'",
        (pANTLR3_UINT8) "'+'",
        (pANTLR3_UINT8) "'>'",
        (pANTLR3_UINT8) "'.'",
        (pANTLR3_UINT8) "'*'",
        (pANTLR3_UINT8) "'['",
        (pANTLR3_UINT8) "'='",
        (pANTLR3_UINT8) "'~='",
        (pANTLR3_UINT8) "'|='",
        (pANTLR3_UINT8) "']'",
        (pANTLR3_UINT8) "')'",
        (pANTLR3_UINT8) "'/'",
        (pANTLR3_UINT8) "'-'"
       };

        

// Forward declare the locally static matching functions we have generated.
//
static void	stylesheet    (pCSSParser ctx);
static void	import_statement    (pCSSParser ctx);
static void	media    (pCSSParser ctx);
static void	media_list    (pCSSParser ctx);
static void	page    (pCSSParser ctx);
static void	rule_set    (pCSSParser ctx);
static void	selector    (pCSSParser ctx);
static void	simple_selector    (pCSSParser ctx);
static void	klass    (pCSSParser ctx);
static void	element_name    (pCSSParser ctx);
static void	attrib    (pCSSParser ctx);
static void	pseudo    (pCSSParser ctx);
static void	declaration    (pCSSParser ctx);
static void	expr    (pCSSParser ctx);
static void	term    (pCSSParser ctx);
static void	CSSParserFree(pCSSParser ctx);
/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed. 
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "CSS.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new CSSParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pCSSParser
CSSParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return CSSParserNewSSD(instream, NULL);
}

/** \brief Create a new CSSParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pCSSParser
CSSParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pCSSParser ctx;	    /* Context structure we will build and return   */
    
    ctx	= (pCSSParser) ANTLR3_CALLOC(1, sizeof(CSSParser));
    
    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }
    
    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in CSSParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our CSSParser interface
     */
    ctx->stylesheet	= stylesheet;
    ctx->import_statement	= import_statement;
    ctx->media	= media;
    ctx->media_list	= media_list;
    ctx->page	= page;
    ctx->rule_set	= rule_set;
    ctx->selector	= selector;
    ctx->simple_selector	= simple_selector;
    ctx->klass	= klass;
    ctx->element_name	= element_name;
    ctx->attrib	= attrib;
    ctx->pseudo	= pseudo;
    ctx->declaration	= declaration;
    ctx->expr	= expr;
    ctx->term	= term;
    ctx->free			= CSSParserFree;
    ctx->getGrammarFileName	= getGrammarFileName;
    
    /* Install the scope pushing methods.
     */

        
    

	
    /* Install the token table
     */
    PSRSTATE->tokenNames   = CSSParserTokenNames;
    
    
    /* Return the newly built parser to the caller
     */
    return  ctx;
}

/** Free the parser resources
 */
 static void
 CSSParserFree(pCSSParser ctx)
 {
    /* Free any scope memory
     */
    
        
	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);
    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }
 
/** Return token names used by this parser
 *
 * The returned pointer is used as an index into the token names table (using the token 
 * number as the index).
 * 
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames() 
{
        return CSSParserTokenNames; 
}

    
/* Declare the bitsets
 */

/** Bitset defining follow set for error recovery in rule state: FOLLOW_31_in_stylesheet83  */
static	ANTLR3_BITWORD FOLLOW_31_in_stylesheet83_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_31_in_stylesheet83	= { FOLLOW_31_in_stylesheet83_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_stylesheet85  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_stylesheet85_bits[]	= { ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_stylesheet85	= { FOLLOW_STRING_in_stylesheet85_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_32_in_stylesheet87  */
static	ANTLR3_BITWORD FOLLOW_32_in_stylesheet87_bits[]	= { ANTLR3_UINT64_LIT(0x0000731E00030002) };
static  ANTLR3_BITSET_LIST FOLLOW_32_in_stylesheet87	= { FOLLOW_32_in_stylesheet87_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_stylesheet96  */
static	ANTLR3_BITWORD FOLLOW_set_in_stylesheet96_bits[]	= { ANTLR3_UINT64_LIT(0x0000731E00030002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_stylesheet96	= { FOLLOW_set_in_stylesheet96_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_import_statement_in_stylesheet113  */
static	ANTLR3_BITWORD FOLLOW_import_statement_in_stylesheet113_bits[]	= { ANTLR3_UINT64_LIT(0x0000731E00030002) };
static  ANTLR3_BITSET_LIST FOLLOW_import_statement_in_stylesheet113	= { FOLLOW_import_statement_in_stylesheet113_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_stylesheet115  */
static	ANTLR3_BITWORD FOLLOW_set_in_stylesheet115_bits[]	= { ANTLR3_UINT64_LIT(0x0000731E00030002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_stylesheet115	= { FOLLOW_set_in_stylesheet115_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rule_set_in_stylesheet137  */
static	ANTLR3_BITWORD FOLLOW_rule_set_in_stylesheet137_bits[]	= { ANTLR3_UINT64_LIT(0x0000731600030002) };
static  ANTLR3_BITSET_LIST FOLLOW_rule_set_in_stylesheet137	= { FOLLOW_rule_set_in_stylesheet137_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_media_in_stylesheet141  */
static	ANTLR3_BITWORD FOLLOW_media_in_stylesheet141_bits[]	= { ANTLR3_UINT64_LIT(0x0000731600030002) };
static  ANTLR3_BITSET_LIST FOLLOW_media_in_stylesheet141	= { FOLLOW_media_in_stylesheet141_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_page_in_stylesheet145  */
static	ANTLR3_BITWORD FOLLOW_page_in_stylesheet145_bits[]	= { ANTLR3_UINT64_LIT(0x0000731600030002) };
static  ANTLR3_BITSET_LIST FOLLOW_page_in_stylesheet145	= { FOLLOW_page_in_stylesheet145_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_stylesheet149  */
static	ANTLR3_BITWORD FOLLOW_set_in_stylesheet149_bits[]	= { ANTLR3_UINT64_LIT(0x0000731600030002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_stylesheet149	= { FOLLOW_set_in_stylesheet149_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_35_in_import_statement174  */
static	ANTLR3_BITWORD FOLLOW_35_in_import_statement174_bits[]	= { ANTLR3_UINT64_LIT(0x000000000000C000) };
static  ANTLR3_BITSET_LIST FOLLOW_35_in_import_statement174	= { FOLLOW_35_in_import_statement174_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_import_statement176  */
static	ANTLR3_BITWORD FOLLOW_set_in_import_statement176_bits[]	= { ANTLR3_UINT64_LIT(0x0000000100010000) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_import_statement176	= { FOLLOW_set_in_import_statement176_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_media_list_in_import_statement186  */
static	ANTLR3_BITWORD FOLLOW_media_list_in_import_statement186_bits[]	= { ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_media_list_in_import_statement186	= { FOLLOW_media_list_in_import_statement186_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_32_in_import_statement189  */
static	ANTLR3_BITWORD FOLLOW_32_in_import_statement189_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_32_in_import_statement189	= { FOLLOW_32_in_import_statement189_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_36_in_media202  */
static	ANTLR3_BITWORD FOLLOW_36_in_media202_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_36_in_media202	= { FOLLOW_36_in_media202_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_media_list_in_media204  */
static	ANTLR3_BITWORD FOLLOW_media_list_in_media204_bits[]	= { ANTLR3_UINT64_LIT(0x0000002000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_media_list_in_media204	= { FOLLOW_media_list_in_media204_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_37_in_media206  */
static	ANTLR3_BITWORD FOLLOW_37_in_media206_bits[]	= { ANTLR3_UINT64_LIT(0x0000724000030000) };
static  ANTLR3_BITSET_LIST FOLLOW_37_in_media206	= { FOLLOW_37_in_media206_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rule_set_in_media208  */
static	ANTLR3_BITWORD FOLLOW_rule_set_in_media208_bits[]	= { ANTLR3_UINT64_LIT(0x0000724000030000) };
static  ANTLR3_BITSET_LIST FOLLOW_rule_set_in_media208	= { FOLLOW_rule_set_in_media208_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_38_in_media211  */
static	ANTLR3_BITWORD FOLLOW_38_in_media211_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_38_in_media211	= { FOLLOW_38_in_media211_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_media_list224  */
static	ANTLR3_BITWORD FOLLOW_ID_in_media_list224_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_media_list224	= { FOLLOW_ID_in_media_list224_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_39_in_media_list228  */
static	ANTLR3_BITWORD FOLLOW_39_in_media_list228_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_39_in_media_list228	= { FOLLOW_39_in_media_list228_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_media_list230  */
static	ANTLR3_BITWORD FOLLOW_ID_in_media_list230_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_media_list230	= { FOLLOW_ID_in_media_list230_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_40_in_page246  */
static	ANTLR3_BITWORD FOLLOW_40_in_page246_bits[]	= { ANTLR3_UINT64_LIT(0x0000022000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_40_in_page246	= { FOLLOW_40_in_page246_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_41_in_page250  */
static	ANTLR3_BITWORD FOLLOW_41_in_page250_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_41_in_page250	= { FOLLOW_41_in_page250_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_page252  */
static	ANTLR3_BITWORD FOLLOW_ID_in_page252_bits[]	= { ANTLR3_UINT64_LIT(0x0000002000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_page252	= { FOLLOW_ID_in_page252_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_37_in_page257  */
static	ANTLR3_BITWORD FOLLOW_37_in_page257_bits[]	= { ANTLR3_UINT64_LIT(0x0000004100010000) };
static  ANTLR3_BITSET_LIST FOLLOW_37_in_page257	= { FOLLOW_37_in_page257_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declaration_in_page259  */
static	ANTLR3_BITWORD FOLLOW_declaration_in_page259_bits[]	= { ANTLR3_UINT64_LIT(0x0000004100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_declaration_in_page259	= { FOLLOW_declaration_in_page259_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_32_in_page264  */
static	ANTLR3_BITWORD FOLLOW_32_in_page264_bits[]	= { ANTLR3_UINT64_LIT(0x0000004100010000) };
static  ANTLR3_BITSET_LIST FOLLOW_32_in_page264	= { FOLLOW_32_in_page264_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declaration_in_page266  */
static	ANTLR3_BITWORD FOLLOW_declaration_in_page266_bits[]	= { ANTLR3_UINT64_LIT(0x0000004100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_declaration_in_page266	= { FOLLOW_declaration_in_page266_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_38_in_page272  */
static	ANTLR3_BITWORD FOLLOW_38_in_page272_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_38_in_page272	= { FOLLOW_38_in_page272_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_selector_in_rule_set285  */
static	ANTLR3_BITWORD FOLLOW_selector_in_rule_set285_bits[]	= { ANTLR3_UINT64_LIT(0x000000A000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_selector_in_rule_set285	= { FOLLOW_selector_in_rule_set285_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_39_in_rule_set289  */
static	ANTLR3_BITWORD FOLLOW_39_in_rule_set289_bits[]	= { ANTLR3_UINT64_LIT(0x0000720000030000) };
static  ANTLR3_BITSET_LIST FOLLOW_39_in_rule_set289	= { FOLLOW_39_in_rule_set289_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_selector_in_rule_set291  */
static	ANTLR3_BITWORD FOLLOW_selector_in_rule_set291_bits[]	= { ANTLR3_UINT64_LIT(0x000000A000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_selector_in_rule_set291	= { FOLLOW_selector_in_rule_set291_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_37_in_rule_set300  */
static	ANTLR3_BITWORD FOLLOW_37_in_rule_set300_bits[]	= { ANTLR3_UINT64_LIT(0x0000004100010000) };
static  ANTLR3_BITSET_LIST FOLLOW_37_in_rule_set300	= { FOLLOW_37_in_rule_set300_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declaration_in_rule_set302  */
static	ANTLR3_BITWORD FOLLOW_declaration_in_rule_set302_bits[]	= { ANTLR3_UINT64_LIT(0x0000004100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_declaration_in_rule_set302	= { FOLLOW_declaration_in_rule_set302_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_32_in_rule_set307  */
static	ANTLR3_BITWORD FOLLOW_32_in_rule_set307_bits[]	= { ANTLR3_UINT64_LIT(0x0000004100010000) };
static  ANTLR3_BITSET_LIST FOLLOW_32_in_rule_set307	= { FOLLOW_32_in_rule_set307_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declaration_in_rule_set309  */
static	ANTLR3_BITWORD FOLLOW_declaration_in_rule_set309_bits[]	= { ANTLR3_UINT64_LIT(0x0000004100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_declaration_in_rule_set309	= { FOLLOW_declaration_in_rule_set309_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_38_in_rule_set315  */
static	ANTLR3_BITWORD FOLLOW_38_in_rule_set315_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_38_in_rule_set315	= { FOLLOW_38_in_rule_set315_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simple_selector_in_selector328  */
static	ANTLR3_BITWORD FOLLOW_simple_selector_in_selector328_bits[]	= { ANTLR3_UINT64_LIT(0x00007E0000030002) };
static  ANTLR3_BITSET_LIST FOLLOW_simple_selector_in_selector328	= { FOLLOW_simple_selector_in_selector328_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_selector332  */
static	ANTLR3_BITWORD FOLLOW_set_in_selector332_bits[]	= { ANTLR3_UINT64_LIT(0x0000720000030000) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_selector332	= { FOLLOW_set_in_selector332_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_selector_in_selector343  */
static	ANTLR3_BITWORD FOLLOW_selector_in_selector343_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_selector_in_selector343	= { FOLLOW_selector_in_selector343_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_element_name_in_simple_selector359  */
static	ANTLR3_BITWORD FOLLOW_element_name_in_simple_selector359_bits[]	= { ANTLR3_UINT64_LIT(0x0000720000030002) };
static  ANTLR3_BITSET_LIST FOLLOW_element_name_in_simple_selector359	= { FOLLOW_element_name_in_simple_selector359_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_HASH_in_simple_selector363  */
static	ANTLR3_BITWORD FOLLOW_HASH_in_simple_selector363_bits[]	= { ANTLR3_UINT64_LIT(0x0000720000030002) };
static  ANTLR3_BITSET_LIST FOLLOW_HASH_in_simple_selector363	= { FOLLOW_HASH_in_simple_selector363_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_klass_in_simple_selector367  */
static	ANTLR3_BITWORD FOLLOW_klass_in_simple_selector367_bits[]	= { ANTLR3_UINT64_LIT(0x0000720000030002) };
static  ANTLR3_BITSET_LIST FOLLOW_klass_in_simple_selector367	= { FOLLOW_klass_in_simple_selector367_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_attrib_in_simple_selector371  */
static	ANTLR3_BITWORD FOLLOW_attrib_in_simple_selector371_bits[]	= { ANTLR3_UINT64_LIT(0x0000720000030002) };
static  ANTLR3_BITSET_LIST FOLLOW_attrib_in_simple_selector371	= { FOLLOW_attrib_in_simple_selector371_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_pseudo_in_simple_selector375  */
static	ANTLR3_BITWORD FOLLOW_pseudo_in_simple_selector375_bits[]	= { ANTLR3_UINT64_LIT(0x0000720000030002) };
static  ANTLR3_BITSET_LIST FOLLOW_pseudo_in_simple_selector375	= { FOLLOW_pseudo_in_simple_selector375_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_HASH_in_simple_selector386  */
static	ANTLR3_BITWORD FOLLOW_HASH_in_simple_selector386_bits[]	= { ANTLR3_UINT64_LIT(0x0000720000030002) };
static  ANTLR3_BITSET_LIST FOLLOW_HASH_in_simple_selector386	= { FOLLOW_HASH_in_simple_selector386_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_klass_in_simple_selector390  */
static	ANTLR3_BITWORD FOLLOW_klass_in_simple_selector390_bits[]	= { ANTLR3_UINT64_LIT(0x0000720000030002) };
static  ANTLR3_BITSET_LIST FOLLOW_klass_in_simple_selector390	= { FOLLOW_klass_in_simple_selector390_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_attrib_in_simple_selector394  */
static	ANTLR3_BITWORD FOLLOW_attrib_in_simple_selector394_bits[]	= { ANTLR3_UINT64_LIT(0x0000720000030002) };
static  ANTLR3_BITSET_LIST FOLLOW_attrib_in_simple_selector394	= { FOLLOW_attrib_in_simple_selector394_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_pseudo_in_simple_selector398  */
static	ANTLR3_BITWORD FOLLOW_pseudo_in_simple_selector398_bits[]	= { ANTLR3_UINT64_LIT(0x0000720000030002) };
static  ANTLR3_BITSET_LIST FOLLOW_pseudo_in_simple_selector398	= { FOLLOW_pseudo_in_simple_selector398_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_44_in_klass414  */
static	ANTLR3_BITWORD FOLLOW_44_in_klass414_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_44_in_klass414	= { FOLLOW_44_in_klass414_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_klass416  */
static	ANTLR3_BITWORD FOLLOW_ID_in_klass416_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_klass416	= { FOLLOW_ID_in_klass416_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_element_name0  */
static	ANTLR3_BITWORD FOLLOW_set_in_element_name0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_element_name0	= { FOLLOW_set_in_element_name0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_46_in_attrib446  */
static	ANTLR3_BITWORD FOLLOW_46_in_attrib446_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_46_in_attrib446	= { FOLLOW_46_in_attrib446_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_attrib448  */
static	ANTLR3_BITWORD FOLLOW_ID_in_attrib448_bits[]	= { ANTLR3_UINT64_LIT(0x0007800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_attrib448	= { FOLLOW_ID_in_attrib448_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_attrib452  */
static	ANTLR3_BITWORD FOLLOW_set_in_attrib452_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000014000) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_attrib452	= { FOLLOW_set_in_attrib452_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_attrib466  */
static	ANTLR3_BITWORD FOLLOW_set_in_attrib466_bits[]	= { ANTLR3_UINT64_LIT(0x0004000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_attrib466	= { FOLLOW_set_in_attrib466_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_50_in_attrib479  */
static	ANTLR3_BITWORD FOLLOW_50_in_attrib479_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_50_in_attrib479	= { FOLLOW_50_in_attrib479_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_41_in_pseudo492  */
static	ANTLR3_BITWORD FOLLOW_41_in_pseudo492_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010040) };
static  ANTLR3_BITSET_LIST FOLLOW_41_in_pseudo492	= { FOLLOW_41_in_pseudo492_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_pseudo496  */
static	ANTLR3_BITWORD FOLLOW_ID_in_pseudo496_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_pseudo496	= { FOLLOW_ID_in_pseudo496_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FUNCTION_in_pseudo500  */
static	ANTLR3_BITWORD FOLLOW_FUNCTION_in_pseudo500_bits[]	= { ANTLR3_UINT64_LIT(0x0008000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_FUNCTION_in_pseudo500	= { FOLLOW_FUNCTION_in_pseudo500_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_pseudo502  */
static	ANTLR3_BITWORD FOLLOW_ID_in_pseudo502_bits[]	= { ANTLR3_UINT64_LIT(0x0008000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_pseudo502	= { FOLLOW_ID_in_pseudo502_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_51_in_pseudo505  */
static	ANTLR3_BITWORD FOLLOW_51_in_pseudo505_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_51_in_pseudo505	= { FOLLOW_51_in_pseudo505_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_declaration520  */
static	ANTLR3_BITWORD FOLLOW_ID_in_declaration520_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_declaration520	= { FOLLOW_ID_in_declaration520_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_41_in_declaration522  */
static	ANTLR3_BITWORD FOLLOW_41_in_declaration522_bits[]	= { ANTLR3_UINT64_LIT(0x00200400000BFF50) };
static  ANTLR3_BITSET_LIST FOLLOW_41_in_declaration522	= { FOLLOW_41_in_declaration522_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_declaration524  */
static	ANTLR3_BITWORD FOLLOW_expr_in_declaration524_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040002) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_declaration524	= { FOLLOW_expr_in_declaration524_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IMPORTANT_in_declaration526  */
static	ANTLR3_BITWORD FOLLOW_IMPORTANT_in_declaration526_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IMPORTANT_in_declaration526	= { FOLLOW_IMPORTANT_in_declaration526_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_expr540  */
static	ANTLR3_BITWORD FOLLOW_term_in_expr540_bits[]	= { ANTLR3_UINT64_LIT(0x00300480000BFF52) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_expr540	= { FOLLOW_term_in_expr540_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_expr544  */
static	ANTLR3_BITWORD FOLLOW_set_in_expr544_bits[]	= { ANTLR3_UINT64_LIT(0x00200400000BFF50) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_expr544	= { FOLLOW_set_in_expr544_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_expr555  */
static	ANTLR3_BITWORD FOLLOW_term_in_expr555_bits[]	= { ANTLR3_UINT64_LIT(0x00300480000BFF52) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_expr555	= { FOLLOW_term_in_expr555_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_term571  */
static	ANTLR3_BITWORD FOLLOW_set_in_term571_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000083F10) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_term571	= { FOLLOW_set_in_term571_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_term582  */
static	ANTLR3_BITWORD FOLLOW_set_in_term582_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_term582	= { FOLLOW_set_in_term582_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_term620  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_term620_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_term620	= { FOLLOW_STRING_in_term620_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_term626  */
static	ANTLR3_BITWORD FOLLOW_ID_in_term626_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_term626	= { FOLLOW_ID_in_term626_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_URI_in_term632  */
static	ANTLR3_BITWORD FOLLOW_URI_in_term632_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_URI_in_term632	= { FOLLOW_URI_in_term632_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_HASH_in_term638  */
static	ANTLR3_BITWORD FOLLOW_HASH_in_term638_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_HASH_in_term638	= { FOLLOW_HASH_in_term638_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FUNCTION_in_term650  */
static	ANTLR3_BITWORD FOLLOW_FUNCTION_in_term650_bits[]	= { ANTLR3_UINT64_LIT(0x00200400000BFF50) };
static  ANTLR3_BITSET_LIST FOLLOW_FUNCTION_in_term650	= { FOLLOW_FUNCTION_in_term650_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_term652  */
static	ANTLR3_BITWORD FOLLOW_expr_in_term652_bits[]	= { ANTLR3_UINT64_LIT(0x0008000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_term652	= { FOLLOW_expr_in_term652_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_51_in_term654  */
static	ANTLR3_BITWORD FOLLOW_51_in_term654_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_51_in_term654	= { FOLLOW_51_in_term654_bits, 1	};
     

 
 
/* ==============================================
 * Parsing rules
 */
/** 
 * $ANTLR start stylesheet
 * CSS.g:20:1: stylesheet : ( '@charset' STRING ';' )? ( '<!--' | '-->' )* ( import_statement ( '<!--' | '-->' )* )* ( ( rule_set | media | page ) ( '<!--' | '-->' )* )* ;
 */
static void
stylesheet(pCSSParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // CSS.g:21:3: ( ( '@charset' STRING ';' )? ( '<!--' | '-->' )* ( import_statement ( '<!--' | '-->' )* )* ( ( rule_set | media | page ) ( '<!--' | '-->' )* )* )
        // CSS.g:21:5: ( '@charset' STRING ';' )? ( '<!--' | '-->' )* ( import_statement ( '<!--' | '-->' )* )* ( ( rule_set | media | page ) ( '<!--' | '-->' )* )*
        {

            // CSS.g:21:5: ( '@charset' STRING ';' )?
            {
                int alt1=2;
                switch ( LA(1) ) 
                {
                    case 31:
                    	{
                    		alt1=1;
                    	}
                        break;
                }

                switch (alt1) 
                {
            	case 1:
            	    // CSS.g:21:7: '@charset' STRING ';'
            	    {
            	         MATCHT(31, &FOLLOW_31_in_stylesheet83); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestylesheetEx;
            	        }

            	         MATCHT(STRING, &FOLLOW_STRING_in_stylesheet85); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestylesheetEx;
            	        }

            	         MATCHT(32, &FOLLOW_32_in_stylesheet87); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestylesheetEx;
            	        }


            	    }
            	    break;

                }
            }

            // CSS.g:22:5: ( '<!--' | '-->' )*

            for (;;)
            {
                int alt2=2;
                switch ( LA(1) ) 
                {
                case 33:
                case 34:
                	{
                		alt2=1;
                	}
                    break;

                }

                switch (alt2) 
                {
            	case 1:
            	    // CSS.g:
            	    {
            	        if ( ((LA(1) >= 33) && (LA(1) <= 34)) )
            	        {
            	            CONSUME();
            	            PERRORRECOVERY=ANTLR3_FALSE;
            	        }
            	        else 
            	        {
            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = &FOLLOW_set_in_stylesheet96;
            	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_stylesheet96);    goto rulestylesheetEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop2;	/* break out of the loop */
            	    break;
                }
            }
            loop2: ; /* Jump out to here if this rule does not match */


            // CSS.g:23:5: ( import_statement ( '<!--' | '-->' )* )*

            for (;;)
            {
                int alt4=2;
                switch ( LA(1) ) 
                {
                case 35:
                	{
                		alt4=1;
                	}
                    break;

                }

                switch (alt4) 
                {
            	case 1:
            	    // CSS.g:23:7: import_statement ( '<!--' | '-->' )*
            	    {
            	        FOLLOWPUSH(FOLLOW_import_statement_in_stylesheet113);
            	        import_statement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestylesheetEx;
            	        }


            	        // CSS.g:23:24: ( '<!--' | '-->' )*

            	        for (;;)
            	        {
            	            int alt3=2;
            	            switch ( LA(1) ) 
            	            {
            	            case 33:
            	            case 34:
            	            	{
            	            		alt3=1;
            	            	}
            	                break;

            	            }

            	            switch (alt3) 
            	            {
            	        	case 1:
            	        	    // CSS.g:
            	        	    {
            	        	        if ( ((LA(1) >= 33) && (LA(1) <= 34)) )
            	        	        {
            	        	            CONSUME();
            	        	            PERRORRECOVERY=ANTLR3_FALSE;
            	        	        }
            	        	        else 
            	        	        {
            	        	            CONSTRUCTEX();
            	        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	        	            EXCEPTION->expectingSet = &FOLLOW_set_in_stylesheet115;
            	        	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_stylesheet115);    goto rulestylesheetEx;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop3;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop3: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

            	default:
            	    goto loop4;	/* break out of the loop */
            	    break;
                }
            }
            loop4: ; /* Jump out to here if this rule does not match */


            // CSS.g:24:5: ( ( rule_set | media | page ) ( '<!--' | '-->' )* )*

            for (;;)
            {
                int alt7=2;
                switch ( LA(1) ) 
                {
                case ID:
                case HASH:
                case 36:
                case 40:
                case 41:
                case 44:
                case 45:
                case 46:
                	{
                		alt7=1;
                	}
                    break;

                }

                switch (alt7) 
                {
            	case 1:
            	    // CSS.g:24:7: ( rule_set | media | page ) ( '<!--' | '-->' )*
            	    {

            	        // CSS.g:24:7: ( rule_set | media | page )
            	        {
            	            int alt5=3;
            	            switch ( LA(1) ) 
            	            {
            	            case ID:
            	            case HASH:
            	            case 41:
            	            case 44:
            	            case 45:
            	            case 46:
            	            	{
            	            		alt5=1;
            	            	}
            	                break;
            	            case 36:
            	            	{
            	            		alt5=2;
            	            	}
            	                break;
            	            case 40:
            	            	{
            	            		alt5=3;
            	            	}
            	                break;

            	            default:
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 5;
            	                EXCEPTION->state        = 0;


            	                goto rulestylesheetEx;
            	            }

            	            switch (alt5) 
            	            {
            	        	case 1:
            	        	    // CSS.g:24:9: rule_set
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_rule_set_in_stylesheet137);
            	        	        rule_set(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulestylesheetEx;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // CSS.g:24:20: media
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_media_in_stylesheet141);
            	        	        media(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulestylesheetEx;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 3:
            	        	    // CSS.g:24:28: page
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_page_in_stylesheet145);
            	        	        page(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulestylesheetEx;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // CSS.g:24:35: ( '<!--' | '-->' )*

            	        for (;;)
            	        {
            	            int alt6=2;
            	            switch ( LA(1) ) 
            	            {
            	            case 33:
            	            case 34:
            	            	{
            	            		alt6=1;
            	            	}
            	                break;

            	            }

            	            switch (alt6) 
            	            {
            	        	case 1:
            	        	    // CSS.g:
            	        	    {
            	        	        if ( ((LA(1) >= 33) && (LA(1) <= 34)) )
            	        	        {
            	        	            CONSUME();
            	        	            PERRORRECOVERY=ANTLR3_FALSE;
            	        	        }
            	        	        else 
            	        	        {
            	        	            CONSTRUCTEX();
            	        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	        	            EXCEPTION->expectingSet = &FOLLOW_set_in_stylesheet149;
            	        	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_stylesheet149);    goto rulestylesheetEx;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop6;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop6: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

            	default:
            	    goto loop7;	/* break out of the loop */
            	    break;
                }
            }
            loop7: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulestylesheetEx; /* Prevent compiler warnings */
    rulestylesheetEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end stylesheet */

/** 
 * $ANTLR start import_statement
 * CSS.g:27:1: import_statement : '@import' ( STRING | URI ) ( media_list )? ';' ;
 */
static void
import_statement(pCSSParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // CSS.g:28:3: ( '@import' ( STRING | URI ) ( media_list )? ';' )
        // CSS.g:28:5: '@import' ( STRING | URI ) ( media_list )? ';'
        {
             MATCHT(35, &FOLLOW_35_in_import_statement174); 
            if  (HASEXCEPTION())
            {
                goto ruleimport_statementEx;
            }

            if ( ((LA(1) >= STRING) && (LA(1) <= URI)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_import_statement176;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_import_statement176);    goto ruleimport_statementEx;
            }


            // CSS.g:28:32: ( media_list )?
            {
                int alt8=2;
                switch ( LA(1) ) 
                {
                    case ID:
                    	{
                    		alt8=1;
                    	}
                        break;
                }

                switch (alt8) 
                {
            	case 1:
            	    // CSS.g:28:32: media_list
            	    {
            	        FOLLOWPUSH(FOLLOW_media_list_in_import_statement186);
            	        media_list(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleimport_statementEx;
            	        }


            	    }
            	    break;

                }
            }
             MATCHT(32, &FOLLOW_32_in_import_statement189); 
            if  (HASEXCEPTION())
            {
                goto ruleimport_statementEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleimport_statementEx; /* Prevent compiler warnings */
    ruleimport_statementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end import_statement */

/** 
 * $ANTLR start media
 * CSS.g:31:1: media : '@media' media_list '{' ( rule_set )* '}' ;
 */
static void
media(pCSSParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // CSS.g:32:3: ( '@media' media_list '{' ( rule_set )* '}' )
        // CSS.g:32:5: '@media' media_list '{' ( rule_set )* '}'
        {
             MATCHT(36, &FOLLOW_36_in_media202); 
            if  (HASEXCEPTION())
            {
                goto rulemediaEx;
            }

            FOLLOWPUSH(FOLLOW_media_list_in_media204);
            media_list(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemediaEx;
            }

             MATCHT(37, &FOLLOW_37_in_media206); 
            if  (HASEXCEPTION())
            {
                goto rulemediaEx;
            }


            // CSS.g:32:29: ( rule_set )*

            for (;;)
            {
                int alt9=2;
                switch ( LA(1) ) 
                {
                case ID:
                case HASH:
                case 41:
                case 44:
                case 45:
                case 46:
                	{
                		alt9=1;
                	}
                    break;

                }

                switch (alt9) 
                {
            	case 1:
            	    // CSS.g:32:29: rule_set
            	    {
            	        FOLLOWPUSH(FOLLOW_rule_set_in_media208);
            	        rule_set(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemediaEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop9;	/* break out of the loop */
            	    break;
                }
            }
            loop9: ; /* Jump out to here if this rule does not match */

             MATCHT(38, &FOLLOW_38_in_media211); 
            if  (HASEXCEPTION())
            {
                goto rulemediaEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulemediaEx; /* Prevent compiler warnings */
    rulemediaEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end media */

/** 
 * $ANTLR start media_list
 * CSS.g:35:1: media_list : ID ( ',' ID )* ;
 */
static void
media_list(pCSSParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // CSS.g:36:3: ( ID ( ',' ID )* )
        // CSS.g:36:5: ID ( ',' ID )*
        {
             MATCHT(ID, &FOLLOW_ID_in_media_list224); 
            if  (HASEXCEPTION())
            {
                goto rulemedia_listEx;
            }


            // CSS.g:36:8: ( ',' ID )*

            for (;;)
            {
                int alt10=2;
                switch ( LA(1) ) 
                {
                case 39:
                	{
                		alt10=1;
                	}
                    break;

                }

                switch (alt10) 
                {
            	case 1:
            	    // CSS.g:36:10: ',' ID
            	    {
            	         MATCHT(39, &FOLLOW_39_in_media_list228); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemedia_listEx;
            	        }

            	         MATCHT(ID, &FOLLOW_ID_in_media_list230); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemedia_listEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop10;	/* break out of the loop */
            	    break;
                }
            }
            loop10: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulemedia_listEx; /* Prevent compiler warnings */
    rulemedia_listEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end media_list */

/** 
 * $ANTLR start page
 * CSS.g:39:1: page : '@page' ( ':' ID )? '{' ( declaration )? ( ';' ( declaration )? )* '}' ;
 */
static void
page(pCSSParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // CSS.g:40:3: ( '@page' ( ':' ID )? '{' ( declaration )? ( ';' ( declaration )? )* '}' )
        // CSS.g:40:5: '@page' ( ':' ID )? '{' ( declaration )? ( ';' ( declaration )? )* '}'
        {
             MATCHT(40, &FOLLOW_40_in_page246); 
            if  (HASEXCEPTION())
            {
                goto rulepageEx;
            }


            // CSS.g:40:13: ( ':' ID )?
            {
                int alt11=2;
                switch ( LA(1) ) 
                {
                    case 41:
                    	{
                    		alt11=1;
                    	}
                        break;
                }

                switch (alt11) 
                {
            	case 1:
            	    // CSS.g:40:15: ':' ID
            	    {
            	         MATCHT(41, &FOLLOW_41_in_page250); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepageEx;
            	        }

            	         MATCHT(ID, &FOLLOW_ID_in_page252); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepageEx;
            	        }


            	    }
            	    break;

                }
            }
             MATCHT(37, &FOLLOW_37_in_page257); 
            if  (HASEXCEPTION())
            {
                goto rulepageEx;
            }


            // CSS.g:40:29: ( declaration )?
            {
                int alt12=2;
                switch ( LA(1) ) 
                {
                    case ID:
                    	{
                    		alt12=1;
                    	}
                        break;
                }

                switch (alt12) 
                {
            	case 1:
            	    // CSS.g:40:29: declaration
            	    {
            	        FOLLOWPUSH(FOLLOW_declaration_in_page259);
            	        declaration(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepageEx;
            	        }


            	    }
            	    break;

                }
            }

            // CSS.g:40:42: ( ';' ( declaration )? )*

            for (;;)
            {
                int alt14=2;
                switch ( LA(1) ) 
                {
                case 32:
                	{
                		alt14=1;
                	}
                    break;

                }

                switch (alt14) 
                {
            	case 1:
            	    // CSS.g:40:44: ';' ( declaration )?
            	    {
            	         MATCHT(32, &FOLLOW_32_in_page264); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepageEx;
            	        }


            	        // CSS.g:40:48: ( declaration )?
            	        {
            	            int alt13=2;
            	            switch ( LA(1) ) 
            	            {
            	                case ID:
            	                	{
            	                		alt13=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt13) 
            	            {
            	        	case 1:
            	        	    // CSS.g:40:48: declaration
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_declaration_in_page266);
            	        	        declaration(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulepageEx;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

            	default:
            	    goto loop14;	/* break out of the loop */
            	    break;
                }
            }
            loop14: ; /* Jump out to here if this rule does not match */

             MATCHT(38, &FOLLOW_38_in_page272); 
            if  (HASEXCEPTION())
            {
                goto rulepageEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepageEx; /* Prevent compiler warnings */
    rulepageEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end page */

/** 
 * $ANTLR start rule_set
 * CSS.g:43:1: rule_set : selector ( ',' selector )* '{' ( declaration )? ( ';' ( declaration )? )* '}' ;
 */
static void
rule_set(pCSSParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // CSS.g:44:3: ( selector ( ',' selector )* '{' ( declaration )? ( ';' ( declaration )? )* '}' )
        // CSS.g:44:5: selector ( ',' selector )* '{' ( declaration )? ( ';' ( declaration )? )* '}'
        {
            FOLLOWPUSH(FOLLOW_selector_in_rule_set285);
            selector(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerule_setEx;
            }


            // CSS.g:44:14: ( ',' selector )*

            for (;;)
            {
                int alt15=2;
                switch ( LA(1) ) 
                {
                case 39:
                	{
                		alt15=1;
                	}
                    break;

                }

                switch (alt15) 
                {
            	case 1:
            	    // CSS.g:44:16: ',' selector
            	    {
            	         MATCHT(39, &FOLLOW_39_in_rule_set289); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerule_setEx;
            	        }

            	        FOLLOWPUSH(FOLLOW_selector_in_rule_set291);
            	        selector(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerule_setEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop15;	/* break out of the loop */
            	    break;
                }
            }
            loop15: ; /* Jump out to here if this rule does not match */

             MATCHT(37, &FOLLOW_37_in_rule_set300); 
            if  (HASEXCEPTION())
            {
                goto rulerule_setEx;
            }


            // CSS.g:45:9: ( declaration )?
            {
                int alt16=2;
                switch ( LA(1) ) 
                {
                    case ID:
                    	{
                    		alt16=1;
                    	}
                        break;
                }

                switch (alt16) 
                {
            	case 1:
            	    // CSS.g:45:9: declaration
            	    {
            	        FOLLOWPUSH(FOLLOW_declaration_in_rule_set302);
            	        declaration(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerule_setEx;
            	        }


            	    }
            	    break;

                }
            }

            // CSS.g:45:22: ( ';' ( declaration )? )*

            for (;;)
            {
                int alt18=2;
                switch ( LA(1) ) 
                {
                case 32:
                	{
                		alt18=1;
                	}
                    break;

                }

                switch (alt18) 
                {
            	case 1:
            	    // CSS.g:45:24: ';' ( declaration )?
            	    {
            	         MATCHT(32, &FOLLOW_32_in_rule_set307); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerule_setEx;
            	        }


            	        // CSS.g:45:28: ( declaration )?
            	        {
            	            int alt17=2;
            	            switch ( LA(1) ) 
            	            {
            	                case ID:
            	                	{
            	                		alt17=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt17) 
            	            {
            	        	case 1:
            	        	    // CSS.g:45:28: declaration
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_declaration_in_rule_set309);
            	        	        declaration(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulerule_setEx;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

            	default:
            	    goto loop18;	/* break out of the loop */
            	    break;
                }
            }
            loop18: ; /* Jump out to here if this rule does not match */

             MATCHT(38, &FOLLOW_38_in_rule_set315); 
            if  (HASEXCEPTION())
            {
                goto rulerule_setEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulerule_setEx; /* Prevent compiler warnings */
    rulerule_setEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end rule_set */

/** 
 * $ANTLR start selector
 * CSS.g:48:1: selector : simple_selector ( ( '+' | '>' )? selector )? ;
 */
static void
selector(pCSSParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // CSS.g:49:3: ( simple_selector ( ( '+' | '>' )? selector )? )
        // CSS.g:49:5: simple_selector ( ( '+' | '>' )? selector )?
        {
            FOLLOWPUSH(FOLLOW_simple_selector_in_selector328);
            simple_selector(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleselectorEx;
            }


            // CSS.g:49:21: ( ( '+' | '>' )? selector )?
            {
                int alt20=2;
                switch ( LA(1) ) 
                {
                    case ID:
                    case HASH:
                    case 41:
                    case 42:
                    case 43:
                    case 44:
                    case 45:
                    case 46:
                    	{
                    		alt20=1;
                    	}
                        break;
                }

                switch (alt20) 
                {
            	case 1:
            	    // CSS.g:49:23: ( '+' | '>' )? selector
            	    {

            	        // CSS.g:49:23: ( '+' | '>' )?
            	        {
            	            int alt19=2;
            	            switch ( LA(1) ) 
            	            {
            	                case 42:
            	                case 43:
            	                	{
            	                		alt19=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt19) 
            	            {
            	        	case 1:
            	        	    // CSS.g:
            	        	    {
            	        	        if ( ((LA(1) >= 42) && (LA(1) <= 43)) )
            	        	        {
            	        	            CONSUME();
            	        	            PERRORRECOVERY=ANTLR3_FALSE;
            	        	        }
            	        	        else 
            	        	        {
            	        	            CONSTRUCTEX();
            	        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	        	            EXCEPTION->expectingSet = &FOLLOW_set_in_selector332;
            	        	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_selector332);    goto ruleselectorEx;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }
            	        FOLLOWPUSH(FOLLOW_selector_in_selector343);
            	        selector(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleselectorEx;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleselectorEx; /* Prevent compiler warnings */
    ruleselectorEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end selector */

/** 
 * $ANTLR start simple_selector
 * CSS.g:52:1: simple_selector : ( element_name ( HASH | klass | attrib | pseudo )* | ( HASH | klass | attrib | pseudo )+ );
 */
static void
simple_selector(pCSSParser ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  CSS.g:53:3: ( element_name ( HASH | klass | attrib | pseudo )* | ( HASH | klass | attrib | pseudo )+ )
            
            ANTLR3_UINT32 alt23;

            alt23=2;

            switch ( LA(1) ) 
            {
            case ID:
            case 45:
            	{
            		alt23=1;
            	}
                break;
            case HASH:
            case 41:
            case 44:
            case 46:
            	{
            		alt23=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 23;
                EXCEPTION->state        = 0;


                goto rulesimple_selectorEx;
            }

            switch (alt23) 
            {
        	case 1:
        	    // CSS.g:53:5: element_name ( HASH | klass | attrib | pseudo )*
        	    {
        	        FOLLOWPUSH(FOLLOW_element_name_in_simple_selector359);
        	        element_name(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimple_selectorEx;
        	        }


        	        // CSS.g:53:18: ( HASH | klass | attrib | pseudo )*

        	        for (;;)
        	        {
        	            int alt21=5;
        	            switch ( LA(1) ) 
        	            {
        	            case HASH:
        	            	{
        	            		alt21=1;
        	            	}
        	                break;
        	            case 44:
        	            	{
        	            		switch ( LA(2) ) 
        	            		{
        	            		case ID:
        	            			{
        	            				alt21=2;
        	            			}
        	            		    break;

        	            		}

        	            	}
        	                break;
        	            case 46:
        	            	{
        	            		switch ( LA(2) ) 
        	            		{
        	            		case ID:
        	            			{
        	            				switch ( LA(3) ) 
        	            				{
        	            				case 47:
        	            				case 48:
        	            				case 49:
        	            					{
        	            						switch ( LA(4) ) 
        	            						{
        	            						case STRING:
        	            						case ID:
        	            							{
        	            								switch ( LA(5) ) 
        	            								{
        	            								case 50:
        	            									{
        	            										alt21=3;
        	            									}
        	            								    break;

        	            								}

        	            							}
        	            						    break;

        	            						}

        	            					}
        	            				    break;
        	            				case 50:
        	            					{
        	            						alt21=3;
        	            					}
        	            				    break;

        	            				}

        	            			}
        	            		    break;

        	            		}

        	            	}
        	                break;
        	            case 41:
        	            	{
        	            		switch ( LA(2) ) 
        	            		{
        	            		case ID:
        	            			{
        	            				alt21=4;
        	            			}
        	            		    break;
        	            		case FUNCTION:
        	            			{
        	            				switch ( LA(3) ) 
        	            				{
        	            				case ID:
        	            					{
        	            						switch ( LA(4) ) 
        	            						{
        	            						case 51:
        	            							{
        	            								alt21=4;
        	            							}
        	            						    break;

        	            						}

        	            					}
        	            				    break;
        	            				case 51:
        	            					{
        	            						alt21=4;
        	            					}
        	            				    break;

        	            				}

        	            			}
        	            		    break;

        	            		}

        	            	}
        	                break;

        	            }

        	            switch (alt21) 
        	            {
        	        	case 1:
        	        	    // CSS.g:53:20: HASH
        	        	    {
        	        	         MATCHT(HASH, &FOLLOW_HASH_in_simple_selector363); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesimple_selectorEx;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // CSS.g:53:27: klass
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_klass_in_simple_selector367);
        	        	        klass(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesimple_selectorEx;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // CSS.g:53:35: attrib
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_attrib_in_simple_selector371);
        	        	        attrib(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesimple_selectorEx;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 4:
        	        	    // CSS.g:53:44: pseudo
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_pseudo_in_simple_selector375);
        	        	        pseudo(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesimple_selectorEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop21;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop21: ; /* Jump out to here if this rule does not match */


        	    }
        	    break;
        	case 2:
        	    // CSS.g:54:5: ( HASH | klass | attrib | pseudo )+
        	    {
        	        // CSS.g:54:5: ( HASH | klass | attrib | pseudo )+
        	        {
        	            int cnt22=0;

        	            for (;;)
        	            {
        	                int alt22=5;
        	        	switch ( LA(1) ) 
        	        	{
        	        	case HASH:
        	        		{
        	        			alt22=1;
        	        		}
        	        	    break;
        	        	case 44:
        	        		{
        	        			alt22=2;
        	        		}
        	        	    break;
        	        	case 46:
        	        		{
        	        			alt22=3;
        	        		}
        	        	    break;
        	        	case 41:
        	        		{
        	        			alt22=4;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt22) 
        	        	{
        	        	    case 1:
        	        	        // CSS.g:54:7: HASH
        	        	        {
        	        	             MATCHT(HASH, &FOLLOW_HASH_in_simple_selector386); 
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulesimple_selectorEx;
        	        	            }


        	        	        }
        	        	        break;
        	        	    case 2:
        	        	        // CSS.g:54:14: klass
        	        	        {
        	        	            FOLLOWPUSH(FOLLOW_klass_in_simple_selector390);
        	        	            klass(ctx);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulesimple_selectorEx;
        	        	            }


        	        	        }
        	        	        break;
        	        	    case 3:
        	        	        // CSS.g:54:22: attrib
        	        	        {
        	        	            FOLLOWPUSH(FOLLOW_attrib_in_simple_selector394);
        	        	            attrib(ctx);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulesimple_selectorEx;
        	        	            }


        	        	        }
        	        	        break;
        	        	    case 4:
        	        	        // CSS.g:54:31: pseudo
        	        	        {
        	        	            FOLLOWPUSH(FOLLOW_pseudo_in_simple_selector398);
        	        	            pseudo(ctx);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulesimple_selectorEx;
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:
        	        	    
        	        		if ( cnt22 >= 1 )
        	        		{
        	        		    goto loop22;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto rulesimple_selectorEx;
        	        	}
        	        	cnt22++;
        	            }
        	            loop22: ;	/* Jump to here if this rule does not match */
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulesimple_selectorEx; /* Prevent compiler warnings */
    rulesimple_selectorEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end simple_selector */

/** 
 * $ANTLR start klass
 * CSS.g:57:1: klass : '.' ID ;
 */
static void
klass(pCSSParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // CSS.g:58:3: ( '.' ID )
        // CSS.g:58:5: '.' ID
        {
             MATCHT(44, &FOLLOW_44_in_klass414); 
            if  (HASEXCEPTION())
            {
                goto ruleklassEx;
            }

             MATCHT(ID, &FOLLOW_ID_in_klass416); 
            if  (HASEXCEPTION())
            {
                goto ruleklassEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleklassEx; /* Prevent compiler warnings */
    ruleklassEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end klass */

/** 
 * $ANTLR start element_name
 * CSS.g:61:1: element_name : ( ID | '*' );
 */
static void
element_name(pCSSParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // CSS.g:62:3: ( ID | '*' )
        // CSS.g:
        {
            if ( LA(1) == ID || LA(1) == 45 )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_element_name0;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_element_name0);    goto ruleelement_nameEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleelement_nameEx; /* Prevent compiler warnings */
    ruleelement_nameEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end element_name */

/** 
 * $ANTLR start attrib
 * CSS.g:65:1: attrib : '[' ID ( ( '=' | '~=' | '|=' ) ( ID | STRING ) )? ']' ;
 */
static void
attrib(pCSSParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // CSS.g:66:3: ( '[' ID ( ( '=' | '~=' | '|=' ) ( ID | STRING ) )? ']' )
        // CSS.g:66:5: '[' ID ( ( '=' | '~=' | '|=' ) ( ID | STRING ) )? ']'
        {
             MATCHT(46, &FOLLOW_46_in_attrib446); 
            if  (HASEXCEPTION())
            {
                goto ruleattribEx;
            }

             MATCHT(ID, &FOLLOW_ID_in_attrib448); 
            if  (HASEXCEPTION())
            {
                goto ruleattribEx;
            }


            // CSS.g:66:12: ( ( '=' | '~=' | '|=' ) ( ID | STRING ) )?
            {
                int alt24=2;
                switch ( LA(1) ) 
                {
                    case 47:
                    case 48:
                    case 49:
                    	{
                    		alt24=1;
                    	}
                        break;
                }

                switch (alt24) 
                {
            	case 1:
            	    // CSS.g:66:14: ( '=' | '~=' | '|=' ) ( ID | STRING )
            	    {
            	        if ( ((LA(1) >= 47) && (LA(1) <= 49)) )
            	        {
            	            CONSUME();
            	            PERRORRECOVERY=ANTLR3_FALSE;
            	        }
            	        else 
            	        {
            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = &FOLLOW_set_in_attrib452;
            	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_attrib452);    goto ruleattribEx;
            	        }

            	        if ( LA(1) == STRING || LA(1) == ID )
            	        {
            	            CONSUME();
            	            PERRORRECOVERY=ANTLR3_FALSE;
            	        }
            	        else 
            	        {
            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = &FOLLOW_set_in_attrib466;
            	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_attrib466);    goto ruleattribEx;
            	        }


            	    }
            	    break;

                }
            }
             MATCHT(50, &FOLLOW_50_in_attrib479); 
            if  (HASEXCEPTION())
            {
                goto ruleattribEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleattribEx; /* Prevent compiler warnings */
    ruleattribEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end attrib */

/** 
 * $ANTLR start pseudo
 * CSS.g:69:1: pseudo : ':' ( ID | FUNCTION ( ID )? ')' ) ;
 */
static void
pseudo(pCSSParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // CSS.g:70:3: ( ':' ( ID | FUNCTION ( ID )? ')' ) )
        // CSS.g:70:5: ':' ( ID | FUNCTION ( ID )? ')' )
        {
             MATCHT(41, &FOLLOW_41_in_pseudo492); 
            if  (HASEXCEPTION())
            {
                goto rulepseudoEx;
            }


            // CSS.g:70:9: ( ID | FUNCTION ( ID )? ')' )
            {
                int alt26=2;
                switch ( LA(1) ) 
                {
                case ID:
                	{
                		alt26=1;
                	}
                    break;
                case FUNCTION:
                	{
                		alt26=2;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 26;
                    EXCEPTION->state        = 0;


                    goto rulepseudoEx;
                }

                switch (alt26) 
                {
            	case 1:
            	    // CSS.g:70:11: ID
            	    {
            	         MATCHT(ID, &FOLLOW_ID_in_pseudo496); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepseudoEx;
            	        }


            	    }
            	    break;
            	case 2:
            	    // CSS.g:70:16: FUNCTION ( ID )? ')'
            	    {
            	         MATCHT(FUNCTION, &FOLLOW_FUNCTION_in_pseudo500); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepseudoEx;
            	        }


            	        // CSS.g:70:25: ( ID )?
            	        {
            	            int alt25=2;
            	            switch ( LA(1) ) 
            	            {
            	                case ID:
            	                	{
            	                		alt25=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt25) 
            	            {
            	        	case 1:
            	        	    // CSS.g:70:25: ID
            	        	    {
            	        	         MATCHT(ID, &FOLLOW_ID_in_pseudo502); 
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulepseudoEx;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }
            	         MATCHT(51, &FOLLOW_51_in_pseudo505); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepseudoEx;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepseudoEx; /* Prevent compiler warnings */
    rulepseudoEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end pseudo */

/** 
 * $ANTLR start declaration
 * CSS.g:73:1: declaration : ID ':' expr ( IMPORTANT )? ;
 */
static void
declaration(pCSSParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // CSS.g:74:3: ( ID ':' expr ( IMPORTANT )? )
        // CSS.g:74:5: ID ':' expr ( IMPORTANT )?
        {
             MATCHT(ID, &FOLLOW_ID_in_declaration520); 
            if  (HASEXCEPTION())
            {
                goto ruledeclarationEx;
            }

             MATCHT(41, &FOLLOW_41_in_declaration522); 
            if  (HASEXCEPTION())
            {
                goto ruledeclarationEx;
            }

            FOLLOWPUSH(FOLLOW_expr_in_declaration524);
            expr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledeclarationEx;
            }


            // CSS.g:74:17: ( IMPORTANT )?
            {
                int alt27=2;
                switch ( LA(1) ) 
                {
                    case IMPORTANT:
                    	{
                    		alt27=1;
                    	}
                        break;
                }

                switch (alt27) 
                {
            	case 1:
            	    // CSS.g:74:17: IMPORTANT
            	    {
            	         MATCHT(IMPORTANT, &FOLLOW_IMPORTANT_in_declaration526); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledeclarationEx;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruledeclarationEx; /* Prevent compiler warnings */
    ruledeclarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end declaration */

/** 
 * $ANTLR start expr
 * CSS.g:77:1: expr : term ( ( '/' | ',' )? term )* ;
 */
static void
expr(pCSSParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // CSS.g:78:3: ( term ( ( '/' | ',' )? term )* )
        // CSS.g:78:5: term ( ( '/' | ',' )? term )*
        {
            FOLLOWPUSH(FOLLOW_term_in_expr540);
            term(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleexprEx;
            }


            // CSS.g:78:10: ( ( '/' | ',' )? term )*

            for (;;)
            {
                int alt29=2;
                switch ( LA(1) ) 
                {
                case PERCENTAGE:
                case FUNCTION:
                case ANGLE:
                case LENGTH:
                case FREQ:
                case TIME:
                case EMS:
                case EXS:
                case STRING:
                case URI:
                case ID:
                case HASH:
                case NUMBER:
                case 39:
                case 42:
                case 52:
                case 53:
                	{
                		alt29=1;
                	}
                    break;

                }

                switch (alt29) 
                {
            	case 1:
            	    // CSS.g:78:12: ( '/' | ',' )? term
            	    {

            	        // CSS.g:78:12: ( '/' | ',' )?
            	        {
            	            int alt28=2;
            	            switch ( LA(1) ) 
            	            {
            	                case 39:
            	                case 52:
            	                	{
            	                		alt28=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt28) 
            	            {
            	        	case 1:
            	        	    // CSS.g:
            	        	    {
            	        	        if ( LA(1) == 39 || LA(1) == 52 )
            	        	        {
            	        	            CONSUME();
            	        	            PERRORRECOVERY=ANTLR3_FALSE;
            	        	        }
            	        	        else 
            	        	        {
            	        	            CONSTRUCTEX();
            	        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	        	            EXCEPTION->expectingSet = &FOLLOW_set_in_expr544;
            	        	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_expr544);    goto ruleexprEx;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }
            	        FOLLOWPUSH(FOLLOW_term_in_expr555);
            	        term(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexprEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop29;	/* break out of the loop */
            	    break;
                }
            }
            loop29: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleexprEx; /* Prevent compiler warnings */
    ruleexprEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end expr */

/** 
 * $ANTLR start term
 * CSS.g:81:1: term : ( ( '-' | '+' )? ( NUMBER | PERCENTAGE | LENGTH | EMS | EXS | ANGLE | TIME | FREQ ) | STRING | ID | URI | HASH | FUNCTION expr ')' );
 */
static void
term(pCSSParser ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  CSS.g:82:3: ( ( '-' | '+' )? ( NUMBER | PERCENTAGE | LENGTH | EMS | EXS | ANGLE | TIME | FREQ ) | STRING | ID | URI | HASH | FUNCTION expr ')' )
            
            ANTLR3_UINT32 alt31;

            alt31=6;

            switch ( LA(1) ) 
            {
            case PERCENTAGE:
            case ANGLE:
            case LENGTH:
            case FREQ:
            case TIME:
            case EMS:
            case EXS:
            case NUMBER:
            case 42:
            case 53:
            	{
            		alt31=1;
            	}
                break;
            case STRING:
            	{
            		alt31=2;
            	}
                break;
            case ID:
            	{
            		alt31=3;
            	}
                break;
            case URI:
            	{
            		alt31=4;
            	}
                break;
            case HASH:
            	{
            		alt31=5;
            	}
                break;
            case FUNCTION:
            	{
            		alt31=6;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 31;
                EXCEPTION->state        = 0;


                goto ruletermEx;
            }

            switch (alt31) 
            {
        	case 1:
        	    // CSS.g:82:5: ( '-' | '+' )? ( NUMBER | PERCENTAGE | LENGTH | EMS | EXS | ANGLE | TIME | FREQ )
        	    {

        	        // CSS.g:82:5: ( '-' | '+' )?
        	        {
        	            int alt30=2;
        	            switch ( LA(1) ) 
        	            {
        	                case 42:
        	                case 53:
        	                	{
        	                		alt30=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt30) 
        	            {
        	        	case 1:
        	        	    // CSS.g:
        	        	    {
        	        	        if ( LA(1) == 42 || LA(1) == 53 )
        	        	        {
        	        	            CONSUME();
        	        	            PERRORRECOVERY=ANTLR3_FALSE;
        	        	        }
        	        	        else 
        	        	        {
        	        	            CONSTRUCTEX();
        	        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
        	        	            EXCEPTION->expectingSet = &FOLLOW_set_in_term571;
        	        	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_term571);    goto ruletermEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }
        	        if ( LA(1) == PERCENTAGE || ((LA(1) >= ANGLE) && (LA(1) <= EXS)) || LA(1) == NUMBER )
        	        {
        	            CONSUME();
        	            PERRORRECOVERY=ANTLR3_FALSE;
        	        }
        	        else 
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
        	            EXCEPTION->expectingSet = &FOLLOW_set_in_term582;
        	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_term582);    goto ruletermEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // CSS.g:83:5: STRING
        	    {
        	         MATCHT(STRING, &FOLLOW_STRING_in_term620); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // CSS.g:84:5: ID
        	    {
        	         MATCHT(ID, &FOLLOW_ID_in_term626); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // CSS.g:85:5: URI
        	    {
        	         MATCHT(URI, &FOLLOW_URI_in_term632); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	    }
        	    break;
        	case 5:
        	    // CSS.g:86:5: HASH
        	    {
        	         MATCHT(HASH, &FOLLOW_HASH_in_term638); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	    }
        	    break;
        	case 6:
        	    // CSS.g:87:5: FUNCTION expr ')'
        	    {
        	         MATCHT(FUNCTION, &FOLLOW_FUNCTION_in_term650); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expr_in_term652);
        	        expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }

        	         MATCHT(51, &FOLLOW_51_in_term654); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruletermEx; /* Prevent compiler warnings */
    ruletermEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end term */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */

 
 



/* End of code
 * =============================================================================
 */
