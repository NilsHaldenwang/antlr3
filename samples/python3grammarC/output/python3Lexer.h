/** \file
 *  This C header file was generated by $ANTLR version 3.2.1-SNAPSHOT Jun 18, 2010 05:38:11
 *
 *     -  From the grammar source file : python3.g
 *     -                            On : 2010-08-07 07:08:23
 *     -                 for the lexer : python3LexerLexer *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
 * The lexer python3Lexer has the callable functions (rules) shown below,
 * which will invoke the code for the associated rule in the source grammar
 * assuming that the input stream is pointing to a token/text stream that could begin
 * this rule.
 * 
 * For instance if you call the first (topmost) rule in a parser grammar, you will
 * get the results of a full parse, but calling a rule half way through the grammar will
 * allow you to pass part of a full token stream to the parser, such as for syntax checking
 * in editors and so on.
 *
 * The parser entry points are called indirectly (by function pointer to function) via
 * a parser context typedef ppython3Lexer, which is returned from a call to python3LexerNew().
 *
 * As this is a generated lexer, it is unlikely you will call it 'manually'. However
 * the methods are provided anyway.
 * * The methods in ppython3Lexer are  as follows:
 *
 *  -  void      ppython3Lexer->T__118(ppython3Lexer)
 *  -  void      ppython3Lexer->STRINGLITERAL(ppython3Lexer)
 *  -  void      ppython3Lexer->STRINGPREFIX(ppython3Lexer)
 *  -  void      ppython3Lexer->SHORTSTRING(ppython3Lexer)
 *  -  void      ppython3Lexer->LONGSTRING(ppython3Lexer)
 *  -  void      ppython3Lexer->BYTESLITERAL(ppython3Lexer)
 *  -  void      ppython3Lexer->BYTESPREFIX(ppython3Lexer)
 *  -  void      ppython3Lexer->SHORTBYTES(ppython3Lexer)
 *  -  void      ppython3Lexer->LONGBYTES(ppython3Lexer)
 *  -  void      ppython3Lexer->TRIAPOS(ppython3Lexer)
 *  -  void      ppython3Lexer->TRIQUOTE(ppython3Lexer)
 *  -  void      ppython3Lexer->ESCAPESEQ(ppython3Lexer)
 *  -  void      ppython3Lexer->FALSE(ppython3Lexer)
 *  -  void      ppython3Lexer->NONE(ppython3Lexer)
 *  -  void      ppython3Lexer->TRUE(ppython3Lexer)
 *  -  void      ppython3Lexer->AND(ppython3Lexer)
 *  -  void      ppython3Lexer->AS(ppython3Lexer)
 *  -  void      ppython3Lexer->ASSERT(ppython3Lexer)
 *  -  void      ppython3Lexer->FOR(ppython3Lexer)
 *  -  void      ppython3Lexer->BREAK(ppython3Lexer)
 *  -  void      ppython3Lexer->CLASS(ppython3Lexer)
 *  -  void      ppython3Lexer->CONTINUE(ppython3Lexer)
 *  -  void      ppython3Lexer->DEF(ppython3Lexer)
 *  -  void      ppython3Lexer->DEL(ppython3Lexer)
 *  -  void      ppython3Lexer->ELIF(ppython3Lexer)
 *  -  void      ppython3Lexer->ELSE(ppython3Lexer)
 *  -  void      ppython3Lexer->EXCEPT(ppython3Lexer)
 *  -  void      ppython3Lexer->FINALLY(ppython3Lexer)
 *  -  void      ppython3Lexer->FROM(ppython3Lexer)
 *  -  void      ppython3Lexer->GLOBAL(ppython3Lexer)
 *  -  void      ppython3Lexer->IF(ppython3Lexer)
 *  -  void      ppython3Lexer->IMPORT(ppython3Lexer)
 *  -  void      ppython3Lexer->IN(ppython3Lexer)
 *  -  void      ppython3Lexer->IS(ppython3Lexer)
 *  -  void      ppython3Lexer->LAMBDA(ppython3Lexer)
 *  -  void      ppython3Lexer->NONLOCAL(ppython3Lexer)
 *  -  void      ppython3Lexer->NOT(ppython3Lexer)
 *  -  void      ppython3Lexer->OR(ppython3Lexer)
 *  -  void      ppython3Lexer->PASS(ppython3Lexer)
 *  -  void      ppython3Lexer->RAISE(ppython3Lexer)
 *  -  void      ppython3Lexer->RETURN(ppython3Lexer)
 *  -  void      ppython3Lexer->TRY(ppython3Lexer)
 *  -  void      ppython3Lexer->WHILE(ppython3Lexer)
 *  -  void      ppython3Lexer->WITH(ppython3Lexer)
 *  -  void      ppython3Lexer->YIELD(ppython3Lexer)
 *  -  void      ppython3Lexer->INTEGER(ppython3Lexer)
 *  -  void      ppython3Lexer->DECIMALINTEGER(ppython3Lexer)
 *  -  void      ppython3Lexer->NONZERODIGIT(ppython3Lexer)
 *  -  void      ppython3Lexer->DIGIT(ppython3Lexer)
 *  -  void      ppython3Lexer->OCTINTEGER(ppython3Lexer)
 *  -  void      ppython3Lexer->HEXINTEGER(ppython3Lexer)
 *  -  void      ppython3Lexer->BININTEGER(ppython3Lexer)
 *  -  void      ppython3Lexer->OCTDIGIT(ppython3Lexer)
 *  -  void      ppython3Lexer->HEXDIGIT(ppython3Lexer)
 *  -  void      ppython3Lexer->BINDIGIT(ppython3Lexer)
 *  -  void      ppython3Lexer->FLOATNUMBER(ppython3Lexer)
 *  -  void      ppython3Lexer->POINTFLOAT(ppython3Lexer)
 *  -  void      ppython3Lexer->EXPONENTFLOAT(ppython3Lexer)
 *  -  void      ppython3Lexer->INTPART(ppython3Lexer)
 *  -  void      ppython3Lexer->FRACTION(ppython3Lexer)
 *  -  void      ppython3Lexer->EXPONENT(ppython3Lexer)
 *  -  void      ppython3Lexer->IMAGNUMBER(ppython3Lexer)
 *  -  void      ppython3Lexer->IDENTIFIER(ppython3Lexer)
 *  -  void      ppython3Lexer->ID_START(ppython3Lexer)
 *  -  void      ppython3Lexer->ID_CONTINUE(ppython3Lexer)
 *  -  void      ppython3Lexer->PLUS(ppython3Lexer)
 *  -  void      ppython3Lexer->MINUS(ppython3Lexer)
 *  -  void      ppython3Lexer->STAR(ppython3Lexer)
 *  -  void      ppython3Lexer->DOUBLESTAR(ppython3Lexer)
 *  -  void      ppython3Lexer->SLASH(ppython3Lexer)
 *  -  void      ppython3Lexer->DOUBLESLASH(ppython3Lexer)
 *  -  void      ppython3Lexer->PERCENT(ppython3Lexer)
 *  -  void      ppython3Lexer->LEFTSHIFT(ppython3Lexer)
 *  -  void      ppython3Lexer->RIGHTSHIFT(ppython3Lexer)
 *  -  void      ppython3Lexer->AMPERSAND(ppython3Lexer)
 *  -  void      ppython3Lexer->VBAR(ppython3Lexer)
 *  -  void      ppython3Lexer->CIRCUMFLEX(ppython3Lexer)
 *  -  void      ppython3Lexer->TILDE(ppython3Lexer)
 *  -  void      ppython3Lexer->LESS(ppython3Lexer)
 *  -  void      ppython3Lexer->GREATER(ppython3Lexer)
 *  -  void      ppython3Lexer->LESSEQUAL(ppython3Lexer)
 *  -  void      ppython3Lexer->GREATEREQUAL(ppython3Lexer)
 *  -  void      ppython3Lexer->EQUAL(ppython3Lexer)
 *  -  void      ppython3Lexer->NOTEQUAL(ppython3Lexer)
 *  -  void      ppython3Lexer->LPAREN(ppython3Lexer)
 *  -  void      ppython3Lexer->RPAREN(ppython3Lexer)
 *  -  void      ppython3Lexer->LBRACK(ppython3Lexer)
 *  -  void      ppython3Lexer->RBRACK(ppython3Lexer)
 *  -  void      ppython3Lexer->LCURLY(ppython3Lexer)
 *  -  void      ppython3Lexer->RCURLY(ppython3Lexer)
 *  -  void      ppython3Lexer->COMMA(ppython3Lexer)
 *  -  void      ppython3Lexer->COLON(ppython3Lexer)
 *  -  void      ppython3Lexer->DOT(ppython3Lexer)
 *  -  void      ppython3Lexer->SEMI(ppython3Lexer)
 *  -  void      ppython3Lexer->AT(ppython3Lexer)
 *  -  void      ppython3Lexer->ASSIGN(ppython3Lexer)
 *  -  void      ppython3Lexer->PLUSEQUAL(ppython3Lexer)
 *  -  void      ppython3Lexer->MINUSEQUAL(ppython3Lexer)
 *  -  void      ppython3Lexer->STAREQUAL(ppython3Lexer)
 *  -  void      ppython3Lexer->SLASHEQUAL(ppython3Lexer)
 *  -  void      ppython3Lexer->DOUBLESLASHEQUAL(ppython3Lexer)
 *  -  void      ppython3Lexer->PERCENTEQUAL(ppython3Lexer)
 *  -  void      ppython3Lexer->AMPERSANDEQUAL(ppython3Lexer)
 *  -  void      ppython3Lexer->VBAREQUAL(ppython3Lexer)
 *  -  void      ppython3Lexer->CIRCUMFLEXEQUAL(ppython3Lexer)
 *  -  void      ppython3Lexer->LEFTSHIFTEQUAL(ppython3Lexer)
 *  -  void      ppython3Lexer->RIGHTSHIFTEQUAL(ppython3Lexer)
 *  -  void      ppython3Lexer->DOUBLESTAREQUAL(ppython3Lexer)
 *  -  void      ppython3Lexer->CONTINUED_LINE(ppython3Lexer)
 *  -  void      ppython3Lexer->NEWLINE(ppython3Lexer)
 *  -  void      ppython3Lexer->WS(ppython3Lexer)
 *  -  void      ppython3Lexer->LEADING_WS(ppython3Lexer)
 *  -  void      ppython3Lexer->COMMENT(ppython3Lexer)
 *  -  void      ppython3Lexer->DEDENT(ppython3Lexer)
 *  -  void      ppython3Lexer->INDENT(ppython3Lexer)
 *  -  void      ppython3Lexer->Tokens(ppython3Lexer)
 *
 * The return type for any particular rule is of course determined by the source
 * grammar file.
 */
// [The "BSD licence"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#ifndef	_python3Lexer_H
#define _python3Lexer_H
/* =============================================================================
 * Standard antlr3 C runtime definitions
 */
#include    <antlr3.h>

/* End of standard antlr 3 runtime definitions
 * =============================================================================
 */
 
#ifdef __cplusplus
extern "C" {
#endif

// Forward declare the context typedef so that we can use it before it is
// properly defined. Delegators and delegates (from import statements) are
// interdependent and their context structures contain pointers to each other
// C only allows such things to be declared if you pre-declare the typedef.
//
typedef struct python3Lexer_Ctx_struct python3Lexer, * ppython3Lexer;



	#define ANTLR3_INLINE_INPUT_ASCII


#ifdef	ANTLR3_WINDOWS
// Disable: Unreferenced parameter,							- Rules with parameters that are not used
//          constant conditional,							- ANTLR realizes that a prediction is always true (synpred usually)
//          initialized but unused variable					- tree rewrite variables declared but not needed
//          Unreferenced local variable						- lexer rule declares but does not always use _type
//          potentially unitialized variable used			- retval always returned from a rule 
//			unreferenced local function has been removed	- susually getTokenNames or freeScope, they can go without warnigns
//
// These are only really displayed at warning level /W4 but that is the code ideal I am aiming at
// and the codegen must generate some of these warnings by necessity, apart from 4100, which is
// usually generated when a parser rule is given a parameter that it does not use. Mostly though
// this is a matter of orthogonality hence I disable that one.
//
#pragma warning( disable : 4100 )
#pragma warning( disable : 4101 )
#pragma warning( disable : 4127 )
#pragma warning( disable : 4189 )
#pragma warning( disable : 4505 )
#pragma warning( disable : 4701 )
#endif

/** Context tracking structure for python3Lexer
 */
struct python3Lexer_Ctx_struct
{
    /** Built in ANTLR3 context tracker contains all the generic elements
     *  required for context tracking.
     */
    pANTLR3_LEXER    pLexer;


     void (*mT__118)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mSTRINGLITERAL)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mSTRINGPREFIX)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mSHORTSTRING)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mLONGSTRING)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mBYTESLITERAL)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mBYTESPREFIX)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mSHORTBYTES)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mLONGBYTES)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mTRIAPOS)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mTRIQUOTE)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mESCAPESEQ)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mFALSE)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mNONE)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mTRUE)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mAND)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mAS)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mASSERT)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mFOR)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mBREAK)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mCLASS)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mCONTINUE)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mDEF)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mDEL)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mELIF)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mELSE)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mEXCEPT)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mFINALLY)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mFROM)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mGLOBAL)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mIF)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mIMPORT)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mIN)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mIS)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mLAMBDA)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mNONLOCAL)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mNOT)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mOR)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mPASS)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mRAISE)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mRETURN)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mTRY)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mWHILE)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mWITH)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mYIELD)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mINTEGER)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mDECIMALINTEGER)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mNONZERODIGIT)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mDIGIT)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mOCTINTEGER)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mHEXINTEGER)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mBININTEGER)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mOCTDIGIT)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mHEXDIGIT)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mBINDIGIT)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mFLOATNUMBER)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mPOINTFLOAT)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mEXPONENTFLOAT)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mINTPART)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mFRACTION)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mEXPONENT)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mIMAGNUMBER)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mIDENTIFIER)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mID_START)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mID_CONTINUE)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mPLUS)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mMINUS)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mSTAR)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mDOUBLESTAR)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mSLASH)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mDOUBLESLASH)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mPERCENT)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mLEFTSHIFT)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mRIGHTSHIFT)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mAMPERSAND)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mVBAR)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mCIRCUMFLEX)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mTILDE)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mLESS)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mGREATER)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mLESSEQUAL)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mGREATEREQUAL)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mEQUAL)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mNOTEQUAL)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mLPAREN)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mRPAREN)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mLBRACK)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mRBRACK)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mLCURLY)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mRCURLY)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mCOMMA)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mCOLON)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mDOT)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mSEMI)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mAT)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mASSIGN)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mPLUSEQUAL)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mMINUSEQUAL)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mSTAREQUAL)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mSLASHEQUAL)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mDOUBLESLASHEQUAL)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mPERCENTEQUAL)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mAMPERSANDEQUAL)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mVBAREQUAL)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mCIRCUMFLEXEQUAL)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mLEFTSHIFTEQUAL)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mRIGHTSHIFTEQUAL)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mDOUBLESTAREQUAL)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mCONTINUED_LINE)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mNEWLINE)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mWS)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mLEADING_WS)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mCOMMENT)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mDEDENT)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mINDENT)	(struct python3Lexer_Ctx_struct * ctx);
     void (*mTokens)	(struct python3Lexer_Ctx_struct * ctx);
    const char * (*getGrammarFileName)();
    void            (*reset)  (struct python3Lexer_Ctx_struct * ctx);
    void	    (*free)   (struct python3Lexer_Ctx_struct * ctx);
        

    	ANTLR3_INT32 implicitLineJoiningLevel;
    	ANTLR3_INT32 startPos;

    	pANTLR3_STACK identStack;
    	pANTLR3_VECTOR tokens;

    	void (*origFree) (struct python3Lexer_Ctx_struct * ctx);
    	pANTLR3_COMMON_TOKEN (*origNextToken)(pANTLR3_TOKEN_SOURCE toksource);

};

// Function protoypes for the constructor functions that external translation units
// such as delegators and delegates may wish to call.
//
ANTLR3_API ppython3Lexer python3LexerNew         (pANTLR3_INPUT_STREAM instream);
ANTLR3_API ppython3Lexer python3LexerNewSSD      (pANTLR3_INPUT_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state);

/** Symbolic definitions of all the tokens that the lexer will work with.
 * \{
 *
 * Antlr will define EOF, but we can't use that as it it is too common in
 * in C header files and that would be confusing. There is no way to filter this out at the moment
 * so we just undef it here for now. That isn't the value we get back from C recognizers
 * anyway. We are looking for ANTLR3_TOKEN_EOF.
 */
#ifdef	EOF
#undef	EOF
#endif
#ifdef	Tokens
#undef	Tokens
#endif 
#define SLASHEQUAL      57
#define EXPONENT      111
#define STAR      14
#define NONZERODIGIT      102
#define CIRCUMFLEXEQUAL      61
#define WHILE      36
#define TRIAPOS      93
#define GREATEREQUAL      50
#define LONGBYTES      97
#define NOT      46
#define EXCEPT      40
#define EOF      -1
#define BREAK      21
#define PASS      20
#define LEADING_WS      116
#define NOTEQUAL      52
#define VBAR      66
#define MINUSEQUAL      55
#define RPAREN      10
#define OCTINTEGER      99
#define IMPORT      30
#define GREATER      48
#define DOUBLESTAREQUAL      64
#define LESS      47
#define RETURN      23
#define RAISE      24
#define COMMENT      117
#define AMPERSANDEQUAL      59
#define SHORTBYTES      96
#define RBRACK      78
#define NONLOCAL      27
#define ELSE      35
#define ESCAPESEQ      92
#define LCURLY      79
#define RIGHTSHIFT      70
#define ASSERT      28
#define TRY      39
#define SHORTSTRING      90
#define DOUBLESLASHEQUAL      65
#define ELIF      34
#define WS      115
#define INTPART      109
#define BINDIGIT      106
#define VBAREQUAL      60
#define NONE      81
#define OR      44
#define BYTESLITERAL      85
#define FLOATNUMBER      87
#define FROM      25
#define FALSE      83
#define LESSEQUAL      51
#define PERCENTEQUAL      58
#define DOUBLESLASH      75
#define EXPONENTFLOAT      108
#define CLASS      7
#define CONTINUED_LINE      114
#define LBRACK      77
#define DEF      12
#define DOUBLESTAR      15
#define T__118      118
#define BYTESPREFIX      95
#define DEL      19
#define OCTDIGIT      104
#define BININTEGER      101
#define FOR      37
#define DEDENT      5
#define AND      45
#define RIGHTSHIFTEQUAL      63
#define POINTFLOAT      107
#define INDENT      4
#define LPAREN      9
#define IF      33
#define PLUSEQUAL      54
#define STRINGPREFIX      89
#define AT      17
#define AS      32
#define SLASH      73
#define IN      38
#define CONTINUE      22
#define COMMA      13
#define IS      53
#define IDENTIFIER      11
#define EQUAL      49
#define YIELD      29
#define TILDE      76
#define LEFTSHIFTEQUAL      62
#define LEFTSHIFT      69
#define PLUS      71
#define LAMBDA      43
#define DIGIT      103
#define DOT      31
#define IMAGNUMBER      88
#define WITH      42
#define INTEGER      86
#define PERCENT      74
#define AMPERSAND      68
#define HEXINTEGER      100
#define MINUS      72
#define TRUE      82
#define SEMI      18
#define LONGSTRING      91
#define COLON      8
#define TRIQUOTE      94
#define NEWLINE      6
#define FINALLY      41
#define STRINGLITERAL      84
#define RCURLY      80
#define ASSIGN      16
#define ID_CONTINUE      113
#define DECIMALINTEGER      98
#define GLOBAL      26
#define FRACTION      110
#define ID_START      112
#define STAREQUAL      56
#define CIRCUMFLEX      67
#define HEXDIGIT      105
#ifdef	EOF
#undef	EOF
#define	EOF	ANTLR3_TOKEN_EOF
#endif

#ifndef TOKENSOURCE
#define TOKENSOURCE(lxr) lxr->pLexer->rec->state->tokSource
#endif

/* End of token definitions for python3Lexer
 * =============================================================================
 */
/** \} */

#ifdef __cplusplus
}
#endif

#endif

/* END - Note:Keep extra line feed to satisfy UNIX systems */
