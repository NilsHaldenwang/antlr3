#!/usr/bin/ruby
# encoding: utf-8

Ruby.setup
establish 'cli-main'
establish 'console'
Ruby.project ||= 'antlr3'
project.globalize
project.setup_extras

require 'string-template'
require 'inflection/import'
require 'core/string/path-join'

Main do
  
  mode(:unzip) do
    argument(:file) do
      description("The stg file to break up into parts")
      validate do |pt|
        pt =~ /\.stg$/i
      end
      arity -2
    end
    
    option('directory', 'd') do
      description("The directory to put the output")
      argument_required
      validate do |pt|
        test(?d, pt)
      end
      default('.')
    end
    
    option('numbers', 'n') do
      description "Prefix template files with the index of the template"
      argument_optional
    end
    
    def run
      base_directory = params[:directory].value
      for file in params[:file].values
        @group = StringTemplate::Group.load(file)
        @directory = base_directory / @group.name
        @members = @group.members.clone
        @digits = Math.log10(@members.length).floor + 1
        @index = []
        
        test(?d, @directory) or Dir.mkdir(@directory)
        
        stdout.printf("< in %s >\n", @directory)
        
        tokens = @group.tokens.clone
        
        open(@directory / @group.name << '.stg', 'w') do |manifest|
          cursor = 0
          head = nil
          
          print_tokens = lambda do |stream, next_head|
            for token in tokens[cursor...head]
              stream.print(token.text)
            end
            cursor = head
            head = next_head
          end
          
          until @members.empty?
            case member = @members.shift
            when StringTemplate::Comment
              member.doc_comment? and head = member.span.begin
            when StringTemplate::Template, StringTemplate::TypeMap
              head ||= member.span.begin
              print_tokens[manifest, member.span.end + 1]
              name = file_name(member)
              open(@directory / name, 'w') do |template_file|
                print_tokens[template_file, head]
                manifest.puts("<%= #{name} %>")
              end
              stdout.printf("  => wrote %s\n", name)
            end
          end
          head = tokens.length
          print_tokens[manifest, nil]
        end
      end
    end
    
    def file_name(template)
      if params[:numbers].given?
        "%0#{@digits}i_%s.st" % [@index.length, template.name]
      else
        '%s.st' % template.name
      end
    end
    
  end
  
  mode(:zip) do
    option(:file) do
      argument_required
      description("The name of the output stg file")
      validate do |pt|
        test(?d, File.dirname(pt))
      end
    end
    
    argument('directory', 'd') do
      description("The base directory containing the stg parts")
      validate do |pt|
        test(?d, pt)
      end
    end
    
    def reconstruct(directory)
      manifest = load_manifest(directory)
      manifest.gsub!(/<%=(.+)%>/) do
        name = $1; name.strip!
        name =~ /\.st$/ or name << '.st'
        template = directory / name
        if test(?f, template) then File.read(template)
        else
          $stderr.printf("-> file %s mentioned in the manifest doesn't exist; skipping it\n",
                         template)
          ''
        end
      end
      return manifest
    end
    
    def load_manifest(directory)
      group_name = File.basename(directory)
      manifest_path = directory / "#{group_name}.stg"
      unless test(?f, manifest_path)
        $stderr.puts("could not find manifest file %s" % manifest_path)
        exit_failure
      end
      
      return File.read(manifest_path)
    end
    
    def run
      directory = params[:directory].value
      
      new_group_source = reconstruct(directory)
      
      begin
        StringTemplate::Group.parse(new_group_source)
      rescue StringTemplate::GroupParser::ParseError => error
        $stderr.puts("successfully zipped the templates, but the resulting group seems to have syntax errors")
        $stderr.puts("#{error.class}: #{error.message}")
        $stderr.puts("- " * 40)
        $stderr.puts(error.source_range(2).indent(2))
        $stderr.puts("- " * 40)
        $stderr.puts(error.backtrace.map { |ln| "  - #{ln}" })
      end
      
      puts(new_group_source)
      #output_file = params[:file].value ||
      #  (File.dirname(params[:directory].value) / group_name << '.stg')
      #
      #if test(?f, output_file)
      #  agree("overwrite #{output_file}? [y/n] ") or exit(1)
      #end
      #
      #open(output_file, 'w') do |f|
      #  f.puts("group #{group_name};\n")
      #  for segment in segments
      #    f.puts(segment, "\n")
      #  end
      #end
      #$stderr.puts("wrote #{output_file}")
      #
      #begin
      #  StringTemplate::Group.load(output_file)
      #rescue => err
      #  $stderr.puts("there are problems with #{output_file}!")
      #  $stderr.puts("when parsing the assembled file, got error: #{err}")
      #  $stderr.puts(err.backtrace)
      #else
      #  $stderr.puts("parsed #{output_file} successfully -- everything seems ok")
      #end
    end
    
  end
  
  def run
    help!
  end
  
end
